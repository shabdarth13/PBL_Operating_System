# @generated by tools/pyi/gen_pyi.py from torch/_C/_VariableFunctions.pyi.in
# mypy: disable-error-code="type-arg"
# mypy: allow-untyped-defs
# ruff: noqa: F401,PYI054

from collections.abc import Sequence
from types import EllipsisType
from typing import Any, Callable, Literal, overload, TypeVar

import torch
from torch import (
    contiguous_format,
    Generator,
    inf,
    memory_format,
    strided,
    SymInt,
    Tensor,
)
from torch._prims_common import DeviceLikeType
from torch.types import (
    _bool,
    _complex,
    _device,
    _dtype,
    _float,
    _int,
    _layout,
    _qscheme,
    _size,
    Device,
    Number,
)

__all__ = [
    "__and__",
    "__lshift__",
    "__or__",
    "__rshift__",
    "__xor__",
    "_adaptive_avg_pool2d",
    "_adaptive_avg_pool3d",
    "_add_batch_dim",
    "_add_relu",
    "_add_relu_",
    "_addmm_activation",
    "_aminmax",
    "_amp_foreach_non_finite_check_and_unscale_",
    "_amp_update_scale_",
    "_assert_async",
    "_assert_scalar",
    "_assert_tensor_metadata",
    "_batch_norm_impl_index",
    "_cast_Byte",
    "_cast_Char",
    "_cast_Double",
    "_cast_Float",
    "_cast_Half",
    "_cast_Int",
    "_cast_Long",
    "_cast_Short",
    "_choose_qparams_per_tensor",
    "_chunk_cat",
    "_coalesce",
    "_compute_linear_combination",
    "_conj",
    "_conj_copy",
    "_conj_physical",
    "_convert_indices_from_coo_to_csr",
    "_convert_indices_from_csr_to_coo",
    "_convert_weight_to_int4pack",
    "_convert_weight_to_int4pack_for_cpu",
    "_convolution",
    "_convolution_mode",
    "_copy_from",
    "_copy_from_and_resize",
    "_cslt_compress",
    "_cslt_sparse_mm",
    "_cslt_sparse_mm_search",
    "_ctc_loss",
    "_cudnn_ctc_loss",
    "_cudnn_init_dropout_state",
    "_cudnn_rnn",
    "_cudnn_rnn_flatten_weight",
    "_cufft_clear_plan_cache",
    "_cufft_get_plan_cache_max_size",
    "_cufft_get_plan_cache_size",
    "_cufft_set_plan_cache_max_size",
    "_cummax_helper",
    "_cummin_helper",
    "_debug_has_internal_overlap",
    "_dim_arange",
    "_dirichlet_grad",
    "_disable_functionalization",
    "_dyn_quant_matmul_4bit",
    "_dyn_quant_pack_4bit_weight",
    "_efficientzerotensor",
    "_embedding_bag",
    "_embedding_bag_forward_only",
    "_empty_affine_quantized",
    "_empty_per_channel_affine_quantized",
    "_enable_functionalization",
    "_euclidean_dist",
    "_fake_quantize_learnable_per_channel_affine",
    "_fake_quantize_learnable_per_tensor_affine",
    "_fake_quantize_per_tensor_affine_cachemask_tensor_qparams",
    "_fake_quantize_per_tensor_affine_cachemask_tensor_qparams",
    "_fft_c2c",
    "_fft_c2r",
    "_fft_r2c",
    "_fill_mem_eff_dropout_mask_",
    "_foobar",
    "_foreach_abs",
    "_foreach_abs_",
    "_foreach_acos",
    "_foreach_acos_",
    "_foreach_add",
    "_foreach_add_",
    "_foreach_addcdiv",
    "_foreach_addcdiv_",
    "_foreach_addcmul",
    "_foreach_addcmul_",
    "_foreach_asin",
    "_foreach_asin_",
    "_foreach_atan",
    "_foreach_atan_",
    "_foreach_ceil",
    "_foreach_ceil_",
    "_foreach_clamp_max",
    "_foreach_clamp_max_",
    "_foreach_clamp_min",
    "_foreach_clamp_min_",
    "_foreach_copy_",
    "_foreach_cos",
    "_foreach_cos_",
    "_foreach_cosh",
    "_foreach_cosh_",
    "_foreach_div",
    "_foreach_div_",
    "_foreach_erf",
    "_foreach_erf_",
    "_foreach_erfc",
    "_foreach_erfc_",
    "_foreach_exp",
    "_foreach_exp_",
    "_foreach_expm1",
    "_foreach_expm1_",
    "_foreach_floor",
    "_foreach_floor_",
    "_foreach_frac",
    "_foreach_frac_",
    "_foreach_lerp",
    "_foreach_lerp_",
    "_foreach_lgamma",
    "_foreach_lgamma_",
    "_foreach_log",
    "_foreach_log10",
    "_foreach_log10_",
    "_foreach_log1p",
    "_foreach_log1p_",
    "_foreach_log2",
    "_foreach_log2_",
    "_foreach_log_",
    "_foreach_max",
    "_foreach_maximum",
    "_foreach_maximum_",
    "_foreach_minimum",
    "_foreach_minimum_",
    "_foreach_mul",
    "_foreach_mul_",
    "_foreach_neg",
    "_foreach_neg_",
    "_foreach_norm",
    "_foreach_pow",
    "_foreach_pow_",
    "_foreach_reciprocal",
    "_foreach_reciprocal_",
    "_foreach_round",
    "_foreach_round_",
    "_foreach_rsqrt",
    "_foreach_rsqrt_",
    "_foreach_sigmoid",
    "_foreach_sigmoid_",
    "_foreach_sign",
    "_foreach_sign_",
    "_foreach_sin",
    "_foreach_sin_",
    "_foreach_sinh",
    "_foreach_sinh_",
    "_foreach_sqrt",
    "_foreach_sqrt_",
    "_foreach_sub",
    "_foreach_sub_",
    "_foreach_tan",
    "_foreach_tan_",
    "_foreach_tanh",
    "_foreach_tanh_",
    "_foreach_trunc",
    "_foreach_trunc_",
    "_foreach_zero_",
    "_from_functional_tensor",
    "_functional_assert_async",
    "_functional_assert_scalar",
    "_functional_sym_constrain_range",
    "_functional_sym_constrain_range_for_size",
    "_functionalize_apply_view_metas",
    "_functionalize_are_all_mutations_hidden_from_autograd",
    "_functionalize_are_all_mutations_under_no_grad_or_inference_mode",
    "_functionalize_commit_update",
    "_functionalize_has_metadata_mutation",
    "_functionalize_is_symbolic",
    "_functionalize_mark_mutation_hidden_from_autograd",
    "_functionalize_replace",
    "_functionalize_set_storage_changed",
    "_functionalize_sync",
    "_functionalize_unsafe_set",
    "_functionalize_was_inductor_storage_resized",
    "_functionalize_was_storage_changed",
    "_fused_adagrad_",
    "_fused_adam_",
    "_fused_adamw_",
    "_fused_dropout",
    "_fused_moving_avg_obs_fq_helper",
    "_fused_moving_avg_obs_fq_helper",
    "_fused_rms_norm",
    "_fused_sdp_choice",
    "_fused_sgd_",
    "_fw_primal_copy",
    "_grid_sampler_2d_cpu_fallback",
    "_grouped_mm",
    "_has_compatible_shallow_copy_type",
    "_histogramdd_bin_edges",
    "_histogramdd_from_bin_cts",
    "_histogramdd_from_bin_tensors",
    "_index_put_impl_",
    "_indices_copy",
    "_int_mm",
    "_is_all_true",
    "_is_any_true",
    "_is_functional_tensor",
    "_is_functional_tensor_base",
    "_is_zerotensor",
    "_lazy_clone",
    "_linalg_check_errors",
    "_linalg_det",
    "_linalg_det",
    "_linalg_eigh",
    "_linalg_eigh",
    "_linalg_slogdet",
    "_linalg_slogdet",
    "_linalg_solve_ex",
    "_linalg_solve_ex",
    "_linalg_svd",
    "_linalg_svd",
    "_log_softmax",
    "_log_softmax_backward_data",
    "_logcumsumexp",
    "_lstm_mps",
    "_lu_with_info",
    "_lu_with_info",
    "_make_dep_token",
    "_make_dual",
    "_make_dual_copy",
    "_make_per_channel_quantized_tensor",
    "_make_per_tensor_quantized_tensor",
    "_masked_scale",
    "_masked_softmax",
    "_mixed_dtypes_linear",
    "_mkldnn_reshape",
    "_mkldnn_transpose",
    "_mkldnn_transpose_",
    "_mps_convolution",
    "_mps_convolution_transpose",
    "_native_batch_norm_legit",
    "_native_batch_norm_legit_no_training",
    "_native_multi_head_attention",
    "_neg_view",
    "_neg_view_copy",
    "_nested_compute_contiguous_strides_offsets",
    "_nested_from_padded",
    "_nested_from_padded_and_nested_example",
    "_nested_from_padded_tensor",
    "_nested_get_jagged_dummy",
    "_nested_get_lengths",
    "_nested_get_max_seqlen",
    "_nested_get_min_seqlen",
    "_nested_get_offsets",
    "_nested_get_ragged_idx",
    "_nested_get_values",
    "_nested_get_values_copy",
    "_nested_tensor_from_mask",
    "_nested_tensor_from_mask_left_aligned",
    "_nested_tensor_from_tensor_list",
    "_nested_tensor_softmax_with_shape",
    "_nested_view_from_buffer",
    "_nested_view_from_buffer_copy",
    "_nested_view_from_jagged",
    "_nested_view_from_jagged_copy",
    "_nnpack_available",
    "_nnpack_spatial_convolution",
    "_pack_padded_sequence",
    "_pad_packed_sequence",
    "_pin_memory",
    "_prelu_kernel",
    "_print",
    "_propagate_xla_data",
    "_remove_batch_dim",
    "_reshape_alias_copy",
    "_reshape_from_tensor",
    "_resize_output_",
    "_rowwise_prune",
    "_safe_softmax",
    "_sample_dirichlet",
    "_saturate_weight_to_fp16",
    "_scaled_dot_product_attention_math",
    "_scaled_dot_product_attention_math_for_mps",
    "_scaled_dot_product_cudnn_attention",
    "_scaled_dot_product_cudnn_attention",
    "_scaled_dot_product_efficient_attention",
    "_scaled_dot_product_efficient_attention",
    "_scaled_dot_product_flash_attention",
    "_scaled_dot_product_flash_attention",
    "_scaled_dot_product_flash_attention_for_cpu",
    "_scaled_dot_product_flash_attention_for_cpu",
    "_scaled_grouped_mm",
    "_scaled_mm",
    "_shape_as_tensor",
    "_sobol_engine_draw",
    "_sobol_engine_ff_",
    "_sobol_engine_initialize_state_",
    "_sobol_engine_scramble_",
    "_softmax",
    "_softmax_backward_data",
    "_sparse_broadcast_to",
    "_sparse_broadcast_to_copy",
    "_sparse_csr_prod",
    "_sparse_csr_sum",
    "_sparse_log_softmax_backward_data",
    "_sparse_semi_structured_addmm",
    "_sparse_semi_structured_apply",
    "_sparse_semi_structured_apply_dense",
    "_sparse_semi_structured_linear",
    "_sparse_semi_structured_mm",
    "_sparse_semi_structured_tile",
    "_sparse_softmax_backward_data",
    "_sparse_sparse_matmul",
    "_sparse_sum",
    "_stack",
    "_standard_gamma",
    "_standard_gamma_grad",
    "_sync",
    "_test_autograd_multiple_dispatch",
    "_test_autograd_multiple_dispatch_view",
    "_test_autograd_multiple_dispatch_view_copy",
    "_test_check_tensor",
    "_test_functorch_fallback",
    "_test_parallel_materialize",
    "_test_serialization_subcmul",
    "_to_cpu",
    "_to_functional_tensor",
    "_to_sparse_semi_structured",
    "_transform_bias_rescale_qkv",
    "_transformer_encoder_layer_fwd",
    "_trilinear",
    "_triton_multi_head_attention",
    "_triton_scaled_dot_attention",
    "_unique",
    "_unique2",
    "_unpack_dual",
    "_unpack_dual",
    "_unsafe_index",
    "_unsafe_index_put",
    "_unsafe_masked_index",
    "_unsafe_masked_index_put_accumulate",
    "_use_cudnn_ctc_loss",
    "_use_cudnn_rnn_flatten_weight",
    "_validate_compressed_sparse_indices",
    "_validate_sparse_bsc_tensor_args",
    "_validate_sparse_bsr_tensor_args",
    "_validate_sparse_compressed_tensor_args",
    "_validate_sparse_coo_tensor_args",
    "_validate_sparse_csc_tensor_args",
    "_validate_sparse_csr_tensor_args",
    "_values_copy",
    "_weight_int4pack_mm",
    "_weight_int4pack_mm_for_cpu",
    "_weight_int4pack_mm_with_scales_and_zeros",
    "_weight_int8pack_mm",
    "_weight_norm",
    "_weight_norm_interface",
    "_wrapped_linear_prepack",
    "_wrapped_quantized_linear_prepacked",
    "abs",
    "abs_",
    "absolute",
    "acos",
    "acos_",
    "acosh",
    "acosh_",
    "adaptive_avg_pool1d",
    "adaptive_max_pool1d",
    "add",
    "addbmm",
    "addcdiv",
    "addcmul",
    "addmm",
    "addmv",
    "addmv_",
    "addr",
    "adjoint",
    "affine_grid_generator",
    "alias_copy",
    "all",
    "allclose",
    "alpha_dropout",
    "alpha_dropout_",
    "amax",
    "amin",
    "aminmax",
    "aminmax",
    "angle",
    "any",
    "arange",
    "arccos",
    "arccos_",
    "arccosh",
    "arccosh_",
    "arcsin",
    "arcsin_",
    "arcsinh",
    "arcsinh_",
    "arctan",
    "arctan2",
    "arctan_",
    "arctanh",
    "arctanh_",
    "argmax",
    "argmin",
    "argsort",
    "argwhere",
    "as_strided",
    "as_strided_",
    "as_strided_copy",
    "as_strided_scatter",
    "as_tensor",
    "asarray",
    "asin",
    "asin_",
    "asinh",
    "asinh_",
    "atan",
    "atan2",
    "atan_",
    "atanh",
    "atanh_",
    "avg_pool1d",
    "baddbmm",
    "bartlett_window",
    "batch_norm",
    "batch_norm_backward_elemt",
    "batch_norm_backward_reduce",
    "batch_norm_elemt",
    "batch_norm_gather_stats",
    "batch_norm_gather_stats_with_counts",
    "batch_norm_stats",
    "batch_norm_update_stats",
    "bernoulli",
    "bilinear",
    "binary_cross_entropy_with_logits",
    "bincount",
    "binomial",
    "bitwise_and",
    "bitwise_left_shift",
    "bitwise_not",
    "bitwise_or",
    "bitwise_right_shift",
    "bitwise_xor",
    "blackman_window",
    "bmm",
    "broadcast_to",
    "bucketize",
    "can_cast",
    "cat",
    "ccol_indices_copy",
    "ceil",
    "ceil_",
    "celu",
    "celu_",
    "channel_shuffle",
    "cholesky",
    "cholesky_inverse",
    "cholesky_solve",
    "choose_qparams_optimized",
    "chunk",
    "clamp",
    "clamp_",
    "clamp_max",
    "clamp_max_",
    "clamp_min",
    "clamp_min_",
    "clip",
    "clip_",
    "clone",
    "col_indices_copy",
    "column_stack",
    "combinations",
    "complex",
    "concat",
    "concatenate",
    "conj",
    "conj_physical",
    "conj_physical_",
    "constant_pad_nd",
    "conv1d",
    "conv2d",
    "conv3d",
    "conv_tbc",
    "conv_transpose1d",
    "conv_transpose2d",
    "conv_transpose3d",
    "convolution",
    "copysign",
    "corrcoef",
    "cos",
    "cos_",
    "cosh",
    "cosh_",
    "cosine_embedding_loss",
    "cosine_similarity",
    "count_nonzero",
    "cov",
    "cross",
    "crow_indices_copy",
    "ctc_loss",
    "cudnn_affine_grid_generator",
    "cudnn_batch_norm",
    "cudnn_convolution",
    "cudnn_convolution_add_relu",
    "cudnn_convolution_relu",
    "cudnn_convolution_transpose",
    "cudnn_grid_sampler",
    "cudnn_is_acceptable",
    "cummax",
    "cummax",
    "cummin",
    "cummin",
    "cumprod",
    "cumsum",
    "cumulative_trapezoid",
    "deg2rad",
    "deg2rad_",
    "dequantize",
    "det",
    "detach",
    "detach_",
    "detach_copy",
    "diag",
    "diag_embed",
    "diagflat",
    "diagonal",
    "diagonal_copy",
    "diagonal_scatter",
    "diff",
    "digamma",
    "dist",
    "div",
    "divide",
    "dot",
    "dropout",
    "dropout_",
    "dsmm",
    "dsplit",
    "dstack",
    "embedding",
    "embedding_bag",
    "embedding_renorm_",
    "empty",
    "empty_like",
    "empty_permuted",
    "empty_quantized",
    "empty_strided",
    "eq",
    "equal",
    "erf",
    "erf_",
    "erfc",
    "erfc_",
    "erfinv",
    "exp",
    "exp2",
    "exp2_",
    "exp_",
    "expand_copy",
    "expm1",
    "expm1_",
    "eye",
    "fake_quantize_per_channel_affine",
    "fake_quantize_per_tensor_affine",
    "fbgemm_linear_fp16_weight",
    "fbgemm_linear_fp16_weight_fp32_activation",
    "fbgemm_linear_int8_weight",
    "fbgemm_linear_int8_weight_fp32_activation",
    "fbgemm_linear_quantize_weight",
    "fbgemm_pack_gemm_matrix_fp16",
    "fbgemm_pack_quantized_matrix",
    "feature_alpha_dropout",
    "feature_alpha_dropout_",
    "feature_dropout",
    "feature_dropout_",
    "fill",
    "fill_",
    "fix",
    "fix_",
    "flatten",
    "flip",
    "fliplr",
    "flipud",
    "float_power",
    "floor",
    "floor_",
    "floor_divide",
    "fmax",
    "fmin",
    "fmod",
    "frac",
    "frac_",
    "frexp",
    "frexp",
    "frobenius_norm",
    "from_file",
    "from_numpy",
    "frombuffer",
    "full",
    "full_like",
    "fused_moving_avg_obs_fake_quant",
    "gather",
    "gcd",
    "gcd_",
    "ge",
    "geqrf",
    "geqrf",
    "ger",
    "get_default_dtype",
    "get_num_interop_threads",
    "get_num_threads",
    "gradient",
    "greater",
    "greater_equal",
    "grid_sampler",
    "grid_sampler_2d",
    "grid_sampler_3d",
    "group_norm",
    "gru",
    "gru_cell",
    "gt",
    "hamming_window",
    "hann_window",
    "hardshrink",
    "heaviside",
    "hinge_embedding_loss",
    "histc",
    "histogram",
    "histogram",
    "histogramdd",
    "histogramdd",
    "hsmm",
    "hsplit",
    "hspmm",
    "hstack",
    "hypot",
    "i0",
    "i0_",
    "igamma",
    "igammac",
    "imag",
    "index_add",
    "index_copy",
    "index_fill",
    "index_put",
    "index_put_",
    "index_reduce",
    "index_select",
    "indices_copy",
    "init_num_threads",
    "inner",
    "instance_norm",
    "int_repr",
    "inverse",
    "is_complex",
    "is_conj",
    "is_distributed",
    "is_floating_point",
    "is_grad_enabled",
    "is_inference",
    "is_inference_mode_enabled",
    "is_neg",
    "is_nonzero",
    "is_same_size",
    "is_signed",
    "is_vulkan_available",
    "isclose",
    "isfinite",
    "isin",
    "isinf",
    "isnan",
    "isneginf",
    "isposinf",
    "isreal",
    "istft",
    "kaiser_window",
    "kl_div",
    "kron",
    "kthvalue",
    "kthvalue",
    "layer_norm",
    "lcm",
    "lcm_",
    "ldexp",
    "ldexp_",
    "le",
    "lerp",
    "less",
    "less_equal",
    "lgamma",
    "linspace",
    "log",
    "log10",
    "log10_",
    "log1p",
    "log1p_",
    "log2",
    "log2_",
    "log_",
    "log_softmax",
    "logaddexp",
    "logaddexp2",
    "logcumsumexp",
    "logdet",
    "logical_and",
    "logical_not",
    "logical_or",
    "logical_xor",
    "logit",
    "logit_",
    "logspace",
    "logsumexp",
    "lstm",
    "lstm_cell",
    "lt",
    "lu_solve",
    "lu_unpack",
    "lu_unpack",
    "margin_ranking_loss",
    "masked_fill",
    "masked_scatter",
    "masked_select",
    "matmul",
    "matrix_exp",
    "matrix_power",
    "max",
    "max",
    "max_pool1d",
    "max_pool1d_with_indices",
    "max_pool2d",
    "max_pool3d",
    "maximum",
    "mean",
    "median",
    "median",
    "min",
    "min",
    "minimum",
    "miopen_batch_norm",
    "miopen_convolution",
    "miopen_convolution_add_relu",
    "miopen_convolution_relu",
    "miopen_convolution_transpose",
    "miopen_depthwise_convolution",
    "miopen_rnn",
    "mkldnn_adaptive_avg_pool2d",
    "mkldnn_convolution",
    "mkldnn_linear_backward_weights",
    "mkldnn_max_pool2d",
    "mkldnn_max_pool3d",
    "mkldnn_rnn_layer",
    "mm",
    "mode",
    "mode",
    "moveaxis",
    "movedim",
    "msort",
    "mul",
    "multinomial",
    "multiply",
    "mv",
    "mvlgamma",
    "nan_to_num",
    "nan_to_num_",
    "nanmean",
    "nanmedian",
    "nanmedian",
    "nanquantile",
    "nansum",
    "narrow",
    "narrow_copy",
    "native_batch_norm",
    "native_channel_shuffle",
    "native_dropout",
    "native_group_norm",
    "native_layer_norm",
    "native_norm",
    "ne",
    "neg",
    "neg_",
    "negative",
    "negative_",
    "nextafter",
    "nonzero",
    "nonzero_static",
    "norm_except_dim",
    "normal",
    "not_equal",
    "nuclear_norm",
    "numel",
    "ones",
    "ones_like",
    "orgqr",
    "ormqr",
    "outer",
    "pairwise_distance",
    "pdist",
    "permute",
    "permute_copy",
    "pinverse",
    "pixel_shuffle",
    "pixel_unshuffle",
    "poisson",
    "poisson_nll_loss",
    "polar",
    "polygamma",
    "positive",
    "pow",
    "prelu",
    "prod",
    "promote_types",
    "put",
    "q_per_channel_axis",
    "q_per_channel_scales",
    "q_per_channel_zero_points",
    "q_scale",
    "q_zero_point",
    "qr",
    "qr",
    "quantile",
    "quantize_per_channel",
    "quantize_per_tensor",
    "quantize_per_tensor_dynamic",
    "quantized_batch_norm",
    "quantized_gru_cell",
    "quantized_lstm_cell",
    "quantized_max_pool1d",
    "quantized_max_pool2d",
    "quantized_max_pool3d",
    "quantized_rnn_relu_cell",
    "quantized_rnn_tanh_cell",
    "rad2deg",
    "rad2deg_",
    "rand",
    "rand_like",
    "randint",
    "randint_like",
    "randn",
    "randn_like",
    "randperm",
    "range",
    "ravel",
    "real",
    "reciprocal",
    "reciprocal_",
    "relu",
    "relu_",
    "remainder",
    "renorm",
    "repeat_interleave",
    "reshape",
    "resize_as_",
    "resize_as_sparse_",
    "resolve_conj",
    "resolve_neg",
    "result_type",
    "rms_norm",
    "rnn_relu",
    "rnn_relu_cell",
    "rnn_tanh",
    "rnn_tanh_cell",
    "roll",
    "rot90",
    "round",
    "round_",
    "row_indices_copy",
    "row_stack",
    "rrelu",
    "rrelu_",
    "rsqrt",
    "rsqrt_",
    "rsub",
    "saddmm",
    "scalar_tensor",
    "scatter",
    "scatter_add",
    "scatter_reduce",
    "searchsorted",
    "segment_reduce",
    "select",
    "select_copy",
    "select_scatter",
    "selu",
    "selu_",
    "set_flush_denormal",
    "set_num_interop_threads",
    "set_num_threads",
    "sgn",
    "sigmoid",
    "sigmoid_",
    "sign",
    "signbit",
    "sin",
    "sin_",
    "sinc",
    "sinc_",
    "sinh",
    "sinh_",
    "slice_copy",
    "slice_inverse",
    "slice_scatter",
    "slogdet",
    "slogdet",
    "smm",
    "softmax",
    "sort",
    "sort",
    "sparse_bsc_tensor",
    "sparse_bsr_tensor",
    "sparse_compressed_tensor",
    "sparse_coo_tensor",
    "sparse_csc_tensor",
    "sparse_csr_tensor",
    "split_copy",
    "split_with_sizes",
    "split_with_sizes_copy",
    "spmm",
    "sqrt",
    "sqrt_",
    "square",
    "square_",
    "squeeze",
    "squeeze_copy",
    "sspaddmm",
    "stack",
    "std",
    "std_mean",
    "sub",
    "subtract",
    "sum",
    "svd",
    "svd",
    "swapaxes",
    "swapdims",
    "sym_constrain_range",
    "sym_constrain_range_for_size",
    "t",
    "t_copy",
    "take",
    "take_along_dim",
    "tan",
    "tan_",
    "tanh",
    "tanh_",
    "tensor",
    "tensor_split",
    "threshold",
    "threshold_",
    "tile",
    "topk",
    "topk",
    "trace",
    "transpose",
    "transpose_copy",
    "trapezoid",
    "trapz",
    "triangular_solve",
    "triangular_solve",
    "tril",
    "tril_indices",
    "triplet_margin_loss",
    "triu",
    "triu_indices",
    "true_divide",
    "trunc",
    "trunc_",
    "unbind",
    "unbind_copy",
    "unflatten",
    "unfold_copy",
    "unique_dim",
    "unsafe_chunk",
    "unsafe_split",
    "unsafe_split_with_sizes",
    "unsqueeze",
    "unsqueeze_copy",
    "values_copy",
    "vander",
    "var",
    "var_mean",
    "vdot",
    "view_as_complex",
    "view_as_complex_copy",
    "view_as_real",
    "view_as_real_copy",
    "view_copy",
    "vsplit",
    "vstack",
    "where",
    "xlogy",
    "xlogy_",
    "zero_",
    "zeros",
    "zeros_like",
]

@overload
def __and__(input: Tensor, other: Tensor) -> Tensor: ...
@overload
def __and__(input: Tensor, other: Number | _complex) -> Tensor: ...
@overload
def __lshift__(input: Tensor, other: Tensor) -> Tensor: ...
@overload
def __lshift__(input: Tensor, other: Number | _complex) -> Tensor: ...
@overload
def __or__(input: Tensor, other: Tensor) -> Tensor: ...
@overload
def __or__(input: Tensor, other: Number | _complex) -> Tensor: ...
@overload
def __rshift__(input: Tensor, other: Tensor) -> Tensor: ...
@overload
def __rshift__(input: Tensor, other: Number | _complex) -> Tensor: ...
@overload
def __xor__(input: Tensor, other: Tensor) -> Tensor: ...
@overload
def __xor__(input: Tensor, other: Number | _complex) -> Tensor: ...
def _adaptive_avg_pool2d(
    input: Tensor,
    output_size: _int | SymInt | Sequence[_int | SymInt],
) -> Tensor: ...
def _adaptive_avg_pool3d(
    input: Tensor,
    output_size: _int | SymInt | Sequence[_int | SymInt],
) -> Tensor: ...
def _add_batch_dim(input: Tensor, batch_dim: _int, level: _int) -> Tensor: ...
@overload
def _add_relu(
    input: Tensor,
    other: Tensor,
    *,
    alpha: Number | _complex = 1,
    out: Tensor | None = None,
) -> Tensor: ...
@overload
def _add_relu(
    input: Tensor,
    other: Number | _complex,
    alpha: Number | _complex = 1,
) -> Tensor: ...
@overload
def _add_relu_(
    input: Tensor,
    other: Tensor,
    *,
    alpha: Number | _complex = 1,
) -> Tensor: ...
@overload
def _add_relu_(
    input: Tensor,
    other: Number | _complex,
    alpha: Number | _complex = 1,
) -> Tensor: ...
def _addmm_activation(
    input: Tensor,
    mat1: Tensor,
    mat2: Tensor,
    *,
    beta: Number | _complex = 1,
    alpha: Number | _complex = 1,
    use_gelu: _bool = False,
    out: Tensor | None = None,
) -> Tensor: ...
@overload
def _aminmax(input: Tensor) -> tuple[Tensor, Tensor]: ...
@overload
def _aminmax(
    input: Tensor,
    dim: _int,
    keepdim: _bool = False,
) -> tuple[Tensor, Tensor]: ...
def _amp_foreach_non_finite_check_and_unscale_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    found_inf: Tensor,
    inv_scale: Tensor,
) -> None: ...
def _amp_update_scale_(
    input: Tensor,
    growth_tracker: Tensor,
    found_inf: Tensor,
    scale_growth_factor: _float,
    scale_backoff_factor: _float,
    growth_interval: _int,
) -> Tensor: ...
@overload
def _assert_async(input: Tensor) -> None:
    r"""
    _assert_async(tensor) -> void

    Asynchronously assert that the contents of tensor are nonzero.  For CPU tensors,
    this is equivalent to ``assert tensor`` or ``assert tensor.is_nonzero()``; for
    CUDA tensors, we DO NOT synchronize and you may only find out the assertion
    failed at a later CUDA kernel launch.  Asynchronous assertion can be helpful for
    testing invariants in CUDA tensors without giving up performance.  This function
    is NOT intended to be used for regular error checking, as it will trash your CUDA
    context if the assert fails (forcing you to restart your PyTorch process.)

    Args:
        tensor (Tensor): a one element tensor to test to see if it is nonzero.  Zero
            elements (including False for boolean tensors) cause an assertion failure
            to be raised.
    """

@overload
def _assert_async(input: Tensor, assert_msg: str) -> None:
    r"""
    _assert_async(tensor) -> void

    Asynchronously assert that the contents of tensor are nonzero.  For CPU tensors,
    this is equivalent to ``assert tensor`` or ``assert tensor.is_nonzero()``; for
    CUDA tensors, we DO NOT synchronize and you may only find out the assertion
    failed at a later CUDA kernel launch.  Asynchronous assertion can be helpful for
    testing invariants in CUDA tensors without giving up performance.  This function
    is NOT intended to be used for regular error checking, as it will trash your CUDA
    context if the assert fails (forcing you to restart your PyTorch process.)

    Args:
        tensor (Tensor): a one element tensor to test to see if it is nonzero.  Zero
            elements (including False for boolean tensors) cause an assertion failure
            to be raised.
    """

def _assert_scalar(self: Number | _complex, assert_msg: str) -> None: ...
def _assert_tensor_metadata(
    a: Tensor,
    size: Sequence[_int | SymInt] | None = None,
    stride: Sequence[_int | SymInt] | None = None,
    dtype: _dtype | None = None,
    *,
    device: DeviceLikeType | None = None,
    layout: _layout | None = None,
) -> None: ...
def _batch_norm_impl_index(
    input: Tensor,
    weight: Tensor | None,
    bias: Tensor | None,
    running_mean: Tensor | None,
    running_var: Tensor | None,
    training: _bool,
    momentum: _float,
    eps: _float,
    cudnn_enabled: _bool,
) -> tuple[Tensor, Tensor, Tensor, Tensor, _int]: ...
def _cast_Byte(input: Tensor, non_blocking: _bool = False) -> Tensor: ...
def _cast_Char(input: Tensor, non_blocking: _bool = False) -> Tensor: ...
def _cast_Double(input: Tensor, non_blocking: _bool = False) -> Tensor: ...
def _cast_Float(input: Tensor, non_blocking: _bool = False) -> Tensor: ...
def _cast_Half(input: Tensor, non_blocking: _bool = False) -> Tensor: ...
def _cast_Int(input: Tensor, non_blocking: _bool = False) -> Tensor: ...
def _cast_Long(input: Tensor, non_blocking: _bool = False) -> Tensor: ...
def _cast_Short(input: Tensor, non_blocking: _bool = False) -> Tensor: ...
def _choose_qparams_per_tensor(
    input: Tensor,
    reduce_range: _bool = False,
) -> tuple[_float, _int]: ...
def _chunk_cat(
    tensors: tuple[Tensor, ...] | list[Tensor] | None,
    dim: _int,
    num_chunks: _int,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _coalesce(input: Tensor) -> Tensor: ...
def _compute_linear_combination(
    input: Tensor,
    coefficients: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _conj(input: Tensor) -> Tensor: ...
def _conj_copy(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def _conj_physical(input: Tensor) -> Tensor: ...
def _convert_indices_from_coo_to_csr(
    input: Tensor,
    size: _int,
    *,
    out_int32: _bool = False,
    out: Tensor | None = None,
) -> Tensor: ...
def _convert_indices_from_csr_to_coo(
    crow_indices: Tensor,
    col_indices: Tensor,
    *,
    out_int32: _bool = False,
    transpose: _bool = False,
    out: Tensor | None = None,
) -> Tensor: ...
def _convert_weight_to_int4pack(input: Tensor, innerKTiles: _int) -> Tensor: ...
def _convert_weight_to_int4pack_for_cpu(
    input: Tensor,
    innerKTiles: _int,
) -> Tensor: ...
@overload
def _convolution(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None,
    stride: Sequence[_int | SymInt],
    padding: Sequence[_int | SymInt],
    dilation: Sequence[_int | SymInt],
    transposed: _bool,
    output_padding: _size,
    groups: _int | SymInt,
    benchmark: _bool,
    deterministic: _bool,
    cudnn_enabled: _bool,
) -> Tensor: ...
@overload
def _convolution(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None,
    stride: Sequence[_int | SymInt],
    padding: Sequence[_int | SymInt],
    dilation: Sequence[_int | SymInt],
    transposed: _bool,
    output_padding: Sequence[_int | SymInt],
    groups: _int | SymInt,
    benchmark: _bool,
    deterministic: _bool,
    cudnn_enabled: _bool,
    allow_tf32: _bool,
) -> Tensor: ...
def _convolution_mode(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None,
    stride: Sequence[_int | SymInt],
    padding: str,
    dilation: Sequence[_int | SymInt],
    groups: _int | SymInt,
) -> Tensor: ...
def _copy_from(
    input: Tensor,
    dst: Tensor,
    non_blocking: _bool = False,
) -> Tensor: ...
def _copy_from_and_resize(input: Tensor, dst: Tensor) -> Tensor: ...
def _cslt_compress(input: Tensor) -> Tensor: ...
def _cslt_sparse_mm(
    compressed_A: Tensor,
    dense_B: Tensor,
    bias: Tensor | None = None,
    alpha: Tensor | None = None,
    out_dtype: _dtype | None = None,
    transpose_result: _bool = False,
    alg_id: _int = 0,
    split_k: _int = 1,
    split_k_mode: _int = -1,
) -> Tensor: ...
def _cslt_sparse_mm_search(
    compressed_A: Tensor,
    dense_B: Tensor,
    bias: Tensor | None = None,
    alpha: Tensor | None = None,
    out_dtype: _dtype | None = None,
    transpose_result: _bool = False,
) -> _int: ...
@overload
def _ctc_loss(
    log_probs: Tensor,
    targets: Tensor,
    input_lengths: _size,
    target_lengths: _size,
    blank: _int = 0,
    zero_infinity: _bool = False,
) -> tuple[Tensor, Tensor]: ...
@overload
def _ctc_loss(
    log_probs: Tensor,
    targets: Tensor,
    input_lengths: Tensor,
    target_lengths: Tensor,
    blank: _int = 0,
    zero_infinity: _bool = False,
) -> tuple[Tensor, Tensor]: ...
@overload
def _cudnn_ctc_loss(
    log_probs: Tensor,
    targets: Tensor,
    input_lengths: _size,
    target_lengths: _size,
    blank: _int,
    deterministic: _bool,
    zero_infinity: _bool,
) -> tuple[Tensor, Tensor]: ...
@overload
def _cudnn_ctc_loss(
    log_probs: Tensor,
    targets: Tensor,
    input_lengths: Tensor,
    target_lengths: Tensor,
    blank: _int,
    deterministic: _bool,
    zero_infinity: _bool,
) -> tuple[Tensor, Tensor]: ...
def _cudnn_init_dropout_state(
    dropout: _float,
    train: _bool,
    dropout_seed: _int,
    *,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor: ...
def _cudnn_rnn(
    input: Tensor,
    weight: tuple[Tensor, ...] | list[Tensor] | None,
    weight_stride0: _int,
    weight_buf: Tensor | None,
    hx: Tensor,
    cx: Tensor | None,
    mode: _int,
    hidden_size: _int | SymInt,
    proj_size: _int | SymInt,
    num_layers: _int,
    batch_first: _bool,
    dropout: _float,
    train: _bool,
    bidirectional: _bool,
    batch_sizes: Sequence[_int | SymInt],
    dropout_state: Tensor | None,
) -> tuple[Tensor, Tensor, Tensor, Tensor, Tensor]: ...
def _cudnn_rnn_flatten_weight(
    weight_arr: tuple[Tensor, ...] | list[Tensor] | None,
    weight_stride0: _int,
    input_size: _int | SymInt,
    mode: _int,
    hidden_size: _int | SymInt,
    proj_size: _int | SymInt,
    num_layers: _int,
    batch_first: _bool,
    bidirectional: _bool,
) -> Tensor: ...
def _cufft_clear_plan_cache(device_index: _int) -> None: ...
def _cufft_get_plan_cache_max_size(device_index: _int) -> _int: ...
def _cufft_get_plan_cache_size(device_index: _int) -> _int: ...
def _cufft_set_plan_cache_max_size(
    device_index: _int,
    max_size: _int,
) -> None: ...
def _cummax_helper(
    input: Tensor,
    values: Tensor,
    indices: Tensor,
    dim: _int,
) -> None: ...
def _cummin_helper(
    input: Tensor,
    values: Tensor,
    indices: Tensor,
    dim: _int,
) -> None: ...
def _debug_has_internal_overlap(input: Tensor) -> _int: ...
def _dim_arange(like: Tensor, dim: _int) -> Tensor: ...
def _dirichlet_grad(x: Tensor, alpha: Tensor, total: Tensor) -> Tensor: ...
def _disable_functionalization(): ...
def _dyn_quant_matmul_4bit(
    inp: Tensor,
    packed_weights: Tensor,
    block_size: _int,
    in_features: _int,
    out_features: _int,
) -> Tensor: ...
def _dyn_quant_pack_4bit_weight(
    weights: Tensor,
    scales_zeros: Tensor,
    bias: Tensor | None,
    block_size: _int,
    in_features: _int,
    out_features: _int,
) -> Tensor: ...
@overload
def _efficientzerotensor(
    size: Sequence[_int | SymInt],
    *,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor: ...
@overload
def _efficientzerotensor(
    *size: _int | SymInt,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor: ...
def _embedding_bag(
    weight: Tensor,
    indices: Tensor,
    offsets: Tensor,
    scale_grad_by_freq: _bool = False,
    mode: _int = 0,
    sparse: _bool = False,
    per_sample_weights: Tensor | None = None,
    include_last_offset: _bool = False,
    padding_idx: _int = -1,
) -> tuple[Tensor, Tensor, Tensor, Tensor]: ...
def _embedding_bag_forward_only(
    weight: Tensor,
    indices: Tensor,
    offsets: Tensor,
    scale_grad_by_freq: _bool = False,
    mode: _int = 0,
    sparse: _bool = False,
    per_sample_weights: Tensor | None = None,
    include_last_offset: _bool = False,
    padding_idx: _int = -1,
) -> tuple[Tensor, Tensor, Tensor, Tensor]: ...
@overload
def _empty_affine_quantized(
    size: Sequence[_int | SymInt],
    *,
    scale: _float = 1,
    zero_point: _int = 0,
    memory_format: memory_format | None = contiguous_format,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor: ...
@overload
def _empty_affine_quantized(
    *size: _int | SymInt,
    scale: _float = 1,
    zero_point: _int = 0,
    memory_format: memory_format | None = contiguous_format,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor: ...
@overload
def _empty_per_channel_affine_quantized(
    size: Sequence[_int | SymInt],
    *,
    scales: Tensor,
    zero_points: Tensor,
    axis: _int,
    memory_format: memory_format | None = contiguous_format,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor: ...
@overload
def _empty_per_channel_affine_quantized(
    *size: _int | SymInt,
    scales: Tensor,
    zero_points: Tensor,
    axis: _int,
    memory_format: memory_format | None = contiguous_format,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor: ...
def _enable_functionalization(*, reapply_views: _bool = False) -> None: ...
def _euclidean_dist(x1: Tensor, x2: Tensor) -> Tensor: ...
def _fake_quantize_learnable_per_channel_affine(
    input: Tensor,
    scale: Tensor,
    zero_point: Tensor,
    axis: _int,
    quant_min: _int,
    quant_max: _int,
    grad_factor: _float = 1.0,
) -> Tensor: ...
def _fake_quantize_learnable_per_tensor_affine(
    input: Tensor,
    scale: Tensor,
    zero_point: Tensor,
    quant_min: _int,
    quant_max: _int,
    grad_factor: _float = 1.0,
) -> Tensor: ...
def _fake_quantize_per_tensor_affine_cachemask_tensor_qparams(
    input: Tensor,
    scale: Tensor,
    zero_point: Tensor,
    fake_quant_enabled: Tensor,
    quant_min: _int,
    quant_max: _int,
) -> torch.return_types._fake_quantize_per_tensor_affine_cachemask_tensor_qparams:  # fmt: skip
    ...
def _fft_c2c(
    input: Tensor,
    dim: Sequence[_int | SymInt],
    normalization: _int,
    forward: _bool,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _fft_c2r(
    input: Tensor,
    dim: _size,
    normalization: _int,
    last_dim_size: _int | SymInt,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _fft_r2c(
    input: Tensor,
    dim: _size,
    normalization: _int,
    onesided: _bool,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _fill_mem_eff_dropout_mask_(
    input: Tensor,
    dropout_p: _float,
    seed: _int,
    offset: _int,
) -> Tensor: ...
def _foobar(
    input: Tensor,
    arg1: _bool = True,
    arg2: _bool = True,
    *,
    arg3: _bool = True,
) -> Tensor: ...
def _foreach_abs(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_abs(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.abs` to each Tensor of the input list.
    """

def _foreach_abs_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_abs_(self: List[Tensor]) -> None

    Apply :func:`torch.abs` to each Tensor of the input list.
    """

def _foreach_acos(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_acos(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.acos` to each Tensor of the input list.
    """

def _foreach_acos_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_acos_(self: List[Tensor]) -> None

    Apply :func:`torch.acos` to each Tensor of the input list.
    """

@overload
def _foreach_add(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_add(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    alpha: Number | _complex = 1,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_add(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: Tensor,
    *,
    alpha: Number | _complex = 1,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_add(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_add_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> None: ...
@overload
def _foreach_add_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    alpha: Number | _complex = 1,
) -> None: ...
@overload
def _foreach_add_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: Tensor,
    *,
    alpha: Number | _complex = 1,
) -> None: ...
@overload
def _foreach_add_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> None: ...
@overload
def _foreach_addcdiv(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensor1: tuple[Tensor, ...] | list[Tensor] | None,
    tensor2: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_addcdiv(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensor1: tuple[Tensor, ...] | list[Tensor] | None,
    tensor2: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Tensor,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_addcdiv(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensor1: tuple[Tensor, ...] | list[Tensor] | None,
    tensor2: tuple[Tensor, ...] | list[Tensor] | None,
    value: Number | _complex = 1,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_addcdiv_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensor1: tuple[Tensor, ...] | list[Tensor] | None,
    tensor2: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> None: ...
@overload
def _foreach_addcdiv_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensor1: tuple[Tensor, ...] | list[Tensor] | None,
    tensor2: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Tensor,
) -> None: ...
@overload
def _foreach_addcdiv_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensor1: tuple[Tensor, ...] | list[Tensor] | None,
    tensor2: tuple[Tensor, ...] | list[Tensor] | None,
    value: Number | _complex = 1,
) -> None: ...
@overload
def _foreach_addcmul(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensor1: tuple[Tensor, ...] | list[Tensor] | None,
    tensor2: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_addcmul(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensor1: tuple[Tensor, ...] | list[Tensor] | None,
    tensor2: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Tensor,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_addcmul(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensor1: tuple[Tensor, ...] | list[Tensor] | None,
    tensor2: tuple[Tensor, ...] | list[Tensor] | None,
    value: Number | _complex = 1,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_addcmul_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensor1: tuple[Tensor, ...] | list[Tensor] | None,
    tensor2: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> None: ...
@overload
def _foreach_addcmul_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensor1: tuple[Tensor, ...] | list[Tensor] | None,
    tensor2: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Tensor,
) -> None: ...
@overload
def _foreach_addcmul_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensor1: tuple[Tensor, ...] | list[Tensor] | None,
    tensor2: tuple[Tensor, ...] | list[Tensor] | None,
    value: Number | _complex = 1,
) -> None: ...
def _foreach_asin(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_asin(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.asin` to each Tensor of the input list.
    """

def _foreach_asin_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_asin_(self: List[Tensor]) -> None

    Apply :func:`torch.asin` to each Tensor of the input list.
    """

def _foreach_atan(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_atan(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.atan` to each Tensor of the input list.
    """

def _foreach_atan_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_atan_(self: List[Tensor]) -> None

    Apply :func:`torch.atan` to each Tensor of the input list.
    """

def _foreach_ceil(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_ceil(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.ceil` to each Tensor of the input list.
    """

def _foreach_ceil_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_ceil_(self: List[Tensor]) -> None

    Apply :func:`torch.ceil` to each Tensor of the input list.
    """

@overload
def _foreach_clamp_max(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_clamp_max(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_clamp_max(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_clamp_max_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> None: ...
@overload
def _foreach_clamp_max_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> None: ...
@overload
def _foreach_clamp_max_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
) -> None: ...
@overload
def _foreach_clamp_min(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_clamp_min(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_clamp_min(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_clamp_min_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> None: ...
@overload
def _foreach_clamp_min_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> None: ...
@overload
def _foreach_clamp_min_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
) -> None: ...
def _foreach_copy_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    src: tuple[Tensor, ...] | list[Tensor] | None,
    non_blocking: _bool = False,
) -> None: ...
def _foreach_cos(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_cos(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.cos` to each Tensor of the input list.
    """

def _foreach_cos_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_cos_(self: List[Tensor]) -> None

    Apply :func:`torch.cos` to each Tensor of the input list.
    """

def _foreach_cosh(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_cosh(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.cosh` to each Tensor of the input list.
    """

def _foreach_cosh_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_cosh_(self: List[Tensor]) -> None

    Apply :func:`torch.cosh` to each Tensor of the input list.
    """

@overload
def _foreach_div(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_div(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: Tensor,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_div(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_div(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_div_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> None: ...
@overload
def _foreach_div_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: Tensor,
) -> None: ...
@overload
def _foreach_div_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> None: ...
@overload
def _foreach_div_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
) -> None: ...
def _foreach_erf(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_erf(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.erf` to each Tensor of the input list.
    """

def _foreach_erf_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_erf_(self: List[Tensor]) -> None

    Apply :func:`torch.erf` to each Tensor of the input list.
    """

def _foreach_erfc(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_erfc(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.erfc` to each Tensor of the input list.
    """

def _foreach_erfc_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_erfc_(self: List[Tensor]) -> None

    Apply :func:`torch.erfc` to each Tensor of the input list.
    """

def _foreach_exp(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_exp(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.exp` to each Tensor of the input list.
    """

def _foreach_exp_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_exp_(self: List[Tensor]) -> None

    Apply :func:`torch.exp` to each Tensor of the input list.
    """

def _foreach_expm1(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_expm1(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.expm1` to each Tensor of the input list.
    """

def _foreach_expm1_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_expm1_(self: List[Tensor]) -> None

    Apply :func:`torch.expm1` to each Tensor of the input list.
    """

def _foreach_floor(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_floor(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.floor` to each Tensor of the input list.
    """

def _foreach_floor_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_floor_(self: List[Tensor]) -> None

    Apply :func:`torch.floor` to each Tensor of the input list.
    """

def _foreach_frac(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_frac(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.frac` to each Tensor of the input list.
    """

def _foreach_frac_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_frac_(self: List[Tensor]) -> None

    Apply :func:`torch.frac` to each Tensor of the input list.
    """

@overload
def _foreach_lerp(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensors1: tuple[Tensor, ...] | list[Tensor] | None,
    weight: Number | _complex,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_lerp(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensors1: tuple[Tensor, ...] | list[Tensor] | None,
    weight: Sequence[Number | _complex],
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_lerp(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensors1: tuple[Tensor, ...] | list[Tensor] | None,
    weights: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_lerp_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensors1: tuple[Tensor, ...] | list[Tensor] | None,
    weight: Number | _complex,
) -> None: ...
@overload
def _foreach_lerp_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensors1: tuple[Tensor, ...] | list[Tensor] | None,
    weight: Sequence[Number | _complex],
) -> None: ...
@overload
def _foreach_lerp_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    tensors1: tuple[Tensor, ...] | list[Tensor] | None,
    weights: tuple[Tensor, ...] | list[Tensor] | None,
) -> None: ...
def _foreach_lgamma(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_lgamma(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.lgamma` to each Tensor of the input list.
    """

def _foreach_lgamma_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> None:
    r"""
    _foreach_lgamma_(self: List[Tensor]) -> None

    Apply :func:`torch.lgamma` to each Tensor of the input list.
    """

def _foreach_log(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_log(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.log` to each Tensor of the input list.
    """

def _foreach_log10(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_log10(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.log10` to each Tensor of the input list.
    """

def _foreach_log10_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_log10_(self: List[Tensor]) -> None

    Apply :func:`torch.log10` to each Tensor of the input list.
    """

def _foreach_log1p(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_log1p(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.log1p` to each Tensor of the input list.
    """

def _foreach_log1p_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_log1p_(self: List[Tensor]) -> None

    Apply :func:`torch.log1p` to each Tensor of the input list.
    """

def _foreach_log2(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_log2(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.log2` to each Tensor of the input list.
    """

def _foreach_log2_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_log2_(self: List[Tensor]) -> None

    Apply :func:`torch.log2` to each Tensor of the input list.
    """

def _foreach_log_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_log_(self: List[Tensor]) -> None

    Apply :func:`torch.log` to each Tensor of the input list.
    """

def _foreach_max(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_maximum(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_maximum(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_maximum(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_maximum_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> None: ...
@overload
def _foreach_maximum_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> None: ...
@overload
def _foreach_maximum_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
) -> None: ...
@overload
def _foreach_minimum(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_minimum(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_minimum(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_minimum_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> None: ...
@overload
def _foreach_minimum_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> None: ...
@overload
def _foreach_minimum_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
) -> None: ...
@overload
def _foreach_mul(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_mul(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: Tensor,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_mul(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_mul(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_mul_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> None: ...
@overload
def _foreach_mul_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: Tensor,
) -> None: ...
@overload
def _foreach_mul_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> None: ...
@overload
def _foreach_mul_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
) -> None: ...
def _foreach_neg(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_neg(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.neg` to each Tensor of the input list.
    """

def _foreach_neg_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_neg_(self: List[Tensor]) -> None

    Apply :func:`torch.neg` to each Tensor of the input list.
    """

def _foreach_norm(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    ord: Number | _complex = 2,
    dtype: _dtype | None = None,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_pow(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    exponent: Sequence[Number | _complex],
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_pow(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    exponent: Number | _complex,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_pow(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    exponent: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_pow(
    self: Number | _complex,
    exponent: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_pow_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    exponent: Sequence[Number | _complex],
) -> None: ...
@overload
def _foreach_pow_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    exponent: Number | _complex,
) -> None: ...
@overload
def _foreach_pow_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    exponent: tuple[Tensor, ...] | list[Tensor] | None,
) -> None: ...
def _foreach_reciprocal(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_reciprocal(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.reciprocal` to each Tensor of the input list.
    """

def _foreach_reciprocal_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> None:
    r"""
    _foreach_reciprocal_(self: List[Tensor]) -> None

    Apply :func:`torch.reciprocal` to each Tensor of the input list.
    """

def _foreach_round(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_round(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.round` to each Tensor of the input list.
    """

def _foreach_round_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_round_(self: List[Tensor]) -> None

    Apply :func:`torch.round` to each Tensor of the input list.
    """

def _foreach_rsqrt(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
def _foreach_rsqrt_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None: ...
def _foreach_sigmoid(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_sigmoid(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.sigmoid` to each Tensor of the input list.
    """

def _foreach_sigmoid_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> None:
    r"""
    _foreach_sigmoid_(self: List[Tensor]) -> None

    Apply :func:`torch.sigmoid` to each Tensor of the input list.
    """

def _foreach_sign(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
def _foreach_sign_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None: ...
def _foreach_sin(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_sin(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.sin` to each Tensor of the input list.
    """

def _foreach_sin_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_sin_(self: List[Tensor]) -> None

    Apply :func:`torch.sin` to each Tensor of the input list.
    """

def _foreach_sinh(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_sinh(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.sinh` to each Tensor of the input list.
    """

def _foreach_sinh_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_sinh_(self: List[Tensor]) -> None

    Apply :func:`torch.sinh` to each Tensor of the input list.
    """

def _foreach_sqrt(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_sqrt(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.sqrt` to each Tensor of the input list.
    """

def _foreach_sqrt_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_sqrt_(self: List[Tensor]) -> None

    Apply :func:`torch.sqrt` to each Tensor of the input list.
    """

@overload
def _foreach_sub(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_sub(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    alpha: Number | _complex = 1,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_sub(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> tuple[Tensor, ...]: ...
@overload
def _foreach_sub_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalars: Sequence[Number | _complex],
) -> None: ...
@overload
def _foreach_sub_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    other: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    alpha: Number | _complex = 1,
) -> None: ...
@overload
def _foreach_sub_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    scalar: Number | _complex,
) -> None: ...
def _foreach_tan(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_tan(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.tan` to each Tensor of the input list.
    """

def _foreach_tan_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_tan_(self: List[Tensor]) -> None

    Apply :func:`torch.tan` to each Tensor of the input list.
    """

def _foreach_tanh(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_tanh(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.tanh` to each Tensor of the input list.
    """

def _foreach_tanh_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_tanh_(self: List[Tensor]) -> None

    Apply :func:`torch.tanh` to each Tensor of the input list.
    """

def _foreach_trunc(
    self: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    _foreach_trunc(self: List[Tensor]) -> List[Tensor]

    Apply :func:`torch.trunc` to each Tensor of the input list.
    """

def _foreach_trunc_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_trunc_(self: List[Tensor]) -> None

    Apply :func:`torch.trunc` to each Tensor of the input list.
    """

def _foreach_zero_(self: tuple[Tensor, ...] | list[Tensor] | None) -> None:
    r"""
    _foreach_zero_(self: List[Tensor]) -> None

    Apply :func:`torch.zero` to each Tensor of the input list.
    """

def _from_functional_tensor(t: Tensor) -> Tensor: ...
def _functional_assert_async(
    input: Tensor,
    assert_msg: str,
    dep_token: Tensor,
) -> Tensor: ...
def _functional_assert_scalar(
    self: Number | _complex,
    assert_msg: str,
    dep_token: Tensor,
) -> Tensor: ...
def _functional_sym_constrain_range(
    size: Number | _complex,
    min: _int | None,
    max: _int | None,
    dep_token: Tensor,
) -> Tensor: ...
def _functional_sym_constrain_range_for_size(
    size: Number | _complex,
    min: _int | None,
    max: _int | None,
    dep_token: Tensor,
) -> Tensor: ...
def _functionalize_apply_view_metas(tensor: Tensor, base: Tensor) -> Tensor: ...
def _functionalize_are_all_mutations_hidden_from_autograd(
    t: Tensor,
) -> _bool: ...
def _functionalize_are_all_mutations_under_no_grad_or_inference_mode(
    t: Tensor,
) -> _bool: ...
def _functionalize_commit_update(t: Tensor) -> None: ...
def _functionalize_has_metadata_mutation(tensor: Tensor) -> _bool: ...
def _functionalize_is_symbolic(tensor: Tensor) -> _bool: ...
def _functionalize_mark_mutation_hidden_from_autograd(t: Tensor) -> None: ...
def _functionalize_replace(self_: Tensor, other: Tensor) -> None: ...
def _functionalize_set_storage_changed(tensor: Tensor) -> _bool: ...
def _functionalize_sync(t: Tensor) -> None: ...
def _functionalize_unsafe_set(dst: Tensor, src: Tensor) -> None: ...
def _functionalize_was_inductor_storage_resized(t: Tensor) -> _bool: ...
def _functionalize_was_storage_changed(tensor: Tensor) -> _bool: ...
@overload
def _fused_adagrad_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    grads: tuple[Tensor, ...] | list[Tensor] | None,
    state_sums: tuple[Tensor, ...] | list[Tensor] | None,
    state_steps: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    lr: Tensor,
    lr_decay: _float,
    weight_decay: _float,
    eps: _float,
    maximize: _bool,
    grad_scale: Tensor | None = None,
    found_inf: Tensor | None = None,
) -> None: ...
@overload
def _fused_adagrad_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    grads: tuple[Tensor, ...] | list[Tensor] | None,
    state_sums: tuple[Tensor, ...] | list[Tensor] | None,
    state_steps: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    lr: _float,
    lr_decay: _float,
    weight_decay: _float,
    eps: _float,
    maximize: _bool,
    grad_scale: Tensor | None = None,
    found_inf: Tensor | None = None,
) -> None: ...
@overload
def _fused_adam_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    grads: tuple[Tensor, ...] | list[Tensor] | None,
    exp_avgs: tuple[Tensor, ...] | list[Tensor] | None,
    exp_avg_sqs: tuple[Tensor, ...] | list[Tensor] | None,
    max_exp_avg_sqs: tuple[Tensor, ...] | list[Tensor] | None,
    state_steps: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    lr: Tensor,
    beta1: _float,
    beta2: _float,
    weight_decay: _float,
    eps: _float,
    amsgrad: _bool,
    maximize: _bool,
    grad_scale: Tensor | None = None,
    found_inf: Tensor | None = None,
) -> None: ...
@overload
def _fused_adam_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    grads: tuple[Tensor, ...] | list[Tensor] | None,
    exp_avgs: tuple[Tensor, ...] | list[Tensor] | None,
    exp_avg_sqs: tuple[Tensor, ...] | list[Tensor] | None,
    max_exp_avg_sqs: tuple[Tensor, ...] | list[Tensor] | None,
    state_steps: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    lr: _float,
    beta1: _float,
    beta2: _float,
    weight_decay: _float,
    eps: _float,
    amsgrad: _bool,
    maximize: _bool,
    grad_scale: Tensor | None = None,
    found_inf: Tensor | None = None,
) -> None: ...
@overload
def _fused_adamw_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    grads: tuple[Tensor, ...] | list[Tensor] | None,
    exp_avgs: tuple[Tensor, ...] | list[Tensor] | None,
    exp_avg_sqs: tuple[Tensor, ...] | list[Tensor] | None,
    max_exp_avg_sqs: tuple[Tensor, ...] | list[Tensor] | None,
    state_steps: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    lr: Tensor,
    beta1: _float,
    beta2: _float,
    weight_decay: _float,
    eps: _float,
    amsgrad: _bool,
    maximize: _bool,
    grad_scale: Tensor | None = None,
    found_inf: Tensor | None = None,
) -> None: ...
@overload
def _fused_adamw_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    grads: tuple[Tensor, ...] | list[Tensor] | None,
    exp_avgs: tuple[Tensor, ...] | list[Tensor] | None,
    exp_avg_sqs: tuple[Tensor, ...] | list[Tensor] | None,
    max_exp_avg_sqs: tuple[Tensor, ...] | list[Tensor] | None,
    state_steps: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    lr: _float,
    beta1: _float,
    beta2: _float,
    weight_decay: _float,
    eps: _float,
    amsgrad: _bool,
    maximize: _bool,
    grad_scale: Tensor | None = None,
    found_inf: Tensor | None = None,
) -> None: ...
def _fused_dropout(
    input: Tensor,
    p: _float,
    generator: Generator | None = None,
) -> tuple[Tensor, Tensor]: ...
def _fused_moving_avg_obs_fq_helper(
    input: Tensor,
    observer_on: Tensor,
    fake_quant_on: Tensor,
    running_min: Tensor,
    running_max: Tensor,
    scale: Tensor,
    zero_point: Tensor,
    averaging_const: _float,
    quant_min: _int,
    quant_max: _int,
    ch_axis: _int,
    per_row_fake_quant: _bool = False,
    symmetric_quant: _bool = False,
) -> torch.return_types._fused_moving_avg_obs_fq_helper: ...
def _fused_rms_norm(
    input: Tensor,
    normalized_shape_ndim: _int,
    weight: Tensor,
    eps: _float,
) -> Tensor: ...
def _fused_sdp_choice(
    query: Tensor,
    key: Tensor,
    value: Tensor,
    attn_mask: Tensor | None = None,
    dropout_p: _float = 0.0,
    is_causal: _bool = False,
    *,
    scale: _float | None = None,
    enable_gqa: _bool = False,
) -> _int: ...
@overload
def _fused_sgd_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    grads: tuple[Tensor, ...] | list[Tensor] | None,
    momentum_buffer_list: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    weight_decay: _float,
    momentum: _float,
    lr: Tensor,
    dampening: _float,
    nesterov: _bool,
    maximize: _bool,
    is_first_step: _bool,
    grad_scale: Tensor | None = None,
    found_inf: Tensor | None = None,
) -> None: ...
@overload
def _fused_sgd_(
    self: tuple[Tensor, ...] | list[Tensor] | None,
    grads: tuple[Tensor, ...] | list[Tensor] | None,
    momentum_buffer_list: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    weight_decay: _float,
    momentum: _float,
    lr: _float,
    dampening: _float,
    nesterov: _bool,
    maximize: _bool,
    is_first_step: _bool,
    grad_scale: Tensor | None = None,
    found_inf: Tensor | None = None,
) -> None: ...
def _fw_primal_copy(
    input: Tensor,
    level: _int,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _grid_sampler_2d_cpu_fallback(
    input: Tensor,
    grid: Tensor,
    interpolation_mode: _int,
    padding_mode: _int,
    align_corners: _bool,
) -> Tensor: ...
def _grouped_mm(
    input: Tensor,
    mat2: Tensor,
    offs: Tensor | None = None,
    bias: Tensor | None = None,
    out_dtype: _dtype | None = None,
) -> Tensor: ...
def _has_compatible_shallow_copy_type(
    input: Tensor,
    from_: Tensor,
) -> _bool: ...
def _histogramdd_bin_edges(
    input: Tensor,
    bins: _size,
    *,
    range: Sequence[_float] | None = None,
    weight: Tensor | None = None,
    density: _bool = False,
) -> tuple[Tensor, ...]: ...
def _histogramdd_from_bin_cts(
    input: Tensor,
    bins: _size,
    *,
    range: Sequence[_float] | None = None,
    weight: Tensor | None = None,
    density: _bool = False,
) -> Tensor: ...
def _histogramdd_from_bin_tensors(
    input: Tensor,
    bins: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    weight: Tensor | None = None,
    density: _bool = False,
) -> Tensor: ...
def _index_put_impl_(
    input: Tensor,
    indices: tuple[Tensor, ...] | list[Tensor] | None,
    values: Tensor,
    accumulate: _bool = False,
    unsafe: _bool = False,
) -> Tensor: ...
def _indices_copy(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def _int_mm(
    input: Tensor,
    mat2: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _is_all_true(input: Tensor) -> Tensor: ...
def _is_any_true(input: Tensor) -> Tensor: ...
def _is_functional_tensor(t: Tensor) -> _bool: ...
def _is_functional_tensor_base(t: Tensor) -> _bool: ...
def _is_zerotensor(input: Tensor) -> _bool: ...
def _lazy_clone(input: Tensor) -> Tensor: ...
def _linalg_check_errors(
    info: Tensor,
    api_name: str,
    *,
    is_matrix: _bool,
) -> None: ...
def _linalg_det(
    A: Tensor,
    *,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> torch.return_types._linalg_det: ...
def _linalg_eigh(
    A: Tensor,
    UPLO: str = "L",
    compute_v: _bool = True,
    *,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> torch.return_types._linalg_eigh: ...
def _linalg_slogdet(
    A: Tensor,
    *,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> torch.return_types._linalg_slogdet: ...
def _linalg_solve_ex(
    A: Tensor,
    B: Tensor,
    *,
    left: _bool = True,
    check_errors: _bool = False,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> torch.return_types._linalg_solve_ex: ...
def _linalg_svd(
    A: Tensor,
    full_matrices: _bool = False,
    compute_uv: _bool = True,
    *,
    driver: str | None = None,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> torch.return_types._linalg_svd: ...
def _log_softmax(
    input: Tensor,
    dim: _int,
    half_to_float: _bool,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _log_softmax_backward_data(
    grad_output: Tensor,
    output: Tensor,
    dim: _int,
    input_dtype: _dtype,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _logcumsumexp(
    input: Tensor,
    dim: _int,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _lstm_mps(
    input: Tensor,
    hx: tuple[Tensor, ...] | list[Tensor] | None,
    params: tuple[Tensor, ...] | list[Tensor] | None,
    has_biases: _bool,
    num_layers: _int,
    dropout: _float,
    train: _bool,
    bidirectional: _bool,
    batch_first: _bool,
) -> tuple[Tensor, Tensor, Tensor, Tensor, Tensor, Tensor]: ...
def _lu_with_info(
    input: Tensor,
    pivot: _bool = True,
    check_errors: _bool = True,
) -> torch.return_types._lu_with_info: ...
def _make_dep_token(
    *,
    memory_format: memory_format | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor: ...
def _make_dual(primal: Tensor, tangent: Tensor, level: _int) -> Tensor: ...
def _make_dual_copy(
    primal: Tensor,
    tangent: Tensor,
    level: _int,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _make_per_channel_quantized_tensor(
    input: Tensor,
    scale: Tensor,
    zero_point: Tensor,
    axis: _int,
) -> Tensor: ...
def _make_per_tensor_quantized_tensor(
    input: Tensor,
    scale: _float,
    zero_point: _int,
) -> Tensor: ...
def _masked_scale(input: Tensor, mask: Tensor, scale: _float) -> Tensor: ...
def _masked_softmax(
    input: Tensor,
    mask: Tensor,
    dim: _int | None = None,
    mask_type: _int | None = None,
) -> Tensor: ...
def _mixed_dtypes_linear(
    input: Tensor,
    weight: Tensor,
    scale: Tensor,
    *,
    bias: Tensor | None = None,
    activation: str | None = None,
) -> Tensor: ...
def _mkldnn_reshape(input: Tensor, shape: _size) -> Tensor: ...
def _mkldnn_transpose(input: Tensor, dim0: _int, dim1: _int) -> Tensor: ...
def _mkldnn_transpose_(input: Tensor, dim0: _int, dim1: _int) -> Tensor: ...
def _mps_convolution(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None,
    padding: Sequence[_int | SymInt],
    stride: Sequence[_int | SymInt],
    dilation: Sequence[_int | SymInt],
    groups: _int | SymInt,
) -> Tensor: ...
def _mps_convolution_transpose(
    input: Tensor,
    weight: Tensor,
    padding: Sequence[_int | SymInt],
    output_padding: Sequence[_int | SymInt],
    stride: Sequence[_int | SymInt],
    dilation: Sequence[_int | SymInt],
    groups: _int | SymInt,
) -> Tensor: ...
@overload
def _native_batch_norm_legit(
    input: Tensor,
    weight: Tensor | None,
    bias: Tensor | None,
    running_mean: Tensor,
    running_var: Tensor,
    training: _bool,
    momentum: _float,
    eps: _float,
    *,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> tuple[Tensor, Tensor, Tensor]: ...
@overload
def _native_batch_norm_legit(
    input: Tensor,
    weight: Tensor | None,
    bias: Tensor | None,
    training: _bool,
    momentum: _float,
    eps: _float,
    *,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> tuple[Tensor, Tensor, Tensor]: ...
def _native_batch_norm_legit_no_training(
    input: Tensor,
    weight: Tensor | None,
    bias: Tensor | None,
    running_mean: Tensor,
    running_var: Tensor,
    momentum: _float,
    eps: _float,
) -> tuple[Tensor, Tensor, Tensor]: ...
def _native_multi_head_attention(
    query: Tensor,
    key: Tensor,
    value: Tensor,
    embed_dim: _int,
    num_head: _int,
    qkv_weight: Tensor,
    qkv_bias: Tensor,
    proj_weight: Tensor,
    proj_bias: Tensor,
    mask: Tensor | None = None,
    need_weights: _bool = True,
    average_attn_weights: _bool = True,
    mask_type: _int | None = None,
) -> tuple[Tensor, Tensor]: ...
def _neg_view(input: Tensor) -> Tensor: ...
def _neg_view_copy(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def _nested_compute_contiguous_strides_offsets(
    nested_size: Tensor,
) -> tuple[Tensor, Tensor]: ...
def _nested_from_padded(
    padded: Tensor,
    cpu_nested_shape_example: Tensor,
    fuse_transform_0213: _bool = False,
) -> Tensor: ...
def _nested_from_padded_and_nested_example(
    padded: Tensor,
    nt_example: Tensor,
) -> Tensor: ...
def _nested_from_padded_tensor(
    padded: Tensor,
    offsets: Tensor,
    dummy: Tensor,
    ragged_idx: _int = 1,
    min_seqlen: Tensor | None = None,
    max_seqlen: Tensor | None = None,
    sum_S: _int | SymInt | None = None,
) -> Tensor: ...
def _nested_get_jagged_dummy(any: Tensor) -> Tensor: ...
def _nested_get_lengths(input: Tensor) -> Tensor: ...
def _nested_get_max_seqlen(input: Tensor) -> Tensor: ...
def _nested_get_min_seqlen(input: Tensor) -> Tensor: ...
def _nested_get_offsets(input: Tensor) -> Tensor: ...
def _nested_get_ragged_idx(input: Tensor) -> _int: ...
def _nested_get_values(input: Tensor) -> Tensor: ...
def _nested_get_values_copy(
    input: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _nested_tensor_from_mask(
    t: Tensor,
    mask: Tensor,
    mask_check: _bool = True,
) -> Tensor: ...
def _nested_tensor_from_mask_left_aligned(t: Tensor, mask: Tensor) -> _bool: ...
def _nested_tensor_from_tensor_list(
    list: tuple[Tensor, ...] | list[Tensor] | None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = None,
) -> Tensor: ...
def _nested_tensor_softmax_with_shape(
    input: Tensor,
    query: Tensor,
) -> Tensor: ...
def _nested_view_from_buffer(
    input: Tensor,
    nested_size: Tensor,
    nested_strides: Tensor,
    offsets: Tensor,
) -> Tensor: ...
def _nested_view_from_buffer_copy(
    input: Tensor,
    nested_size: Tensor,
    nested_strides: Tensor,
    offsets: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _nested_view_from_jagged(
    input: Tensor,
    offsets: Tensor,
    dummy: Tensor,
    lengths: Tensor | None = None,
    ragged_idx: _int = 1,
    min_seqlen: Tensor | None = None,
    max_seqlen: Tensor | None = None,
) -> Tensor: ...
def _nested_view_from_jagged_copy(
    input: Tensor,
    offsets: Tensor,
    dummy: Tensor,
    lengths: Tensor | None = None,
    ragged_idx: _int = 1,
    min_seqlen: Tensor | None = None,
    max_seqlen: Tensor | None = None,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _nnpack_available() -> _bool: ...
def _nnpack_spatial_convolution(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None,
    padding: _int | SymInt | Sequence[_int | SymInt],
    stride: _int | SymInt | Sequence[_int | SymInt] = 1,
) -> Tensor: ...
def _pack_padded_sequence(
    input: Tensor,
    lengths: Tensor,
    batch_first: _bool,
) -> tuple[Tensor, Tensor]: ...
def _pad_packed_sequence(
    data: Tensor,
    batch_sizes: Tensor,
    batch_first: _bool,
    padding_value: Number | _complex,
    total_length: _int,
) -> tuple[Tensor, Tensor]: ...
def _pin_memory(
    input: Tensor,
    device: DeviceLikeType | None = None,
) -> Tensor: ...
def _prelu_kernel(input: Tensor, weight: Tensor) -> Tensor: ...
def _print(s: str) -> None: ...
def _propagate_xla_data(input: Tensor, output: Tensor) -> None: ...
def _remove_batch_dim(
    input: Tensor,
    level: _int,
    batch_size: _int | SymInt,
    out_dim: _int,
) -> Tensor: ...
def _reshape_alias_copy(
    input: Tensor,
    size: Sequence[_int | SymInt],
    stride: Sequence[_int | SymInt],
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _reshape_from_tensor(input: Tensor, shape: Tensor) -> Tensor: ...
def _resize_output_(
    input: Tensor,
    size: Sequence[_int | SymInt],
    device: DeviceLikeType | None,
) -> Tensor: ...
def _rowwise_prune(
    weight: Tensor,
    mask: Tensor,
    compressed_indices_dtype: _dtype,
) -> tuple[Tensor, Tensor]: ...
def _safe_softmax(
    input: Tensor,
    dim: _int,
    dtype: _dtype | None = None,
) -> Tensor: ...
def _sample_dirichlet(
    input: Tensor,
    generator: Generator | None = None,
) -> Tensor: ...
def _saturate_weight_to_fp16(weight: Tensor) -> Tensor: ...
def _scaled_dot_product_attention_math(
    query: Tensor,
    key: Tensor,
    value: Tensor,
    attn_mask: Tensor | None = None,
    dropout_p: _float = 0.0,
    is_causal: _bool = False,
    dropout_mask: Tensor | None = None,
    *,
    scale: _float | None = None,
    enable_gqa: _bool = False,
) -> tuple[Tensor, Tensor]: ...
def _scaled_dot_product_attention_math_for_mps(
    query: Tensor,
    key: Tensor,
    value: Tensor,
    attn_mask: Tensor | None = None,
    dropout_p: _float = 0.0,
    is_causal: _bool = False,
    dropout_mask: Tensor | None = None,
    *,
    scale: _float | None = None,
) -> tuple[Tensor, Tensor]: ...
def _scaled_dot_product_cudnn_attention(
    query: Tensor,
    key: Tensor,
    value: Tensor,
    attn_bias: Tensor | None,
    compute_log_sumexp: _bool,
    dropout_p: _float = 0.0,
    is_causal: _bool = False,
    return_debug_mask: _bool = False,
    *,
    scale: _float | None = None,
) -> torch.return_types._scaled_dot_product_cudnn_attention: ...
def _scaled_dot_product_efficient_attention(
    query: Tensor,
    key: Tensor,
    value: Tensor,
    attn_bias: Tensor | None,
    compute_log_sumexp: _bool,
    dropout_p: _float = 0.0,
    is_causal: _bool = False,
    *,
    scale: _float | None = None,
) -> torch.return_types._scaled_dot_product_efficient_attention: ...
def _scaled_dot_product_flash_attention(
    query: Tensor,
    key: Tensor,
    value: Tensor,
    dropout_p: _float = 0.0,
    is_causal: _bool = False,
    return_debug_mask: _bool = False,
    *,
    scale: _float | None = None,
) -> torch.return_types._scaled_dot_product_flash_attention: ...
def _scaled_dot_product_flash_attention_for_cpu(
    query: Tensor,
    key: Tensor,
    value: Tensor,
    dropout_p: _float = 0.0,
    is_causal: _bool = False,
    *,
    attn_mask: Tensor | None = None,
    scale: _float | None = None,
) -> torch.return_types._scaled_dot_product_flash_attention_for_cpu: ...
def _scaled_grouped_mm(
    input: Tensor,
    mat2: Tensor,
    scale_a: Tensor,
    scale_b: Tensor,
    offs: Tensor | None = None,
    bias: Tensor | None = None,
    scale_result: Tensor | None = None,
    out_dtype: _dtype | None = None,
    use_fast_accum: _bool = False,
) -> Tensor: ...
def _scaled_mm(
    input: Tensor,
    mat2: Tensor,
    scale_a: Tensor,
    scale_b: Tensor,
    bias: Tensor | None = None,
    scale_result: Tensor | None = None,
    out_dtype: _dtype | None = None,
    use_fast_accum: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _shape_as_tensor(input: Tensor) -> Tensor: ...
def _sobol_engine_draw(
    quasi: Tensor,
    n: _int,
    sobolstate: Tensor,
    dimension: _int,
    num_generated: _int,
    dtype: _dtype | None,
) -> tuple[Tensor, Tensor]: ...
def _sobol_engine_ff_(
    input: Tensor,
    n: _int,
    sobolstate: Tensor,
    dimension: _int,
    num_generated: _int,
) -> Tensor: ...
def _sobol_engine_initialize_state_(
    input: Tensor,
    dimension: _int,
) -> Tensor: ...
def _sobol_engine_scramble_(
    input: Tensor,
    ltm: Tensor,
    dimension: _int,
) -> Tensor: ...
def _softmax(
    input: Tensor,
    dim: _int,
    half_to_float: _bool,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _softmax_backward_data(
    grad_output: Tensor,
    output: Tensor,
    dim: _int,
    input_dtype: _dtype,
    *,
    grad_input: Tensor | None = None,
) -> Tensor: ...
def _sparse_broadcast_to(input: Tensor, size: _size) -> Tensor: ...
def _sparse_broadcast_to_copy(
    input: Tensor,
    size: _size,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _sparse_csr_prod(
    input: Tensor,
    dim: _int | _size,
    keepdim: _bool = False,
    *,
    dtype: _dtype | None = None,
) -> Tensor: ...
def _sparse_csr_sum(
    input: Tensor,
    dim: _int | _size,
    keepdim: _bool = False,
    *,
    dtype: _dtype | None = None,
) -> Tensor: ...
def _sparse_log_softmax_backward_data(
    grad_output: Tensor,
    output: Tensor,
    dim: _int,
    input: Tensor,
) -> Tensor: ...
def _sparse_semi_structured_addmm(
    input: Tensor,
    mat1: Tensor,
    mat1_meta: Tensor,
    mat2: Tensor,
    *,
    alpha: Number | _complex = 1,
    beta: Number | _complex = 1,
    out_dtype: _dtype | None = None,
) -> Tensor: ...
def _sparse_semi_structured_apply(
    input: Tensor,
    thread_masks: Tensor,
) -> tuple[Tensor, Tensor]: ...
def _sparse_semi_structured_apply_dense(
    input: Tensor,
    thread_masks: Tensor,
) -> Tensor: ...
def _sparse_semi_structured_linear(
    input: Tensor,
    weight: Tensor,
    meta: Tensor,
    *,
    bias: Tensor | None = None,
    activation: str | None = None,
    out_dtype: _dtype | None = None,
) -> Tensor: ...
def _sparse_semi_structured_mm(
    mat1: Tensor,
    mat1_meta: Tensor,
    mat2: Tensor,
    *,
    out_dtype: _dtype | None = None,
) -> Tensor: ...
def _sparse_semi_structured_tile(
    input: Tensor,
    algorithm: str = "",
    use_cutlass: _bool = True,
) -> tuple[Tensor, Tensor, Tensor, Tensor, Tensor]: ...
def _sparse_softmax_backward_data(
    grad_output: Tensor,
    output: Tensor,
    dim: _int,
    input: Tensor,
) -> Tensor: ...
def _sparse_sparse_matmul(input: Tensor, other: Tensor) -> Tensor: ...
@overload
def _sparse_sum(input: Tensor) -> Tensor: ...
@overload
def _sparse_sum(input: Tensor, *, dtype: _dtype) -> Tensor: ...
@overload
def _sparse_sum(input: Tensor, dim: _int | _size) -> Tensor: ...
@overload
def _sparse_sum(
    input: Tensor,
    dim: _int | _size,
    *,
    dtype: _dtype,
) -> Tensor: ...
def _stack(
    tensors: tuple[Tensor, ...] | list[Tensor] | None,
    dim: _int = 0,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _standard_gamma(
    input: Tensor,
    generator: Generator | None = None,
) -> Tensor: ...
def _standard_gamma_grad(input: Tensor, output: Tensor) -> Tensor: ...
def _sync(t: Tensor) -> None: ...
@overload
def _test_autograd_multiple_dispatch(input: Tensor) -> Tensor: ...
@overload
def _test_autograd_multiple_dispatch(input: Tensor, b: _bool) -> Tensor: ...
def _test_autograd_multiple_dispatch_view(input: Tensor) -> Tensor: ...
def _test_autograd_multiple_dispatch_view_copy(
    input: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def _test_check_tensor(input: Tensor) -> Tensor: ...
def _test_functorch_fallback(input: Tensor, other: Tensor) -> Tensor: ...
def _test_parallel_materialize(
    input: Tensor,
    num_parallel: _int,
    skip_first: _bool = False,
) -> Tensor: ...
def _test_serialization_subcmul(
    input: Tensor,
    other: Tensor,
    alpha: Number | _complex = 1,
) -> Tensor: ...
def _to_cpu(
    tensors: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]: ...
def _to_functional_tensor(t: Tensor) -> Tensor: ...
def _to_sparse_semi_structured(dense: Tensor) -> tuple[Tensor, Tensor]: ...
def _transform_bias_rescale_qkv(
    qkv: Tensor,
    qkv_bias: Tensor,
    num_heads: _int,
) -> tuple[Tensor, Tensor, Tensor]: ...
def _transformer_encoder_layer_fwd(
    src: Tensor,
    embed_dim: _int,
    num_heads: _int,
    qkv_weight: Tensor,
    qkv_bias: Tensor,
    proj_weight: Tensor,
    proj_bias: Tensor,
    use_gelu: _bool,
    norm_first: _bool,
    eps: _float,
    norm_weight_1: Tensor,
    norm_bias_1: Tensor,
    norm_weight_2: Tensor,
    norm_bias_2: Tensor,
    ffn_weight_1: Tensor,
    ffn_bias_1: Tensor,
    ffn_weight_2: Tensor,
    ffn_bias_2: Tensor,
    mask: Tensor | None = None,
    mask_type: _int | None = None,
) -> Tensor: ...
def _trilinear(
    i1: Tensor,
    i2: Tensor,
    i3: Tensor,
    expand1: _size,
    expand2: _size,
    expand3: _size,
    sumdim: _size,
    unroll_dim: _int = 1,
) -> Tensor: ...
def _triton_multi_head_attention(
    query: Tensor,
    key: Tensor,
    value: Tensor,
    embed_dim: _int,
    num_head: _int,
    qkv_weight: Tensor,
    qkv_bias: Tensor,
    proj_weight: Tensor,
    proj_bias: Tensor,
    mask: Tensor | None = None,
) -> Tensor: ...
def _triton_scaled_dot_attention(
    q: Tensor,
    k: Tensor,
    v: Tensor,
    dropout_p: _float = 0.0,
) -> Tensor: ...
def _unique(
    input: Tensor,
    sorted: _bool = True,
    return_inverse: _bool = False,
) -> tuple[Tensor, Tensor]: ...
def _unique2(
    input: Tensor,
    sorted: _bool = True,
    return_inverse: _bool = False,
    return_counts: _bool = False,
) -> tuple[Tensor, Tensor, Tensor]: ...
def _unpack_dual(
    dual: Tensor,
    level: _int,
) -> torch.return_types._unpack_dual: ...
def _unsafe_index(
    input: Tensor,
    indices: tuple[Tensor, ...] | list[Tensor] | None,
) -> Tensor: ...
def _unsafe_index_put(
    input: Tensor,
    indices: tuple[Tensor, ...] | list[Tensor] | None,
    values: Tensor,
    accumulate: _bool = False,
) -> Tensor: ...
def _unsafe_masked_index(
    input: Tensor,
    mask: Tensor,
    indices: tuple[Tensor, ...] | list[Tensor] | None,
    fill: Number | _complex,
) -> Tensor: ...
def _unsafe_masked_index_put_accumulate(
    input: Tensor,
    mask: Tensor,
    indices: tuple[Tensor, ...] | list[Tensor] | None,
    values: Tensor,
) -> Tensor: ...
@overload
def _use_cudnn_ctc_loss(
    log_probs: Tensor,
    targets: Tensor,
    input_lengths: Tensor,
    target_lengths: Tensor,
    blank: _int,
) -> _bool: ...
@overload
def _use_cudnn_ctc_loss(
    log_probs: Tensor,
    targets: Tensor,
    input_lengths: _size,
    target_lengths: _size,
    blank: _int,
) -> _bool: ...
def _use_cudnn_rnn_flatten_weight() -> _bool: ...
def _validate_compressed_sparse_indices(
    is_crow: _bool,
    compressed_idx: Tensor,
    plain_idx: Tensor,
    cdim: _int,
    dim: _int,
    nnz: _int,
) -> None: ...
def _validate_sparse_bsc_tensor_args(
    ccol_indices: Tensor,
    row_indices: Tensor,
    values: Tensor,
    size: _size,
    check_pinning: _bool | None = None,
) -> None: ...
def _validate_sparse_bsr_tensor_args(
    crow_indices: Tensor,
    col_indices: Tensor,
    values: Tensor,
    size: _size,
    check_pinning: _bool | None = None,
) -> None: ...
def _validate_sparse_compressed_tensor_args(
    compressed_indices: Tensor,
    plain_indices: Tensor,
    values: Tensor,
    size: _size,
    layout: _layout,
    check_pinning: _bool | None = None,
) -> None: ...
def _validate_sparse_coo_tensor_args(
    indices: Tensor,
    values: Tensor,
    size: _size,
    is_coalesced: _bool | None = None,
    check_pinning: _bool | None = None,
) -> None: ...
def _validate_sparse_csc_tensor_args(
    ccol_indices: Tensor,
    row_indices: Tensor,
    values: Tensor,
    size: _size,
    check_pinning: _bool | None = None,
) -> None: ...
def _validate_sparse_csr_tensor_args(
    crow_indices: Tensor,
    col_indices: Tensor,
    values: Tensor,
    size: _size,
    check_pinning: _bool | None = None,
) -> None: ...
def _values_copy(input: Tensor, *, out: Tensor | None = None) -> Tensor: ...
def _weight_int4pack_mm(
    input: Tensor,
    mat2: Tensor,
    qGroupSize: _int,
    qScaleAndZeros: Tensor,
) -> Tensor: ...
def _weight_int4pack_mm_for_cpu(
    input: Tensor,
    mat2: Tensor,
    qGroupSize: _int,
    qScaleAndZeros: Tensor,
) -> Tensor: ...
def _weight_int4pack_mm_with_scales_and_zeros(
    input: Tensor,
    mat2: Tensor,
    qGroupSize: _int,
    qScale: Tensor,
    qZeros: Tensor,
) -> Tensor: ...
def _weight_int8pack_mm(
    input: Tensor,
    mat2: Tensor,
    scales: Tensor,
) -> Tensor: ...
def _weight_norm(v: Tensor, g: Tensor, dim: _int = 0) -> Tensor: ...
def _weight_norm_interface(
    v: Tensor,
    g: Tensor,
    dim: _int = 0,
) -> tuple[Tensor, Tensor]: ...
def _wrapped_linear_prepack(
    weight: Tensor,
    weight_scale: Tensor,
    weight_zero_point: Tensor,
    bias: Tensor,
) -> Tensor: ...
def _wrapped_quantized_linear_prepacked(
    input: Tensor,
    input_scale: Tensor,
    input_zero_point: Tensor,
    packed_weight: Tensor,
    output_scale: Tensor,
    output_zero_point: Tensor,
    out_channel: _int,
) -> Tensor: ...
def abs(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    abs(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Computes the absolute value of each element in :attr:`input`.

    .. math::
        \text{out}_{i} = |\text{input}_{i}|

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.abs(torch.tensor([-1, -2, 3]))
        tensor([ 1,  2,  3])
    """

def abs_(input: Tensor) -> Tensor: ...
def absolute(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    absolute(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Alias for :func:`torch.abs`
    """

def acos(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    acos(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Computes the inverse cosine of each element in :attr:`input`.

    .. math::
        \text{out}_{i} = \cos^{-1}(\text{input}_{i})

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4)
        >>> a
        tensor([ 0.3348, -0.5889,  0.2005, -0.1584])
        >>> torch.acos(a)
        tensor([ 1.2294,  2.2004,  1.3690,  1.7298])
    """

def acos_(input: Tensor) -> Tensor: ...
def acosh(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    acosh(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Returns a new tensor with the inverse hyperbolic cosine of the elements of :attr:`input`.

    .. math::
        \text{out}_{i} = \cosh^{-1}(\text{input}_{i})

    Note:
        The domain of the inverse hyperbolic cosine is `[1, inf)` and values outside this range
        will be mapped to ``NaN``, except for `+ INF` for which the output is mapped to `+ INF`.

    Args:
        input (Tensor): the input tensor.

    Keyword arguments:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4).uniform_(1, 2)
        >>> a
        tensor([ 1.3192, 1.9915, 1.9674, 1.7151 ])
        >>> torch.acosh(a)
        tensor([ 0.7791, 1.3120, 1.2979, 1.1341 ])
    """

def acosh_(input: Tensor) -> Tensor: ...
def adaptive_avg_pool1d(input: Tensor, output_size: _int | _size) -> Tensor: ...
def adaptive_max_pool1d(
    input: Tensor,
    output_size: _int | _size,
) -> tuple[Tensor, Tensor]: ...
@overload
def add(
    input: Tensor | Number | _complex,
    other: Tensor | Number | _complex,
    *,
    alpha: Number | _complex | None = 1,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    add(input, other, *, alpha=1, out=None) -> Tensor

    Adds :attr:`other`, scaled by :attr:`alpha`, to :attr:`input`.

    .. math::
        \text{{out}}_i = \text{{input}}_i + \text{{alpha}} \times \text{{other}}_i


    Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
    :ref:`type promotion <type-promotion-doc>`, and integer, float, and complex inputs.

    Args:
        input (Tensor): the input tensor.
        other (Tensor or Number): the tensor or number to add to :attr:`input`.

    Keyword arguments:
        alpha (Number): the multiplier for :attr:`other`.
        out (Tensor, optional): the output tensor.

    Examples::

        >>> a = torch.randn(4)
        >>> a
        tensor([ 0.0202,  1.0985,  1.3506, -0.6056])
        >>> torch.add(a, 20)
        tensor([ 20.0202,  21.0985,  21.3506,  19.3944])

        >>> b = torch.randn(4)
        >>> b
        tensor([-0.9732, -0.3497,  0.6245,  0.4022])
        >>> c = torch.randn(4, 1)
        >>> c
        tensor([[ 0.3743],
                [-1.7724],
                [-0.5811],
                [-0.8017]])
        >>> torch.add(b, c, alpha=10)
        tensor([[  2.7695,   3.3930,   4.3672,   4.1450],
                [-18.6971, -18.0736, -17.0994, -17.3216],
                [ -6.7845,  -6.1610,  -5.1868,  -5.4090],
                [ -8.9902,  -8.3667,  -7.3925,  -7.6147]])
    """

@overload
def add(self: Tensor, alpha: Number | _complex, other: Tensor) -> Tensor:
    r"""
    add(input, other, *, alpha=1, out=None) -> Tensor

    Adds :attr:`other`, scaled by :attr:`alpha`, to :attr:`input`.

    .. math::
        \text{{out}}_i = \text{{input}}_i + \text{{alpha}} \times \text{{other}}_i


    Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
    :ref:`type promotion <type-promotion-doc>`, and integer, float, and complex inputs.

    Args:
        input (Tensor): the input tensor.
        other (Tensor or Number): the tensor or number to add to :attr:`input`.

    Keyword arguments:
        alpha (Number): the multiplier for :attr:`other`.
        out (Tensor, optional): the output tensor.

    Examples::

        >>> a = torch.randn(4)
        >>> a
        tensor([ 0.0202,  1.0985,  1.3506, -0.6056])
        >>> torch.add(a, 20)
        tensor([ 20.0202,  21.0985,  21.3506,  19.3944])

        >>> b = torch.randn(4)
        >>> b
        tensor([-0.9732, -0.3497,  0.6245,  0.4022])
        >>> c = torch.randn(4, 1)
        >>> c
        tensor([[ 0.3743],
                [-1.7724],
                [-0.5811],
                [-0.8017]])
        >>> torch.add(b, c, alpha=10)
        tensor([[  2.7695,   3.3930,   4.3672,   4.1450],
                [-18.6971, -18.0736, -17.0994, -17.3216],
                [ -6.7845,  -6.1610,  -5.1868,  -5.4090],
                [ -8.9902,  -8.3667,  -7.3925,  -7.6147]])
    """

@overload
def add(
    self: Tensor,
    alpha: Number | _complex,
    other: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    add(input, other, *, alpha=1, out=None) -> Tensor

    Adds :attr:`other`, scaled by :attr:`alpha`, to :attr:`input`.

    .. math::
        \text{{out}}_i = \text{{input}}_i + \text{{alpha}} \times \text{{other}}_i


    Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
    :ref:`type promotion <type-promotion-doc>`, and integer, float, and complex inputs.

    Args:
        input (Tensor): the input tensor.
        other (Tensor or Number): the tensor or number to add to :attr:`input`.

    Keyword arguments:
        alpha (Number): the multiplier for :attr:`other`.
        out (Tensor, optional): the output tensor.

    Examples::

        >>> a = torch.randn(4)
        >>> a
        tensor([ 0.0202,  1.0985,  1.3506, -0.6056])
        >>> torch.add(a, 20)
        tensor([ 20.0202,  21.0985,  21.3506,  19.3944])

        >>> b = torch.randn(4)
        >>> b
        tensor([-0.9732, -0.3497,  0.6245,  0.4022])
        >>> c = torch.randn(4, 1)
        >>> c
        tensor([[ 0.3743],
                [-1.7724],
                [-0.5811],
                [-0.8017]])
        >>> torch.add(b, c, alpha=10)
        tensor([[  2.7695,   3.3930,   4.3672,   4.1450],
                [-18.6971, -18.0736, -17.0994, -17.3216],
                [ -6.7845,  -6.1610,  -5.1868,  -5.4090],
                [ -8.9902,  -8.3667,  -7.3925,  -7.6147]])
    """

@overload
def addbmm(
    beta: Number | _complex,
    self: Tensor,
    alpha: Number | _complex,
    batch1: Tensor,
    batch2: Tensor,
) -> Tensor:
    r"""
    addbmm(input, batch1, batch2, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices stored
    in :attr:`batch1` and :attr:`batch2`,
    with a reduced add step (all matrix multiplications get accumulated
    along the first dimension).
    :attr:`input` is added to the final result.

    :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the
    same number of matrices.

    If :attr:`batch1` is a :math:`(b \times n \times m)` tensor, :attr:`batch2` is a
    :math:`(b \times m \times p)` tensor, :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \times p)` tensor
    and :attr:`out` will be a :math:`(n \times p)` tensor.

    .. math::
        out = \beta\ \text{input} + \alpha\ (\sum_{i=0}^{b-1} \text{batch1}_i \mathbin{@} \text{batch2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and :attr:`alpha`
    must be real numbers, otherwise they should be integers.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): matrix to be added
        batch1 (Tensor): the first batch of matrices to be multiplied
        batch2 (Tensor): the second batch of matrices to be multiplied

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for `batch1 @ batch2` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(3, 5)
        >>> batch1 = torch.randn(10, 3, 4)
        >>> batch2 = torch.randn(10, 4, 5)
        >>> torch.addbmm(M, batch1, batch2)
        tensor([[  6.6311,   0.0503,   6.9768, -12.0362,  -2.1653],
                [ -4.8185,  -1.4255,  -6.6760,   8.9453,   2.5743],
                [ -3.8202,   4.3691,   1.0943,  -1.1109,   5.4730]])
    """

@overload
def addbmm(
    beta: Number | _complex,
    self: Tensor,
    alpha: Number | _complex,
    batch1: Tensor,
    batch2: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    addbmm(input, batch1, batch2, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices stored
    in :attr:`batch1` and :attr:`batch2`,
    with a reduced add step (all matrix multiplications get accumulated
    along the first dimension).
    :attr:`input` is added to the final result.

    :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the
    same number of matrices.

    If :attr:`batch1` is a :math:`(b \times n \times m)` tensor, :attr:`batch2` is a
    :math:`(b \times m \times p)` tensor, :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \times p)` tensor
    and :attr:`out` will be a :math:`(n \times p)` tensor.

    .. math::
        out = \beta\ \text{input} + \alpha\ (\sum_{i=0}^{b-1} \text{batch1}_i \mathbin{@} \text{batch2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and :attr:`alpha`
    must be real numbers, otherwise they should be integers.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): matrix to be added
        batch1 (Tensor): the first batch of matrices to be multiplied
        batch2 (Tensor): the second batch of matrices to be multiplied

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for `batch1 @ batch2` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(3, 5)
        >>> batch1 = torch.randn(10, 3, 4)
        >>> batch2 = torch.randn(10, 4, 5)
        >>> torch.addbmm(M, batch1, batch2)
        tensor([[  6.6311,   0.0503,   6.9768, -12.0362,  -2.1653],
                [ -4.8185,  -1.4255,  -6.6760,   8.9453,   2.5743],
                [ -3.8202,   4.3691,   1.0943,  -1.1109,   5.4730]])
    """

@overload
def addbmm(
    input: Tensor,
    batch1: Tensor,
    batch2: Tensor,
    *,
    beta: Number | _complex = 1,
    alpha: Number | _complex = 1,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    addbmm(input, batch1, batch2, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices stored
    in :attr:`batch1` and :attr:`batch2`,
    with a reduced add step (all matrix multiplications get accumulated
    along the first dimension).
    :attr:`input` is added to the final result.

    :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the
    same number of matrices.

    If :attr:`batch1` is a :math:`(b \times n \times m)` tensor, :attr:`batch2` is a
    :math:`(b \times m \times p)` tensor, :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \times p)` tensor
    and :attr:`out` will be a :math:`(n \times p)` tensor.

    .. math::
        out = \beta\ \text{input} + \alpha\ (\sum_{i=0}^{b-1} \text{batch1}_i \mathbin{@} \text{batch2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and :attr:`alpha`
    must be real numbers, otherwise they should be integers.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): matrix to be added
        batch1 (Tensor): the first batch of matrices to be multiplied
        batch2 (Tensor): the second batch of matrices to be multiplied

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for `batch1 @ batch2` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(3, 5)
        >>> batch1 = torch.randn(10, 3, 4)
        >>> batch2 = torch.randn(10, 4, 5)
        >>> torch.addbmm(M, batch1, batch2)
        tensor([[  6.6311,   0.0503,   6.9768, -12.0362,  -2.1653],
                [ -4.8185,  -1.4255,  -6.6760,   8.9453,   2.5743],
                [ -3.8202,   4.3691,   1.0943,  -1.1109,   5.4730]])
    """

@overload
def addbmm(
    beta: Number | _complex,
    self: Tensor,
    batch1: Tensor,
    batch2: Tensor,
) -> Tensor:
    r"""
    addbmm(input, batch1, batch2, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices stored
    in :attr:`batch1` and :attr:`batch2`,
    with a reduced add step (all matrix multiplications get accumulated
    along the first dimension).
    :attr:`input` is added to the final result.

    :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the
    same number of matrices.

    If :attr:`batch1` is a :math:`(b \times n \times m)` tensor, :attr:`batch2` is a
    :math:`(b \times m \times p)` tensor, :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \times p)` tensor
    and :attr:`out` will be a :math:`(n \times p)` tensor.

    .. math::
        out = \beta\ \text{input} + \alpha\ (\sum_{i=0}^{b-1} \text{batch1}_i \mathbin{@} \text{batch2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and :attr:`alpha`
    must be real numbers, otherwise they should be integers.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): matrix to be added
        batch1 (Tensor): the first batch of matrices to be multiplied
        batch2 (Tensor): the second batch of matrices to be multiplied

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for `batch1 @ batch2` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(3, 5)
        >>> batch1 = torch.randn(10, 3, 4)
        >>> batch2 = torch.randn(10, 4, 5)
        >>> torch.addbmm(M, batch1, batch2)
        tensor([[  6.6311,   0.0503,   6.9768, -12.0362,  -2.1653],
                [ -4.8185,  -1.4255,  -6.6760,   8.9453,   2.5743],
                [ -3.8202,   4.3691,   1.0943,  -1.1109,   5.4730]])
    """

@overload
def addbmm(
    beta: Number | _complex,
    self: Tensor,
    batch1: Tensor,
    batch2: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    addbmm(input, batch1, batch2, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices stored
    in :attr:`batch1` and :attr:`batch2`,
    with a reduced add step (all matrix multiplications get accumulated
    along the first dimension).
    :attr:`input` is added to the final result.

    :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the
    same number of matrices.

    If :attr:`batch1` is a :math:`(b \times n \times m)` tensor, :attr:`batch2` is a
    :math:`(b \times m \times p)` tensor, :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \times p)` tensor
    and :attr:`out` will be a :math:`(n \times p)` tensor.

    .. math::
        out = \beta\ \text{input} + \alpha\ (\sum_{i=0}^{b-1} \text{batch1}_i \mathbin{@} \text{batch2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and :attr:`alpha`
    must be real numbers, otherwise they should be integers.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): matrix to be added
        batch1 (Tensor): the first batch of matrices to be multiplied
        batch2 (Tensor): the second batch of matrices to be multiplied

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for `batch1 @ batch2` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(3, 5)
        >>> batch1 = torch.randn(10, 3, 4)
        >>> batch2 = torch.randn(10, 4, 5)
        >>> torch.addbmm(M, batch1, batch2)
        tensor([[  6.6311,   0.0503,   6.9768, -12.0362,  -2.1653],
                [ -4.8185,  -1.4255,  -6.6760,   8.9453,   2.5743],
                [ -3.8202,   4.3691,   1.0943,  -1.1109,   5.4730]])
    """

@overload
def addcdiv(
    self: Tensor,
    value: Number | _complex,
    tensor1: Tensor,
    tensor2: Tensor,
) -> Tensor:
    r"""
    addcdiv(input, tensor1, tensor2, *, value=1, out=None) -> Tensor

    Performs the element-wise division of :attr:`tensor1` by :attr:`tensor2`,
    multiplies the result by the scalar :attr:`value` and adds it to :attr:`input`.

    .. warning::
        Integer division with addcdiv is no longer supported, and in a future
        release addcdiv will perform a true division of tensor1 and tensor2.
        The historic addcdiv behavior can be implemented as
        (input + value * torch.trunc(tensor1 / tensor2)).to(input.dtype)
        for integer inputs and as (input + value * tensor1 / tensor2) for float inputs.
        The future addcdiv behavior is just the latter implementation:
        (input + value * tensor1 / tensor2), for all dtypes.

    .. math::
        \text{out}_i = \text{input}_i + \text{value} \times \frac{\text{tensor1}_i}{\text{tensor2}_i}


    The shapes of :attr:`input`, :attr:`tensor1`, and :attr:`tensor2` must be
    :ref:`broadcastable <broadcasting-semantics>`.

    For inputs of type `FloatTensor` or `DoubleTensor`, :attr:`value` must be
    a real number, otherwise an integer.

    Args:
        input (Tensor): the tensor to be added
        tensor1 (Tensor): the numerator tensor
        tensor2 (Tensor): the denominator tensor

    Keyword args:
        value (Number, optional): multiplier for :math:`\text{tensor1} / \text{tensor2}`
        out (Tensor, optional): the output tensor.

    Example::

        >>> t = torch.randn(1, 3)
        >>> t1 = torch.randn(3, 1)
        >>> t2 = torch.randn(1, 3)
        >>> torch.addcdiv(t, t1, t2, value=0.1)
        tensor([[-0.2312, -3.6496,  0.1312],
                [-1.0428,  3.4292, -0.1030],
                [-0.5369, -0.9829,  0.0430]])
    """

@overload
def addcdiv(
    self: Tensor,
    value: Number | _complex,
    tensor1: Tensor,
    tensor2: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    addcdiv(input, tensor1, tensor2, *, value=1, out=None) -> Tensor

    Performs the element-wise division of :attr:`tensor1` by :attr:`tensor2`,
    multiplies the result by the scalar :attr:`value` and adds it to :attr:`input`.

    .. warning::
        Integer division with addcdiv is no longer supported, and in a future
        release addcdiv will perform a true division of tensor1 and tensor2.
        The historic addcdiv behavior can be implemented as
        (input + value * torch.trunc(tensor1 / tensor2)).to(input.dtype)
        for integer inputs and as (input + value * tensor1 / tensor2) for float inputs.
        The future addcdiv behavior is just the latter implementation:
        (input + value * tensor1 / tensor2), for all dtypes.

    .. math::
        \text{out}_i = \text{input}_i + \text{value} \times \frac{\text{tensor1}_i}{\text{tensor2}_i}


    The shapes of :attr:`input`, :attr:`tensor1`, and :attr:`tensor2` must be
    :ref:`broadcastable <broadcasting-semantics>`.

    For inputs of type `FloatTensor` or `DoubleTensor`, :attr:`value` must be
    a real number, otherwise an integer.

    Args:
        input (Tensor): the tensor to be added
        tensor1 (Tensor): the numerator tensor
        tensor2 (Tensor): the denominator tensor

    Keyword args:
        value (Number, optional): multiplier for :math:`\text{tensor1} / \text{tensor2}`
        out (Tensor, optional): the output tensor.

    Example::

        >>> t = torch.randn(1, 3)
        >>> t1 = torch.randn(3, 1)
        >>> t2 = torch.randn(1, 3)
        >>> torch.addcdiv(t, t1, t2, value=0.1)
        tensor([[-0.2312, -3.6496,  0.1312],
                [-1.0428,  3.4292, -0.1030],
                [-0.5369, -0.9829,  0.0430]])
    """

@overload
def addcdiv(
    input: Tensor,
    tensor1: Tensor,
    tensor2: Tensor,
    *,
    value: Number | _complex = 1,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    addcdiv(input, tensor1, tensor2, *, value=1, out=None) -> Tensor

    Performs the element-wise division of :attr:`tensor1` by :attr:`tensor2`,
    multiplies the result by the scalar :attr:`value` and adds it to :attr:`input`.

    .. warning::
        Integer division with addcdiv is no longer supported, and in a future
        release addcdiv will perform a true division of tensor1 and tensor2.
        The historic addcdiv behavior can be implemented as
        (input + value * torch.trunc(tensor1 / tensor2)).to(input.dtype)
        for integer inputs and as (input + value * tensor1 / tensor2) for float inputs.
        The future addcdiv behavior is just the latter implementation:
        (input + value * tensor1 / tensor2), for all dtypes.

    .. math::
        \text{out}_i = \text{input}_i + \text{value} \times \frac{\text{tensor1}_i}{\text{tensor2}_i}


    The shapes of :attr:`input`, :attr:`tensor1`, and :attr:`tensor2` must be
    :ref:`broadcastable <broadcasting-semantics>`.

    For inputs of type `FloatTensor` or `DoubleTensor`, :attr:`value` must be
    a real number, otherwise an integer.

    Args:
        input (Tensor): the tensor to be added
        tensor1 (Tensor): the numerator tensor
        tensor2 (Tensor): the denominator tensor

    Keyword args:
        value (Number, optional): multiplier for :math:`\text{tensor1} / \text{tensor2}`
        out (Tensor, optional): the output tensor.

    Example::

        >>> t = torch.randn(1, 3)
        >>> t1 = torch.randn(3, 1)
        >>> t2 = torch.randn(1, 3)
        >>> torch.addcdiv(t, t1, t2, value=0.1)
        tensor([[-0.2312, -3.6496,  0.1312],
                [-1.0428,  3.4292, -0.1030],
                [-0.5369, -0.9829,  0.0430]])
    """

@overload
def addcmul(
    self: Tensor,
    value: Number | _complex,
    tensor1: Tensor,
    tensor2: Tensor,
) -> Tensor:
    r"""
    addcmul(input, tensor1, tensor2, *, value=1, out=None) -> Tensor

    Performs the element-wise multiplication of :attr:`tensor1`
    by :attr:`tensor2`, multiplies the result by the scalar :attr:`value`
    and adds it to :attr:`input`.

    .. math::
        \text{out}_i = \text{input}_i + \text{value} \times \text{tensor1}_i \times \text{tensor2}_i

    The shapes of :attr:`tensor`, :attr:`tensor1`, and :attr:`tensor2` must be
    :ref:`broadcastable <broadcasting-semantics>`.

    For inputs of type `FloatTensor` or `DoubleTensor`, :attr:`value` must be
    a real number, otherwise an integer.

    Args:
        input (Tensor): the tensor to be added
        tensor1 (Tensor): the tensor to be multiplied
        tensor2 (Tensor): the tensor to be multiplied

    Keyword args:
        value (Number, optional): multiplier for :math:`tensor1 .* tensor2`
        out (Tensor, optional): the output tensor.

    Example::

        >>> t = torch.randn(1, 3)
        >>> t1 = torch.randn(3, 1)
        >>> t2 = torch.randn(1, 3)
        >>> torch.addcmul(t, t1, t2, value=0.1)
        tensor([[-0.8635, -0.6391,  1.6174],
                [-0.7617, -0.5879,  1.7388],
                [-0.8353, -0.6249,  1.6511]])
    """

@overload
def addcmul(
    self: Tensor,
    value: Number | _complex,
    tensor1: Tensor,
    tensor2: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    addcmul(input, tensor1, tensor2, *, value=1, out=None) -> Tensor

    Performs the element-wise multiplication of :attr:`tensor1`
    by :attr:`tensor2`, multiplies the result by the scalar :attr:`value`
    and adds it to :attr:`input`.

    .. math::
        \text{out}_i = \text{input}_i + \text{value} \times \text{tensor1}_i \times \text{tensor2}_i

    The shapes of :attr:`tensor`, :attr:`tensor1`, and :attr:`tensor2` must be
    :ref:`broadcastable <broadcasting-semantics>`.

    For inputs of type `FloatTensor` or `DoubleTensor`, :attr:`value` must be
    a real number, otherwise an integer.

    Args:
        input (Tensor): the tensor to be added
        tensor1 (Tensor): the tensor to be multiplied
        tensor2 (Tensor): the tensor to be multiplied

    Keyword args:
        value (Number, optional): multiplier for :math:`tensor1 .* tensor2`
        out (Tensor, optional): the output tensor.

    Example::

        >>> t = torch.randn(1, 3)
        >>> t1 = torch.randn(3, 1)
        >>> t2 = torch.randn(1, 3)
        >>> torch.addcmul(t, t1, t2, value=0.1)
        tensor([[-0.8635, -0.6391,  1.6174],
                [-0.7617, -0.5879,  1.7388],
                [-0.8353, -0.6249,  1.6511]])
    """

@overload
def addcmul(
    input: Tensor,
    tensor1: Tensor,
    tensor2: Tensor,
    *,
    value: Number | _complex = 1,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    addcmul(input, tensor1, tensor2, *, value=1, out=None) -> Tensor

    Performs the element-wise multiplication of :attr:`tensor1`
    by :attr:`tensor2`, multiplies the result by the scalar :attr:`value`
    and adds it to :attr:`input`.

    .. math::
        \text{out}_i = \text{input}_i + \text{value} \times \text{tensor1}_i \times \text{tensor2}_i

    The shapes of :attr:`tensor`, :attr:`tensor1`, and :attr:`tensor2` must be
    :ref:`broadcastable <broadcasting-semantics>`.

    For inputs of type `FloatTensor` or `DoubleTensor`, :attr:`value` must be
    a real number, otherwise an integer.

    Args:
        input (Tensor): the tensor to be added
        tensor1 (Tensor): the tensor to be multiplied
        tensor2 (Tensor): the tensor to be multiplied

    Keyword args:
        value (Number, optional): multiplier for :math:`tensor1 .* tensor2`
        out (Tensor, optional): the output tensor.

    Example::

        >>> t = torch.randn(1, 3)
        >>> t1 = torch.randn(3, 1)
        >>> t2 = torch.randn(1, 3)
        >>> torch.addcmul(t, t1, t2, value=0.1)
        tensor([[-0.8635, -0.6391,  1.6174],
                [-0.7617, -0.5879,  1.7388],
                [-0.8353, -0.6249,  1.6511]])
    """

@overload
def addmm(
    beta: Number | _complex,
    self: Tensor,
    alpha: Number | _complex,
    mat1: Tensor,
    mat2: Tensor,
) -> Tensor:
    r"""
    addmm(input, mat1, mat2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a matrix multiplication of the matrices :attr:`mat1` and :attr:`mat2`.
    The matrix :attr:`input` is added to the final result.

    If :attr:`mat1` is a :math:`(n \times m)` tensor, :attr:`mat2` is a
    :math:`(m \times p)` tensor, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \times p)` tensor
    and :attr:`out` will be a :math:`(n \times p)` tensor.

    :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
    :attr:`mat1` and :attr:`mat2` and the added matrix :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{mat1}_i \mathbin{@} \text{mat2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    This operation has support for arguments with :ref:`sparse layouts<sparse-docs>`. If
    :attr:`input` is sparse the result will have the same layout and if :attr:`out`
    is provided it must have the same layout as :attr:`input`.


    .. warning::
        Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,
        or may not have autograd support. If you notice missing functionality please
        open a feature request.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): matrix to be added
        mat1 (Tensor): the first matrix to be matrix multiplied
        mat2 (Tensor): the second matrix to be matrix multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`mat1 @ mat2` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(2, 3)
        >>> mat1 = torch.randn(2, 3)
        >>> mat2 = torch.randn(3, 3)
        >>> torch.addmm(M, mat1, mat2)
        tensor([[-4.8716,  1.4671, -1.3746],
                [ 0.7573, -3.9555, -2.8681]])
    """

@overload
def addmm(
    beta: Number | _complex,
    self: Tensor,
    alpha: Number | _complex,
    mat1: Tensor,
    mat2: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    addmm(input, mat1, mat2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a matrix multiplication of the matrices :attr:`mat1` and :attr:`mat2`.
    The matrix :attr:`input` is added to the final result.

    If :attr:`mat1` is a :math:`(n \times m)` tensor, :attr:`mat2` is a
    :math:`(m \times p)` tensor, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \times p)` tensor
    and :attr:`out` will be a :math:`(n \times p)` tensor.

    :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
    :attr:`mat1` and :attr:`mat2` and the added matrix :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{mat1}_i \mathbin{@} \text{mat2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    This operation has support for arguments with :ref:`sparse layouts<sparse-docs>`. If
    :attr:`input` is sparse the result will have the same layout and if :attr:`out`
    is provided it must have the same layout as :attr:`input`.


    .. warning::
        Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,
        or may not have autograd support. If you notice missing functionality please
        open a feature request.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): matrix to be added
        mat1 (Tensor): the first matrix to be matrix multiplied
        mat2 (Tensor): the second matrix to be matrix multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`mat1 @ mat2` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(2, 3)
        >>> mat1 = torch.randn(2, 3)
        >>> mat2 = torch.randn(3, 3)
        >>> torch.addmm(M, mat1, mat2)
        tensor([[-4.8716,  1.4671, -1.3746],
                [ 0.7573, -3.9555, -2.8681]])
    """

@overload
def addmm(
    input: Tensor,
    mat1: Tensor,
    mat2: Tensor,
    *,
    beta: Number | _complex = 1,
    alpha: Number | _complex = 1,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    addmm(input, mat1, mat2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a matrix multiplication of the matrices :attr:`mat1` and :attr:`mat2`.
    The matrix :attr:`input` is added to the final result.

    If :attr:`mat1` is a :math:`(n \times m)` tensor, :attr:`mat2` is a
    :math:`(m \times p)` tensor, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \times p)` tensor
    and :attr:`out` will be a :math:`(n \times p)` tensor.

    :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
    :attr:`mat1` and :attr:`mat2` and the added matrix :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{mat1}_i \mathbin{@} \text{mat2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    This operation has support for arguments with :ref:`sparse layouts<sparse-docs>`. If
    :attr:`input` is sparse the result will have the same layout and if :attr:`out`
    is provided it must have the same layout as :attr:`input`.


    .. warning::
        Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,
        or may not have autograd support. If you notice missing functionality please
        open a feature request.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): matrix to be added
        mat1 (Tensor): the first matrix to be matrix multiplied
        mat2 (Tensor): the second matrix to be matrix multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`mat1 @ mat2` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(2, 3)
        >>> mat1 = torch.randn(2, 3)
        >>> mat2 = torch.randn(3, 3)
        >>> torch.addmm(M, mat1, mat2)
        tensor([[-4.8716,  1.4671, -1.3746],
                [ 0.7573, -3.9555, -2.8681]])
    """

@overload
def addmm(
    input: Tensor,
    mat1: Tensor,
    mat2: Tensor,
    out_dtype: _dtype,
    *,
    beta: Number | _complex = 1,
    alpha: Number | _complex = 1,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    addmm(input, mat1, mat2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a matrix multiplication of the matrices :attr:`mat1` and :attr:`mat2`.
    The matrix :attr:`input` is added to the final result.

    If :attr:`mat1` is a :math:`(n \times m)` tensor, :attr:`mat2` is a
    :math:`(m \times p)` tensor, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \times p)` tensor
    and :attr:`out` will be a :math:`(n \times p)` tensor.

    :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
    :attr:`mat1` and :attr:`mat2` and the added matrix :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{mat1}_i \mathbin{@} \text{mat2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    This operation has support for arguments with :ref:`sparse layouts<sparse-docs>`. If
    :attr:`input` is sparse the result will have the same layout and if :attr:`out`
    is provided it must have the same layout as :attr:`input`.


    .. warning::
        Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,
        or may not have autograd support. If you notice missing functionality please
        open a feature request.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): matrix to be added
        mat1 (Tensor): the first matrix to be matrix multiplied
        mat2 (Tensor): the second matrix to be matrix multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`mat1 @ mat2` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(2, 3)
        >>> mat1 = torch.randn(2, 3)
        >>> mat2 = torch.randn(3, 3)
        >>> torch.addmm(M, mat1, mat2)
        tensor([[-4.8716,  1.4671, -1.3746],
                [ 0.7573, -3.9555, -2.8681]])
    """

@overload
def addmm(
    beta: Number | _complex,
    self: Tensor,
    mat1: Tensor,
    mat2: Tensor,
) -> Tensor:
    r"""
    addmm(input, mat1, mat2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a matrix multiplication of the matrices :attr:`mat1` and :attr:`mat2`.
    The matrix :attr:`input` is added to the final result.

    If :attr:`mat1` is a :math:`(n \times m)` tensor, :attr:`mat2` is a
    :math:`(m \times p)` tensor, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \times p)` tensor
    and :attr:`out` will be a :math:`(n \times p)` tensor.

    :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
    :attr:`mat1` and :attr:`mat2` and the added matrix :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{mat1}_i \mathbin{@} \text{mat2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    This operation has support for arguments with :ref:`sparse layouts<sparse-docs>`. If
    :attr:`input` is sparse the result will have the same layout and if :attr:`out`
    is provided it must have the same layout as :attr:`input`.


    .. warning::
        Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,
        or may not have autograd support. If you notice missing functionality please
        open a feature request.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): matrix to be added
        mat1 (Tensor): the first matrix to be matrix multiplied
        mat2 (Tensor): the second matrix to be matrix multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`mat1 @ mat2` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(2, 3)
        >>> mat1 = torch.randn(2, 3)
        >>> mat2 = torch.randn(3, 3)
        >>> torch.addmm(M, mat1, mat2)
        tensor([[-4.8716,  1.4671, -1.3746],
                [ 0.7573, -3.9555, -2.8681]])
    """

@overload
def addmm(
    beta: Number | _complex,
    self: Tensor,
    mat1: Tensor,
    mat2: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    addmm(input, mat1, mat2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a matrix multiplication of the matrices :attr:`mat1` and :attr:`mat2`.
    The matrix :attr:`input` is added to the final result.

    If :attr:`mat1` is a :math:`(n \times m)` tensor, :attr:`mat2` is a
    :math:`(m \times p)` tensor, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \times p)` tensor
    and :attr:`out` will be a :math:`(n \times p)` tensor.

    :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
    :attr:`mat1` and :attr:`mat2` and the added matrix :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{mat1}_i \mathbin{@} \text{mat2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    This operation has support for arguments with :ref:`sparse layouts<sparse-docs>`. If
    :attr:`input` is sparse the result will have the same layout and if :attr:`out`
    is provided it must have the same layout as :attr:`input`.


    .. warning::
        Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,
        or may not have autograd support. If you notice missing functionality please
        open a feature request.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): matrix to be added
        mat1 (Tensor): the first matrix to be matrix multiplied
        mat2 (Tensor): the second matrix to be matrix multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`mat1 @ mat2` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(2, 3)
        >>> mat1 = torch.randn(2, 3)
        >>> mat2 = torch.randn(3, 3)
        >>> torch.addmm(M, mat1, mat2)
        tensor([[-4.8716,  1.4671, -1.3746],
                [ 0.7573, -3.9555, -2.8681]])
    """

@overload
def addmv(
    beta: Number | _complex,
    self: Tensor,
    alpha: Number | _complex,
    mat: Tensor,
    vec: Tensor,
) -> Tensor:
    r"""
    addmv(input, mat, vec, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a matrix-vector product of the matrix :attr:`mat` and
    the vector :attr:`vec`.
    The vector :attr:`input` is added to the final result.

    If :attr:`mat` is a :math:`(n \times m)` tensor, :attr:`vec` is a 1-D tensor of
    size `m`, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a 1-D tensor of size `n` and
    :attr:`out` will be 1-D tensor of size `n`.

    :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
    :attr:`mat` and :attr:`vec` and the added tensor :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{mat} \mathbin{@} \text{vec})

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    Args:
        input (Tensor): vector to be added
        mat (Tensor): matrix to be matrix multiplied
        vec (Tensor): vector to be matrix multiplied

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`mat @ vec` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(2)
        >>> mat = torch.randn(2, 3)
        >>> vec = torch.randn(3)
        >>> torch.addmv(M, mat, vec)
        tensor([-0.3768, -5.5565])
    """

@overload
def addmv(
    beta: Number | _complex,
    self: Tensor,
    alpha: Number | _complex,
    mat: Tensor,
    vec: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    addmv(input, mat, vec, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a matrix-vector product of the matrix :attr:`mat` and
    the vector :attr:`vec`.
    The vector :attr:`input` is added to the final result.

    If :attr:`mat` is a :math:`(n \times m)` tensor, :attr:`vec` is a 1-D tensor of
    size `m`, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a 1-D tensor of size `n` and
    :attr:`out` will be 1-D tensor of size `n`.

    :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
    :attr:`mat` and :attr:`vec` and the added tensor :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{mat} \mathbin{@} \text{vec})

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    Args:
        input (Tensor): vector to be added
        mat (Tensor): matrix to be matrix multiplied
        vec (Tensor): vector to be matrix multiplied

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`mat @ vec` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(2)
        >>> mat = torch.randn(2, 3)
        >>> vec = torch.randn(3)
        >>> torch.addmv(M, mat, vec)
        tensor([-0.3768, -5.5565])
    """

@overload
def addmv(
    input: Tensor,
    mat: Tensor,
    vec: Tensor,
    *,
    beta: Number | _complex = 1,
    alpha: Number | _complex = 1,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    addmv(input, mat, vec, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a matrix-vector product of the matrix :attr:`mat` and
    the vector :attr:`vec`.
    The vector :attr:`input` is added to the final result.

    If :attr:`mat` is a :math:`(n \times m)` tensor, :attr:`vec` is a 1-D tensor of
    size `m`, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a 1-D tensor of size `n` and
    :attr:`out` will be 1-D tensor of size `n`.

    :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
    :attr:`mat` and :attr:`vec` and the added tensor :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{mat} \mathbin{@} \text{vec})

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    Args:
        input (Tensor): vector to be added
        mat (Tensor): matrix to be matrix multiplied
        vec (Tensor): vector to be matrix multiplied

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`mat @ vec` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(2)
        >>> mat = torch.randn(2, 3)
        >>> vec = torch.randn(3)
        >>> torch.addmv(M, mat, vec)
        tensor([-0.3768, -5.5565])
    """

@overload
def addmv(
    beta: Number | _complex,
    self: Tensor,
    mat: Tensor,
    vec: Tensor,
) -> Tensor:
    r"""
    addmv(input, mat, vec, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a matrix-vector product of the matrix :attr:`mat` and
    the vector :attr:`vec`.
    The vector :attr:`input` is added to the final result.

    If :attr:`mat` is a :math:`(n \times m)` tensor, :attr:`vec` is a 1-D tensor of
    size `m`, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a 1-D tensor of size `n` and
    :attr:`out` will be 1-D tensor of size `n`.

    :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
    :attr:`mat` and :attr:`vec` and the added tensor :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{mat} \mathbin{@} \text{vec})

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    Args:
        input (Tensor): vector to be added
        mat (Tensor): matrix to be matrix multiplied
        vec (Tensor): vector to be matrix multiplied

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`mat @ vec` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(2)
        >>> mat = torch.randn(2, 3)
        >>> vec = torch.randn(3)
        >>> torch.addmv(M, mat, vec)
        tensor([-0.3768, -5.5565])
    """

@overload
def addmv(
    beta: Number | _complex,
    self: Tensor,
    mat: Tensor,
    vec: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    addmv(input, mat, vec, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a matrix-vector product of the matrix :attr:`mat` and
    the vector :attr:`vec`.
    The vector :attr:`input` is added to the final result.

    If :attr:`mat` is a :math:`(n \times m)` tensor, :attr:`vec` is a 1-D tensor of
    size `m`, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a 1-D tensor of size `n` and
    :attr:`out` will be 1-D tensor of size `n`.

    :attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between
    :attr:`mat` and :attr:`vec` and the added tensor :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{mat} \mathbin{@} \text{vec})

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    Args:
        input (Tensor): vector to be added
        mat (Tensor): matrix to be matrix multiplied
        vec (Tensor): vector to be matrix multiplied

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`mat @ vec` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(2)
        >>> mat = torch.randn(2, 3)
        >>> vec = torch.randn(3)
        >>> torch.addmv(M, mat, vec)
        tensor([-0.3768, -5.5565])
    """

@overload
def addmv_(
    beta: Number | _complex,
    self: Tensor,
    alpha: Number | _complex,
    mat: Tensor,
    vec: Tensor,
) -> Tensor: ...
@overload
def addmv_(
    input: Tensor,
    mat: Tensor,
    vec: Tensor,
    *,
    beta: Number | _complex = 1,
    alpha: Number | _complex = 1,
) -> Tensor: ...
@overload
def addmv_(
    beta: Number | _complex,
    self: Tensor,
    mat: Tensor,
    vec: Tensor,
) -> Tensor: ...
@overload
def addr(
    beta: Number | _complex,
    self: Tensor,
    alpha: Number | _complex,
    vec1: Tensor,
    vec2: Tensor,
) -> Tensor:
    r"""
    addr(input, vec1, vec2, *, beta=1, alpha=1, out=None) -> Tensor

    Performs the outer-product of vectors :attr:`vec1` and :attr:`vec2`
    and adds it to the matrix :attr:`input`.

    Optional values :attr:`beta` and :attr:`alpha` are scaling factors on the
    outer product between :attr:`vec1` and :attr:`vec2` and the added matrix
    :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{vec1} \otimes \text{vec2})

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    If :attr:`vec1` is a vector of size `n` and :attr:`vec2` is a vector
    of size `m`, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a matrix of size
    :math:`(n \times m)` and :attr:`out` will be a matrix of size
    :math:`(n \times m)`.

    Args:
        input (Tensor): matrix to be added
        vec1 (Tensor): the first vector of the outer product
        vec2 (Tensor): the second vector of the outer product

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`\text{vec1} \otimes \text{vec2}` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> vec1 = torch.arange(1., 4.)
        >>> vec2 = torch.arange(1., 3.)
        >>> M = torch.zeros(3, 2)
        >>> torch.addr(M, vec1, vec2)
        tensor([[ 1.,  2.],
                [ 2.,  4.],
                [ 3.,  6.]])
    """

@overload
def addr(
    beta: Number | _complex,
    self: Tensor,
    alpha: Number | _complex,
    vec1: Tensor,
    vec2: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    addr(input, vec1, vec2, *, beta=1, alpha=1, out=None) -> Tensor

    Performs the outer-product of vectors :attr:`vec1` and :attr:`vec2`
    and adds it to the matrix :attr:`input`.

    Optional values :attr:`beta` and :attr:`alpha` are scaling factors on the
    outer product between :attr:`vec1` and :attr:`vec2` and the added matrix
    :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{vec1} \otimes \text{vec2})

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    If :attr:`vec1` is a vector of size `n` and :attr:`vec2` is a vector
    of size `m`, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a matrix of size
    :math:`(n \times m)` and :attr:`out` will be a matrix of size
    :math:`(n \times m)`.

    Args:
        input (Tensor): matrix to be added
        vec1 (Tensor): the first vector of the outer product
        vec2 (Tensor): the second vector of the outer product

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`\text{vec1} \otimes \text{vec2}` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> vec1 = torch.arange(1., 4.)
        >>> vec2 = torch.arange(1., 3.)
        >>> M = torch.zeros(3, 2)
        >>> torch.addr(M, vec1, vec2)
        tensor([[ 1.,  2.],
                [ 2.,  4.],
                [ 3.,  6.]])
    """

@overload
def addr(
    input: Tensor,
    vec1: Tensor,
    vec2: Tensor,
    *,
    beta: Number | _complex = 1,
    alpha: Number | _complex = 1,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    addr(input, vec1, vec2, *, beta=1, alpha=1, out=None) -> Tensor

    Performs the outer-product of vectors :attr:`vec1` and :attr:`vec2`
    and adds it to the matrix :attr:`input`.

    Optional values :attr:`beta` and :attr:`alpha` are scaling factors on the
    outer product between :attr:`vec1` and :attr:`vec2` and the added matrix
    :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{vec1} \otimes \text{vec2})

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    If :attr:`vec1` is a vector of size `n` and :attr:`vec2` is a vector
    of size `m`, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a matrix of size
    :math:`(n \times m)` and :attr:`out` will be a matrix of size
    :math:`(n \times m)`.

    Args:
        input (Tensor): matrix to be added
        vec1 (Tensor): the first vector of the outer product
        vec2 (Tensor): the second vector of the outer product

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`\text{vec1} \otimes \text{vec2}` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> vec1 = torch.arange(1., 4.)
        >>> vec2 = torch.arange(1., 3.)
        >>> M = torch.zeros(3, 2)
        >>> torch.addr(M, vec1, vec2)
        tensor([[ 1.,  2.],
                [ 2.,  4.],
                [ 3.,  6.]])
    """

@overload
def addr(
    beta: Number | _complex,
    self: Tensor,
    vec1: Tensor,
    vec2: Tensor,
) -> Tensor:
    r"""
    addr(input, vec1, vec2, *, beta=1, alpha=1, out=None) -> Tensor

    Performs the outer-product of vectors :attr:`vec1` and :attr:`vec2`
    and adds it to the matrix :attr:`input`.

    Optional values :attr:`beta` and :attr:`alpha` are scaling factors on the
    outer product between :attr:`vec1` and :attr:`vec2` and the added matrix
    :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{vec1} \otimes \text{vec2})

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    If :attr:`vec1` is a vector of size `n` and :attr:`vec2` is a vector
    of size `m`, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a matrix of size
    :math:`(n \times m)` and :attr:`out` will be a matrix of size
    :math:`(n \times m)`.

    Args:
        input (Tensor): matrix to be added
        vec1 (Tensor): the first vector of the outer product
        vec2 (Tensor): the second vector of the outer product

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`\text{vec1} \otimes \text{vec2}` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> vec1 = torch.arange(1., 4.)
        >>> vec2 = torch.arange(1., 3.)
        >>> M = torch.zeros(3, 2)
        >>> torch.addr(M, vec1, vec2)
        tensor([[ 1.,  2.],
                [ 2.,  4.],
                [ 3.,  6.]])
    """

@overload
def addr(
    beta: Number | _complex,
    self: Tensor,
    vec1: Tensor,
    vec2: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    addr(input, vec1, vec2, *, beta=1, alpha=1, out=None) -> Tensor

    Performs the outer-product of vectors :attr:`vec1` and :attr:`vec2`
    and adds it to the matrix :attr:`input`.

    Optional values :attr:`beta` and :attr:`alpha` are scaling factors on the
    outer product between :attr:`vec1` and :attr:`vec2` and the added matrix
    :attr:`input` respectively.

    .. math::
        \text{out} = \beta\ \text{input} + \alpha\ (\text{vec1} \otimes \text{vec2})

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    If :attr:`vec1` is a vector of size `n` and :attr:`vec2` is a vector
    of size `m`, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a matrix of size
    :math:`(n \times m)` and :attr:`out` will be a matrix of size
    :math:`(n \times m)`.

    Args:
        input (Tensor): matrix to be added
        vec1 (Tensor): the first vector of the outer product
        vec2 (Tensor): the second vector of the outer product

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`\text{vec1} \otimes \text{vec2}` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> vec1 = torch.arange(1., 4.)
        >>> vec2 = torch.arange(1., 3.)
        >>> M = torch.zeros(3, 2)
        >>> torch.addr(M, vec1, vec2)
        tensor([[ 1.,  2.],
                [ 2.,  4.],
                [ 3.,  6.]])
    """

def adjoint(input: Tensor) -> Tensor:
    r"""
    adjoint(input: Tensor) -> Tensor
    Returns a view of the tensor conjugated and with the last two dimensions transposed.

    ``x.adjoint()`` is equivalent to ``x.transpose(-2, -1).conj()`` for complex tensors and
    to ``x.transpose(-2, -1)`` for real tensors.

    Args:
        {input}

    Example::

        >>> x = torch.arange(4, dtype=torch.float)
        >>> A = torch.complex(x, x).reshape(2, 2)
        >>> A
        tensor([[0.+0.j, 1.+1.j],
                [2.+2.j, 3.+3.j]])
        >>> A.adjoint()
        tensor([[0.-0.j, 2.-2.j],
                [1.-1.j, 3.-3.j]])
        >>> (A.adjoint() == A.mH).all()
        tensor(True)
    """

def affine_grid_generator(
    theta: Tensor,
    size: Sequence[_int | SymInt],
    align_corners: _bool,
) -> Tensor: ...
def alias_copy(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    Performs the same operation as :func:`torch.alias`, but all output tensors
    are freshly created instead of aliasing the input.
    """

@overload
def all(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    all(input: Tensor, *, out=None) -> Tensor

    Tests if all elements in :attr:`input` evaluate to `True`.

    .. note:: This function matches the behaviour of NumPy in returning
              output of dtype `bool` for all supported dtypes except `uint8`.
              For `uint8` the dtype of output is `uint8` itself.

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.rand(1, 2).bool()
        >>> a
        tensor([[False, True]], dtype=torch.bool)
        >>> torch.all(a)
        tensor(False, dtype=torch.bool)
        >>> a = torch.arange(0, 3)
        >>> a
        tensor([0, 1, 2])
        >>> torch.all(a)
        tensor(False)

    .. function:: all(input, dim, keepdim=False, *, out=None) -> Tensor
       :noindex:

    For each row of :attr:`input` in the given dimension :attr:`dim`,
    returns `True` if all elements in the row evaluate to `True` and `False` otherwise.


    If :attr:`keepdim` is ``True``, the output tensor is of the same size
    as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
    Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
    output tensor having 1 (or ``len(dim)``) fewer dimension(s).


    Args:
        input (Tensor): the input tensor.

        dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
            If ``None``, all dimensions are reduced.


        keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.rand(4, 2).bool()
        >>> a
        tensor([[True, True],
                [True, False],
                [True, True],
                [True, True]], dtype=torch.bool)
        >>> torch.all(a, dim=1)
        tensor([ True, False,  True,  True], dtype=torch.bool)
        >>> torch.all(a, dim=0)
        tensor([ True, False], dtype=torch.bool)
    """

@overload
def all(
    input: Tensor,
    dim: _size | None = None,
    keepdim: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    all(input: Tensor, *, out=None) -> Tensor

    Tests if all elements in :attr:`input` evaluate to `True`.

    .. note:: This function matches the behaviour of NumPy in returning
              output of dtype `bool` for all supported dtypes except `uint8`.
              For `uint8` the dtype of output is `uint8` itself.

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.rand(1, 2).bool()
        >>> a
        tensor([[False, True]], dtype=torch.bool)
        >>> torch.all(a)
        tensor(False, dtype=torch.bool)
        >>> a = torch.arange(0, 3)
        >>> a
        tensor([0, 1, 2])
        >>> torch.all(a)
        tensor(False)

    .. function:: all(input, dim, keepdim=False, *, out=None) -> Tensor
       :noindex:

    For each row of :attr:`input` in the given dimension :attr:`dim`,
    returns `True` if all elements in the row evaluate to `True` and `False` otherwise.


    If :attr:`keepdim` is ``True``, the output tensor is of the same size
    as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
    Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
    output tensor having 1 (or ``len(dim)``) fewer dimension(s).


    Args:
        input (Tensor): the input tensor.

        dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
            If ``None``, all dimensions are reduced.


        keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.rand(4, 2).bool()
        >>> a
        tensor([[True, True],
                [True, False],
                [True, True],
                [True, True]], dtype=torch.bool)
        >>> torch.all(a, dim=1)
        tensor([ True, False,  True,  True], dtype=torch.bool)
        >>> torch.all(a, dim=0)
        tensor([ True, False], dtype=torch.bool)
    """

@overload
def all(
    input: Tensor,
    dim: _int,
    keepdim: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    all(input: Tensor, *, out=None) -> Tensor

    Tests if all elements in :attr:`input` evaluate to `True`.

    .. note:: This function matches the behaviour of NumPy in returning
              output of dtype `bool` for all supported dtypes except `uint8`.
              For `uint8` the dtype of output is `uint8` itself.

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.rand(1, 2).bool()
        >>> a
        tensor([[False, True]], dtype=torch.bool)
        >>> torch.all(a)
        tensor(False, dtype=torch.bool)
        >>> a = torch.arange(0, 3)
        >>> a
        tensor([0, 1, 2])
        >>> torch.all(a)
        tensor(False)

    .. function:: all(input, dim, keepdim=False, *, out=None) -> Tensor
       :noindex:

    For each row of :attr:`input` in the given dimension :attr:`dim`,
    returns `True` if all elements in the row evaluate to `True` and `False` otherwise.


    If :attr:`keepdim` is ``True``, the output tensor is of the same size
    as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
    Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
    output tensor having 1 (or ``len(dim)``) fewer dimension(s).


    Args:
        input (Tensor): the input tensor.

        dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
            If ``None``, all dimensions are reduced.


        keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.rand(4, 2).bool()
        >>> a
        tensor([[True, True],
                [True, False],
                [True, True],
                [True, True]], dtype=torch.bool)
        >>> torch.all(a, dim=1)
        tensor([ True, False,  True,  True], dtype=torch.bool)
        >>> torch.all(a, dim=0)
        tensor([ True, False], dtype=torch.bool)
    """

@overload
def all(
    input: Tensor,
    dim: str | EllipsisType | None,
    keepdim: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    all(input: Tensor, *, out=None) -> Tensor

    Tests if all elements in :attr:`input` evaluate to `True`.

    .. note:: This function matches the behaviour of NumPy in returning
              output of dtype `bool` for all supported dtypes except `uint8`.
              For `uint8` the dtype of output is `uint8` itself.

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.rand(1, 2).bool()
        >>> a
        tensor([[False, True]], dtype=torch.bool)
        >>> torch.all(a)
        tensor(False, dtype=torch.bool)
        >>> a = torch.arange(0, 3)
        >>> a
        tensor([0, 1, 2])
        >>> torch.all(a)
        tensor(False)

    .. function:: all(input, dim, keepdim=False, *, out=None) -> Tensor
       :noindex:

    For each row of :attr:`input` in the given dimension :attr:`dim`,
    returns `True` if all elements in the row evaluate to `True` and `False` otherwise.


    If :attr:`keepdim` is ``True``, the output tensor is of the same size
    as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
    Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
    output tensor having 1 (or ``len(dim)``) fewer dimension(s).


    Args:
        input (Tensor): the input tensor.

        dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
            If ``None``, all dimensions are reduced.


        keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.rand(4, 2).bool()
        >>> a
        tensor([[True, True],
                [True, False],
                [True, True],
                [True, True]], dtype=torch.bool)
        >>> torch.all(a, dim=1)
        tensor([ True, False,  True,  True], dtype=torch.bool)
        >>> torch.all(a, dim=0)
        tensor([ True, False], dtype=torch.bool)
    """

def allclose(
    input: Tensor,
    other: Tensor,
    rtol: _float = 1e-05,
    atol: _float = 1e-08,
    equal_nan: _bool = False,
) -> _bool:
    r"""
    allclose(input: Tensor, other: Tensor, rtol: float = 1e-05, atol: float = 1e-08, equal_nan: bool = False) -> bool

    This function checks if :attr:`input` and :attr:`other` satisfy the condition:

    .. math::
        \lvert \text{input}_i - \text{other}_i \rvert \leq \texttt{atol} + \texttt{rtol} \times \lvert \text{other}_i \rvert

    elementwise, for all elements of :attr:`input` and :attr:`other`. The behaviour of this function is analogous to
    `numpy.allclose <https://numpy.org/doc/stable/reference/generated/numpy.allclose.html>`_

    Args:
        input (Tensor): first tensor to compare
        other (Tensor): second tensor to compare
        atol (float, optional): absolute tolerance. Default: 1e-08
        rtol (float, optional): relative tolerance. Default: 1e-05
        equal_nan (bool, optional): if ``True``, then two ``NaN`` s will be considered equal. Default: ``False``

    Example::

        >>> torch.allclose(torch.tensor([10000., 1e-07]), torch.tensor([10000.1, 1e-08]))
        False
        >>> torch.allclose(torch.tensor([10000., 1e-08]), torch.tensor([10000.1, 1e-09]))
        True
        >>> torch.allclose(torch.tensor([1.0, float('nan')]), torch.tensor([1.0, float('nan')]))
        False
        >>> torch.allclose(torch.tensor([1.0, float('nan')]), torch.tensor([1.0, float('nan')]), equal_nan=True)
        True
    """

def alpha_dropout(input: Tensor, p: _float, train: _bool) -> Tensor: ...
def alpha_dropout_(input: Tensor, p: _float, train: _bool) -> Tensor: ...
def amax(
    input: Tensor,
    dim: _int | _size = (),
    keepdim: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    amax(input, dim, keepdim=False, *, out=None) -> Tensor

    Returns the maximum value of each slice of the :attr:`input` tensor in the given
    dimension(s) :attr:`dim`.

    .. note::
        The difference between ``max``/``min`` and ``amax``/``amin`` is:
            - ``amax``/``amin`` supports reducing on multiple dimensions,
            - ``amax``/``amin`` does not return indices.

        Both ``max``/``min`` and ``amax``/``amin`` evenly distribute gradients between equal values
        when there are multiple input elements with the same minimum or maximum value.


    If :attr:`keepdim` is ``True``, the output tensor is of the same size
    as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
    Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
    output tensor having 1 (or ``len(dim)``) fewer dimension(s).


    Args:
        input (Tensor): the input tensor.

        dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
            If ``None``, all dimensions are reduced.


        keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


    Keyword args:
      out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4, 4)
        >>> a
        tensor([[ 0.8177,  1.4878, -0.2491,  0.9130],
                [-0.7158,  1.1775,  2.0992,  0.4817],
                [-0.0053,  0.0164, -1.3738, -0.0507],
                [ 1.9700,  1.1106, -1.0318, -1.0816]])
        >>> torch.amax(a, 1)
        tensor([1.4878, 2.0992, 0.0164, 1.9700])
    """

def amin(
    input: Tensor,
    dim: _int | _size = (),
    keepdim: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    amin(input, dim, keepdim=False, *, out=None) -> Tensor

    Returns the minimum value of each slice of the :attr:`input` tensor in the given
    dimension(s) :attr:`dim`.

    .. note::
        The difference between ``max``/``min`` and ``amax``/``amin`` is:
            - ``amax``/``amin`` supports reducing on multiple dimensions,
            - ``amax``/``amin`` does not return indices.

        Both ``max``/``min`` and ``amax``/``amin`` evenly distribute gradients between equal values
        when there are multiple input elements with the same minimum or maximum value.


    If :attr:`keepdim` is ``True``, the output tensor is of the same size
    as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
    Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
    output tensor having 1 (or ``len(dim)``) fewer dimension(s).


    Args:
        input (Tensor): the input tensor.

        dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
            If ``None``, all dimensions are reduced.


        keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


    Keyword args:
      out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4, 4)
        >>> a
        tensor([[ 0.6451, -0.4866,  0.2987, -1.3312],
                [-0.5744,  1.2980,  1.8397, -0.2713],
                [ 0.9128,  0.9214, -1.7268, -0.2995],
                [ 0.9023,  0.4853,  0.9075, -1.6165]])
        >>> torch.amin(a, 1)
        tensor([-1.3312, -0.5744, -1.7268, -1.6165])
    """

def aminmax(
    input: Tensor,
    *,
    dim: _int | None = None,
    keepdim: _bool = False,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> torch.return_types.aminmax:
    r"""
    aminmax(input, *, dim=None, keepdim=False, out=None) -> (Tensor min, Tensor max)

    Computes the minimum and maximum values of the :attr:`input` tensor.

    Args:
        input (Tensor):
            The input tensor

    Keyword Args:
        dim (Optional[int]):
            The dimension along which to compute the values. If `None`,
            computes the values over the entire :attr:`input` tensor.
            Default is `None`.
        keepdim (bool):
            If `True`, the reduced dimensions will be kept in the output
            tensor as dimensions with size 1 for broadcasting, otherwise
            they will be removed, as if calling (:func:`torch.squeeze`).
            Default is `False`.
        out (Optional[Tuple[Tensor, Tensor]]):
            Optional tensors on which to write the result. Must have the same
            shape and dtype as the expected output.
            Default is `None`.

    Returns:
        A named tuple `(min, max)` containing the minimum and maximum values.

    Raises:
        RuntimeError
            If any of the dimensions to compute the values over has size 0.

    .. note::
        NaN values are propagated to the output if at least one value is NaN.

    .. seealso::
        :func:`torch.amin` computes just the minimum value
        :func:`torch.amax` computes just the maximum value

    Example::

        >>> torch.aminmax(torch.tensor([1, -3, 5]))
        torch.return_types.aminmax(
        min=tensor(-3),
        max=tensor(5))

        >>> # aminmax propagates NaNs
        >>> torch.aminmax(torch.tensor([1, -3, 5, torch.nan]))
        torch.return_types.aminmax(
        min=tensor(nan),
        max=tensor(nan))

        >>> t = torch.arange(10).view(2, 5)
        >>> t
        tensor([[0, 1, 2, 3, 4],
                [5, 6, 7, 8, 9]])
        >>> t.aminmax(dim=0, keepdim=True)
        torch.return_types.aminmax(
        min=tensor([[0, 1, 2, 3, 4]]),
        max=tensor([[5, 6, 7, 8, 9]]))
    """

def angle(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    angle(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Computes the element-wise angle (in radians) of the given :attr:`input` tensor.

    .. math::
        \text{out}_{i} = angle(\text{input}_{i})

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    .. note:: Starting in PyTorch 1.8, angle returns pi for negative real numbers,
              zero for non-negative real numbers, and propagates NaNs. Previously
              the function would return zero for all real numbers and not propagate
              floating-point NaNs.

    Example::

        >>> torch.angle(torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j]))*180/3.14159
        tensor([ 135.,  135,  -45])
    """

@overload
def any(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    any(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Tests if any element in :attr:`input` evaluates to `True`.

    .. note:: This function matches the behaviour of NumPy in returning
              output of dtype `bool` for all supported dtypes except `uint8`.
              For `uint8` the dtype of output is `uint8` itself.

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.rand(1, 2).bool()
        >>> a
        tensor([[False, True]], dtype=torch.bool)
        >>> torch.any(a)
        tensor(True, dtype=torch.bool)
        >>> a = torch.arange(0, 3)
        >>> a
        tensor([0, 1, 2])
        >>> torch.any(a)
        tensor(True)

    .. function:: any(input, dim, keepdim=False, *, out=None) -> Tensor
       :noindex:

    For each row of :attr:`input` in the given dimension :attr:`dim`,
    returns `True` if any element in the row evaluate to `True` and `False` otherwise.


    If :attr:`keepdim` is ``True``, the output tensor is of the same size
    as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
    Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
    output tensor having 1 (or ``len(dim)``) fewer dimension(s).


    Args:
        input (Tensor): the input tensor.

        dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
            If ``None``, all dimensions are reduced.


        keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4, 2) < 0
        >>> a
        tensor([[ True,  True],
                [False,  True],
                [ True,  True],
                [False, False]])
        >>> torch.any(a, 1)
        tensor([ True,  True,  True, False])
        >>> torch.any(a, 0)
        tensor([True, True])
    """

@overload
def any(
    input: Tensor,
    dim: _size | None = None,
    keepdim: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    any(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Tests if any element in :attr:`input` evaluates to `True`.

    .. note:: This function matches the behaviour of NumPy in returning
              output of dtype `bool` for all supported dtypes except `uint8`.
              For `uint8` the dtype of output is `uint8` itself.

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.rand(1, 2).bool()
        >>> a
        tensor([[False, True]], dtype=torch.bool)
        >>> torch.any(a)
        tensor(True, dtype=torch.bool)
        >>> a = torch.arange(0, 3)
        >>> a
        tensor([0, 1, 2])
        >>> torch.any(a)
        tensor(True)

    .. function:: any(input, dim, keepdim=False, *, out=None) -> Tensor
       :noindex:

    For each row of :attr:`input` in the given dimension :attr:`dim`,
    returns `True` if any element in the row evaluate to `True` and `False` otherwise.


    If :attr:`keepdim` is ``True``, the output tensor is of the same size
    as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
    Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
    output tensor having 1 (or ``len(dim)``) fewer dimension(s).


    Args:
        input (Tensor): the input tensor.

        dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
            If ``None``, all dimensions are reduced.


        keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4, 2) < 0
        >>> a
        tensor([[ True,  True],
                [False,  True],
                [ True,  True],
                [False, False]])
        >>> torch.any(a, 1)
        tensor([ True,  True,  True, False])
        >>> torch.any(a, 0)
        tensor([True, True])
    """

@overload
def any(
    input: Tensor,
    dim: _int,
    keepdim: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    any(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Tests if any element in :attr:`input` evaluates to `True`.

    .. note:: This function matches the behaviour of NumPy in returning
              output of dtype `bool` for all supported dtypes except `uint8`.
              For `uint8` the dtype of output is `uint8` itself.

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.rand(1, 2).bool()
        >>> a
        tensor([[False, True]], dtype=torch.bool)
        >>> torch.any(a)
        tensor(True, dtype=torch.bool)
        >>> a = torch.arange(0, 3)
        >>> a
        tensor([0, 1, 2])
        >>> torch.any(a)
        tensor(True)

    .. function:: any(input, dim, keepdim=False, *, out=None) -> Tensor
       :noindex:

    For each row of :attr:`input` in the given dimension :attr:`dim`,
    returns `True` if any element in the row evaluate to `True` and `False` otherwise.


    If :attr:`keepdim` is ``True``, the output tensor is of the same size
    as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
    Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
    output tensor having 1 (or ``len(dim)``) fewer dimension(s).


    Args:
        input (Tensor): the input tensor.

        dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
            If ``None``, all dimensions are reduced.


        keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4, 2) < 0
        >>> a
        tensor([[ True,  True],
                [False,  True],
                [ True,  True],
                [False, False]])
        >>> torch.any(a, 1)
        tensor([ True,  True,  True, False])
        >>> torch.any(a, 0)
        tensor([True, True])
    """

@overload
def any(
    input: Tensor,
    dim: str | EllipsisType | None,
    keepdim: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    any(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Tests if any element in :attr:`input` evaluates to `True`.

    .. note:: This function matches the behaviour of NumPy in returning
              output of dtype `bool` for all supported dtypes except `uint8`.
              For `uint8` the dtype of output is `uint8` itself.

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.rand(1, 2).bool()
        >>> a
        tensor([[False, True]], dtype=torch.bool)
        >>> torch.any(a)
        tensor(True, dtype=torch.bool)
        >>> a = torch.arange(0, 3)
        >>> a
        tensor([0, 1, 2])
        >>> torch.any(a)
        tensor(True)

    .. function:: any(input, dim, keepdim=False, *, out=None) -> Tensor
       :noindex:

    For each row of :attr:`input` in the given dimension :attr:`dim`,
    returns `True` if any element in the row evaluate to `True` and `False` otherwise.


    If :attr:`keepdim` is ``True``, the output tensor is of the same size
    as :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.
    Otherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the
    output tensor having 1 (or ``len(dim)``) fewer dimension(s).


    Args:
        input (Tensor): the input tensor.

        dim (int or tuple of ints, optional): the dimension or dimensions to reduce.
            If ``None``, all dimensions are reduced.


        keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4, 2) < 0
        >>> a
        tensor([[ True,  True],
                [False,  True],
                [ True,  True],
                [False, False]])
        >>> torch.any(a, 1)
        tensor([ True,  True,  True, False])
        >>> torch.any(a, 0)
        tensor([True, True])
    """

@overload
def arange(
    start: Number,
    end: Number,
    step: Number,
    *,
    out: Tensor | None = None,
    dtype: _dtype | None = None,
    device: DeviceLikeType | None = None,
    requires_grad: _bool = False,
    pin_memory: _bool = False,
) -> Tensor:
    r"""
    arange(start=0, end, step=1, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Returns a 1-D tensor of size :math:`\left\lceil \frac{\text{end} - \text{start}}{\text{step}} \right\rceil`
    with values from the interval ``[start, end)`` taken with common difference
    :attr:`step` beginning from `start`.

    Note: When using floating-point dtypes (especially reduced precision types like ``bfloat16``),
    the results may be affected by floating-point rounding behavior. Some values in the sequence
    might not be exactly representable in certain floating-point formats, which can lead to
    repeated values or unexpected rounding. For precise sequences, it is recommended to use
    integer dtypes instead of floating-point dtypes.

    Note that non-integer :attr:`step` is subject to floating point rounding errors when
    comparing against :attr:`end`; to avoid inconsistency, we advise subtracting a small epsilon from :attr:`end`
    in such cases.

    .. math::
        \text{out}_{{i+1}} = \text{out}_{i} + \text{step}

    Args:
        start (Number, optional): the starting value for the set of points. Default: ``0``.
        end (Number): the ending value for the set of points
        step (Number, optional): the gap between each pair of adjacent points. Default: ``1``.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). If `dtype` is not given, infer the data type from the other input
            arguments. If any of `start`, `end`, or `stop` are floating-point, the
            `dtype` is inferred to be the default dtype, see
            :meth:`~torch.get_default_dtype`. Otherwise, the `dtype` is inferred to
            be `torch.int64`.
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Example::

        >>> torch.arange(5)
        tensor([ 0,  1,  2,  3,  4])
        >>> torch.arange(1, 4)
        tensor([ 1,  2,  3])
        >>> torch.arange(1, 2.5, 0.5)
        tensor([ 1.0000,  1.5000,  2.0000])
    """

@overload
def arange(
    start: Number,
    end: Number,
    *,
    out: Tensor | None = None,
    dtype: _dtype | None = None,
    device: DeviceLikeType | None = None,
    requires_grad: _bool = False,
    pin_memory: _bool = False,
) -> Tensor:
    r"""
    arange(start=0, end, step=1, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Returns a 1-D tensor of size :math:`\left\lceil \frac{\text{end} - \text{start}}{\text{step}} \right\rceil`
    with values from the interval ``[start, end)`` taken with common difference
    :attr:`step` beginning from `start`.

    Note: When using floating-point dtypes (especially reduced precision types like ``bfloat16``),
    the results may be affected by floating-point rounding behavior. Some values in the sequence
    might not be exactly representable in certain floating-point formats, which can lead to
    repeated values or unexpected rounding. For precise sequences, it is recommended to use
    integer dtypes instead of floating-point dtypes.

    Note that non-integer :attr:`step` is subject to floating point rounding errors when
    comparing against :attr:`end`; to avoid inconsistency, we advise subtracting a small epsilon from :attr:`end`
    in such cases.

    .. math::
        \text{out}_{{i+1}} = \text{out}_{i} + \text{step}

    Args:
        start (Number, optional): the starting value for the set of points. Default: ``0``.
        end (Number): the ending value for the set of points
        step (Number, optional): the gap between each pair of adjacent points. Default: ``1``.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). If `dtype` is not given, infer the data type from the other input
            arguments. If any of `start`, `end`, or `stop` are floating-point, the
            `dtype` is inferred to be the default dtype, see
            :meth:`~torch.get_default_dtype`. Otherwise, the `dtype` is inferred to
            be `torch.int64`.
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Example::

        >>> torch.arange(5)
        tensor([ 0,  1,  2,  3,  4])
        >>> torch.arange(1, 4)
        tensor([ 1,  2,  3])
        >>> torch.arange(1, 2.5, 0.5)
        tensor([ 1.0000,  1.5000,  2.0000])
    """

@overload
def arange(
    end: Number,
    *,
    out: Tensor | None = None,
    dtype: _dtype | None = None,
    device: DeviceLikeType | None = None,
    requires_grad: _bool = False,
    pin_memory: _bool = False,
) -> Tensor:
    r"""
    arange(start=0, end, step=1, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Returns a 1-D tensor of size :math:`\left\lceil \frac{\text{end} - \text{start}}{\text{step}} \right\rceil`
    with values from the interval ``[start, end)`` taken with common difference
    :attr:`step` beginning from `start`.

    Note: When using floating-point dtypes (especially reduced precision types like ``bfloat16``),
    the results may be affected by floating-point rounding behavior. Some values in the sequence
    might not be exactly representable in certain floating-point formats, which can lead to
    repeated values or unexpected rounding. For precise sequences, it is recommended to use
    integer dtypes instead of floating-point dtypes.

    Note that non-integer :attr:`step` is subject to floating point rounding errors when
    comparing against :attr:`end`; to avoid inconsistency, we advise subtracting a small epsilon from :attr:`end`
    in such cases.

    .. math::
        \text{out}_{{i+1}} = \text{out}_{i} + \text{step}

    Args:
        start (Number, optional): the starting value for the set of points. Default: ``0``.
        end (Number): the ending value for the set of points
        step (Number, optional): the gap between each pair of adjacent points. Default: ``1``.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). If `dtype` is not given, infer the data type from the other input
            arguments. If any of `start`, `end`, or `stop` are floating-point, the
            `dtype` is inferred to be the default dtype, see
            :meth:`~torch.get_default_dtype`. Otherwise, the `dtype` is inferred to
            be `torch.int64`.
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Example::

        >>> torch.arange(5)
        tensor([ 0,  1,  2,  3,  4])
        >>> torch.arange(1, 4)
        tensor([ 1,  2,  3])
        >>> torch.arange(1, 2.5, 0.5)
        tensor([ 1.0000,  1.5000,  2.0000])
    """

@overload
def arange(
    end: Number | _complex,
    *,
    out: Tensor | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    arange(start=0, end, step=1, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Returns a 1-D tensor of size :math:`\left\lceil \frac{\text{end} - \text{start}}{\text{step}} \right\rceil`
    with values from the interval ``[start, end)`` taken with common difference
    :attr:`step` beginning from `start`.

    Note: When using floating-point dtypes (especially reduced precision types like ``bfloat16``),
    the results may be affected by floating-point rounding behavior. Some values in the sequence
    might not be exactly representable in certain floating-point formats, which can lead to
    repeated values or unexpected rounding. For precise sequences, it is recommended to use
    integer dtypes instead of floating-point dtypes.

    Note that non-integer :attr:`step` is subject to floating point rounding errors when
    comparing against :attr:`end`; to avoid inconsistency, we advise subtracting a small epsilon from :attr:`end`
    in such cases.

    .. math::
        \text{out}_{{i+1}} = \text{out}_{i} + \text{step}

    Args:
        start (Number, optional): the starting value for the set of points. Default: ``0``.
        end (Number): the ending value for the set of points
        step (Number, optional): the gap between each pair of adjacent points. Default: ``1``.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). If `dtype` is not given, infer the data type from the other input
            arguments. If any of `start`, `end`, or `stop` are floating-point, the
            `dtype` is inferred to be the default dtype, see
            :meth:`~torch.get_default_dtype`. Otherwise, the `dtype` is inferred to
            be `torch.int64`.
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Example::

        >>> torch.arange(5)
        tensor([ 0,  1,  2,  3,  4])
        >>> torch.arange(1, 4)
        tensor([ 1,  2,  3])
        >>> torch.arange(1, 2.5, 0.5)
        tensor([ 1.0000,  1.5000,  2.0000])
    """

@overload
def arange(
    start: Number | _complex,
    end: Number | _complex,
    *,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    arange(start=0, end, step=1, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Returns a 1-D tensor of size :math:`\left\lceil \frac{\text{end} - \text{start}}{\text{step}} \right\rceil`
    with values from the interval ``[start, end)`` taken with common difference
    :attr:`step` beginning from `start`.

    Note: When using floating-point dtypes (especially reduced precision types like ``bfloat16``),
    the results may be affected by floating-point rounding behavior. Some values in the sequence
    might not be exactly representable in certain floating-point formats, which can lead to
    repeated values or unexpected rounding. For precise sequences, it is recommended to use
    integer dtypes instead of floating-point dtypes.

    Note that non-integer :attr:`step` is subject to floating point rounding errors when
    comparing against :attr:`end`; to avoid inconsistency, we advise subtracting a small epsilon from :attr:`end`
    in such cases.

    .. math::
        \text{out}_{{i+1}} = \text{out}_{i} + \text{step}

    Args:
        start (Number, optional): the starting value for the set of points. Default: ``0``.
        end (Number): the ending value for the set of points
        step (Number, optional): the gap between each pair of adjacent points. Default: ``1``.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). If `dtype` is not given, infer the data type from the other input
            arguments. If any of `start`, `end`, or `stop` are floating-point, the
            `dtype` is inferred to be the default dtype, see
            :meth:`~torch.get_default_dtype`. Otherwise, the `dtype` is inferred to
            be `torch.int64`.
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Example::

        >>> torch.arange(5)
        tensor([ 0,  1,  2,  3,  4])
        >>> torch.arange(1, 4)
        tensor([ 1,  2,  3])
        >>> torch.arange(1, 2.5, 0.5)
        tensor([ 1.0000,  1.5000,  2.0000])
    """

@overload
def arange(
    start: Number | _complex,
    end: Number | _complex,
    step: Number | _complex = 1,
    *,
    out: Tensor | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    arange(start=0, end, step=1, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Returns a 1-D tensor of size :math:`\left\lceil \frac{\text{end} - \text{start}}{\text{step}} \right\rceil`
    with values from the interval ``[start, end)`` taken with common difference
    :attr:`step` beginning from `start`.

    Note: When using floating-point dtypes (especially reduced precision types like ``bfloat16``),
    the results may be affected by floating-point rounding behavior. Some values in the sequence
    might not be exactly representable in certain floating-point formats, which can lead to
    repeated values or unexpected rounding. For precise sequences, it is recommended to use
    integer dtypes instead of floating-point dtypes.

    Note that non-integer :attr:`step` is subject to floating point rounding errors when
    comparing against :attr:`end`; to avoid inconsistency, we advise subtracting a small epsilon from :attr:`end`
    in such cases.

    .. math::
        \text{out}_{{i+1}} = \text{out}_{i} + \text{step}

    Args:
        start (Number, optional): the starting value for the set of points. Default: ``0``.
        end (Number): the ending value for the set of points
        step (Number, optional): the gap between each pair of adjacent points. Default: ``1``.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). If `dtype` is not given, infer the data type from the other input
            arguments. If any of `start`, `end`, or `stop` are floating-point, the
            `dtype` is inferred to be the default dtype, see
            :meth:`~torch.get_default_dtype`. Otherwise, the `dtype` is inferred to
            be `torch.int64`.
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Example::

        >>> torch.arange(5)
        tensor([ 0,  1,  2,  3,  4])
        >>> torch.arange(1, 4)
        tensor([ 1,  2,  3])
        >>> torch.arange(1, 2.5, 0.5)
        tensor([ 1.0000,  1.5000,  2.0000])
    """

def arccos(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    arccos(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Alias for :func:`torch.acos`.
    """

def arccos_(input: Tensor) -> Tensor: ...
def arccosh(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    arccosh(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Alias for :func:`torch.acosh`.
    """

def arccosh_(input: Tensor) -> Tensor: ...
def arcsin(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    arcsin(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Alias for :func:`torch.asin`.
    """

def arcsin_(input: Tensor) -> Tensor: ...
def arcsinh(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    arcsinh(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Alias for :func:`torch.asinh`.
    """

def arcsinh_(input: Tensor) -> Tensor: ...
def arctan(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    arctan(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Alias for :func:`torch.atan`.
    """

def arctan2(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    arctan2(input: Tensor, other: Tensor, *, out: Optional[Tensor]) -> Tensor
    Alias for :func:`torch.atan2`.
    """

def arctan_(input: Tensor) -> Tensor: ...
def arctanh(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    arctanh(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Alias for :func:`torch.atanh`.
    """

def arctanh_(input: Tensor) -> Tensor: ...
def argmax(
    input: Tensor,
    dim: _int | None = None,
    keepdim: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    argmax(input) -> LongTensor

    Returns the indices of the maximum value of all elements in the :attr:`input` tensor.

    This is the second value returned by :meth:`torch.max`. See its
    documentation for the exact semantics of this method.

    .. note:: If there are multiple maximal values then the indices of the first maximal value are returned.

    Args:
        input (Tensor): the input tensor.

    Example::

        >>> a = torch.randn(4, 4)
        >>> a
        tensor([[ 1.3398,  0.2663, -0.2686,  0.2450],
                [-0.7401, -0.8805, -0.3402, -1.1936],
                [ 0.4907, -1.3948, -1.0691, -0.3132],
                [-1.6092,  0.5419, -0.2993,  0.3195]])
        >>> torch.argmax(a)
        tensor(0)

    .. function:: argmax(input, dim, keepdim=False) -> LongTensor
       :noindex:

    Returns the indices of the maximum values of a tensor across a dimension.

    This is the second value returned by :meth:`torch.max`. See its
    documentation for the exact semantics of this method.

    Args:
        input (Tensor): the input tensor.

        dim (int, optional): the dimension to reduce.
     If ``None``, the argmax of the flattened input is returned.

        keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


    Example::

        >>> a = torch.randn(4, 4)
        >>> a
        tensor([[ 1.3398,  0.2663, -0.2686,  0.2450],
                [-0.7401, -0.8805, -0.3402, -1.1936],
                [ 0.4907, -1.3948, -1.0691, -0.3132],
                [-1.6092,  0.5419, -0.2993,  0.3195]])
        >>> torch.argmax(a, dim=1)
        tensor([ 0,  2,  0,  1])
    """

def argmin(
    input: Tensor,
    dim: _int | None = None,
    keepdim: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    argmin(input, dim=None, keepdim=False) -> LongTensor

    Returns the indices of the minimum value(s) of the flattened tensor or along a dimension

    This is the second value returned by :meth:`torch.min`. See its
    documentation for the exact semantics of this method.

    .. note:: If there are multiple minimal values then the indices of the first minimal value are returned.

    Args:
        input (Tensor): the input tensor.

        dim (int, optional): the dimension to reduce.
     If ``None``, the argmin of the flattened input is returned.

        keepdim (bool, optional): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.


    Example::

        >>> a = torch.randn(4, 4)
        >>> a
        tensor([[ 0.1139,  0.2254, -0.1381,  0.3687],
                [ 1.0100, -1.1975, -0.0102, -0.4732],
                [-0.9240,  0.1207, -0.7506, -1.0213],
                [ 1.7809, -1.2960,  0.9384,  0.1438]])
        >>> torch.argmin(a)
        tensor(13)
        >>> torch.argmin(a, dim=1)
        tensor([ 2,  1,  3,  1])
        >>> torch.argmin(a, dim=1, keepdim=True)
        tensor([[2],
                [1],
                [3],
                [1]])
    """

@overload
def argsort(
    input: Tensor,
    *,
    stable: _bool,
    dim: _int = -1,
    descending: _bool = False,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    argsort(input, dim=-1, descending=False, stable=False) -> Tensor

    Returns the indices that sort a tensor along a given dimension in ascending
    order by value.

    This is the second value returned by :meth:`torch.sort`.  See its documentation
    for the exact semantics of this method.

    If :attr:`stable` is ``True`` then the sorting routine becomes stable, preserving
    the order of equivalent elements. If ``False``, the relative order of values
    which compare equal is not guaranteed. ``True`` is slower.

    Args:
        input (Tensor): the input tensor.
        dim (int, optional): the dimension to sort along
        descending (bool, optional): controls the sorting order (ascending or descending)
        stable (bool, optional): controls the relative order of equivalent elements

    Example::

        >>> a = torch.randn(4, 4)
        >>> a
        tensor([[ 0.0785,  1.5267, -0.8521,  0.4065],
                [ 0.1598,  0.0788, -0.0745, -1.2700],
                [ 1.2208,  1.0722, -0.7064,  1.2564],
                [ 0.0669, -0.2318, -0.8229, -0.9280]])


        >>> torch.argsort(a, dim=1)
        tensor([[2, 0, 3, 1],
                [3, 2, 1, 0],
                [2, 1, 0, 3],
                [3, 2, 1, 0]])
    """

@overload
def argsort(
    input: Tensor,
    dim: _int = -1,
    descending: _bool = False,
) -> Tensor:
    r"""
    argsort(input, dim=-1, descending=False, stable=False) -> Tensor

    Returns the indices that sort a tensor along a given dimension in ascending
    order by value.

    This is the second value returned by :meth:`torch.sort`.  See its documentation
    for the exact semantics of this method.

    If :attr:`stable` is ``True`` then the sorting routine becomes stable, preserving
    the order of equivalent elements. If ``False``, the relative order of values
    which compare equal is not guaranteed. ``True`` is slower.

    Args:
        input (Tensor): the input tensor.
        dim (int, optional): the dimension to sort along
        descending (bool, optional): controls the sorting order (ascending or descending)
        stable (bool, optional): controls the relative order of equivalent elements

    Example::

        >>> a = torch.randn(4, 4)
        >>> a
        tensor([[ 0.0785,  1.5267, -0.8521,  0.4065],
                [ 0.1598,  0.0788, -0.0745, -1.2700],
                [ 1.2208,  1.0722, -0.7064,  1.2564],
                [ 0.0669, -0.2318, -0.8229, -0.9280]])


        >>> torch.argsort(a, dim=1)
        tensor([[2, 0, 3, 1],
                [3, 2, 1, 0],
                [2, 1, 0, 3],
                [3, 2, 1, 0]])
    """

@overload
def argsort(
    input: Tensor,
    dim: str | EllipsisType | None,
    descending: _bool = False,
) -> Tensor:
    r"""
    argsort(input, dim=-1, descending=False, stable=False) -> Tensor

    Returns the indices that sort a tensor along a given dimension in ascending
    order by value.

    This is the second value returned by :meth:`torch.sort`.  See its documentation
    for the exact semantics of this method.

    If :attr:`stable` is ``True`` then the sorting routine becomes stable, preserving
    the order of equivalent elements. If ``False``, the relative order of values
    which compare equal is not guaranteed. ``True`` is slower.

    Args:
        input (Tensor): the input tensor.
        dim (int, optional): the dimension to sort along
        descending (bool, optional): controls the sorting order (ascending or descending)
        stable (bool, optional): controls the relative order of equivalent elements

    Example::

        >>> a = torch.randn(4, 4)
        >>> a
        tensor([[ 0.0785,  1.5267, -0.8521,  0.4065],
                [ 0.1598,  0.0788, -0.0745, -1.2700],
                [ 1.2208,  1.0722, -0.7064,  1.2564],
                [ 0.0669, -0.2318, -0.8229, -0.9280]])


        >>> torch.argsort(a, dim=1)
        tensor([[2, 0, 3, 1],
                [3, 2, 1, 0],
                [2, 1, 0, 3],
                [3, 2, 1, 0]])
    """

def argwhere(input: Tensor) -> Tensor:
    r"""
    argwhere(input) -> Tensor

    Returns a tensor containing the indices of all non-zero elements of
    :attr:`input`.  Each row in the result contains the indices of a non-zero
    element in :attr:`input`. The result is sorted lexicographically, with
    the last index changing the fastest (C-style).

    If :attr:`input` has :math:`n` dimensions, then the resulting indices tensor
    :attr:`out` is of size :math:`(z \times n)`, where :math:`z` is the total number of
    non-zero elements in the :attr:`input` tensor.

    .. note::
        This function is similar to NumPy's `argwhere`.

        When :attr:`input` is on CUDA, this function causes host-device synchronization.

    Args:
        {input}

    Example::

        >>> t = torch.tensor([1, 0, 1])
        >>> torch.argwhere(t)
        tensor([[0],
                [2]])
        >>> t = torch.tensor([[1, 0, 1], [0, 1, 1]])
        >>> torch.argwhere(t)
        tensor([[0, 0],
                [0, 2],
                [1, 1],
                [1, 2]])
    """

def as_strided(
    input: Tensor,
    size: Sequence[_int | SymInt],
    stride: Sequence[_int | SymInt],
    storage_offset: _int | SymInt | None = None,
) -> Tensor:
    r"""
    as_strided(input, size, stride, storage_offset=None) -> Tensor

    Create a view of an existing `torch.Tensor` :attr:`input` with specified
    :attr:`size`, :attr:`stride` and :attr:`storage_offset`.

    .. warning::
        Prefer using other view functions, like :meth:`torch.Tensor.view` or
        :meth:`torch.Tensor.expand`, to setting a view's strides manually with
        `as_strided`, as this function will throw an error on non-standard Pytorch
        backends (that do not have a concept of stride) and the result will depend
        on the current layout in memory. The constructed view must only refer to
        elements within the Tensor's storage or a runtime error will be thrown.
        If the generated view is "overlapped" (with multiple indices referring to
        the same element in memory), the behavior of inplace operations on this view
        is undefined (and might not throw runtime errors).

    Args:
        input (Tensor): the input tensor.
        size (tuple or ints): the shape of the output tensor
        stride (tuple or ints): the stride of the output tensor
        storage_offset (int, optional): the offset in the underlying storage of the output tensor.
            If ``None``, the storage_offset of the output tensor will match the input tensor.

    Example::

        >>> x = torch.randn(3, 3)
        >>> x
        tensor([[ 0.9039,  0.6291,  1.0795],
                [ 0.1586,  2.1939, -0.4900],
                [-0.1909, -0.7503,  1.9355]])
        >>> t = torch.as_strided(x, (2, 2), (1, 2))
        >>> t
        tensor([[0.9039, 1.0795],
                [0.6291, 0.1586]])
        >>> t = torch.as_strided(x, (2, 2), (1, 2), 1)
        tensor([[0.6291, 0.1586],
                [1.0795, 2.1939]])
    """

def as_strided_(
    input: Tensor,
    size: Sequence[_int | SymInt],
    stride: Sequence[_int | SymInt],
    storage_offset: _int | SymInt | None = None,
) -> Tensor: ...
def as_strided_copy(
    input: Tensor,
    size: Sequence[_int | SymInt],
    stride: Sequence[_int | SymInt],
    storage_offset: _int | SymInt | None = None,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    Performs the same operation as :func:`torch.as_strided`, but all output tensors
    are freshly created instead of aliasing the input.
    """

def as_strided_scatter(
    input: Tensor,
    src: Tensor,
    size: Sequence[_int | SymInt],
    stride: Sequence[_int | SymInt],
    storage_offset: _int | SymInt | None = None,
) -> Tensor:
    r"""
    as_strided_scatter(input, src, size, stride, storage_offset=None) -> Tensor

    Embeds the values of the :attr:`src` tensor into :attr:`input` along
    the elements corresponding to the result of calling
    input.as_strided(size, stride, storage_offset).

    This function returns a tensor with fresh storage; it does not
    return a view.

    Args:
        input (Tensor): the input tensor.
        size (tuple or ints): the shape of the output tensor
        stride (tuple or ints): the stride of the output tensor
        storage_offset (int, optional): the offset in the underlying storage of the output tensor

    .. note::

        :attr:`src` must be of the proper size in order to be embedded
        into :attr:`input`. Specifically, it should have the same shape as
        `torch.as_strided(input, size, stride, storage_offset)`

    Example::

        >>> a = torch.arange(4).reshape(2, 2) + 1
        >>> a
        tensor([[1, 2],
                [3, 4]])
        >>> b = torch.zeros(3, 3)
        >>> b
        tensor([[0., 0., 0.],
                [0., 0., 0.],
                [0., 0., 0.]])
        >>> torch.as_strided_scatter(b, a, (2, 2), (1, 2))
        tensor([[1., 3., 2.],
                [4., 0., 0.],
                [0., 0., 0.]])
    """

def as_tensor(
    data: Any,
    dtype: _dtype | None = None,
    device: DeviceLikeType | None = None,
) -> Tensor:
    r"""
    as_tensor(data: Any, dtype: Optional[dtype] = None, device: Optional[DeviceLikeType]) -> Tensor

    Converts :attr:`data` into a tensor, sharing data and preserving autograd
    history if possible.

    If :attr:`data` is already a tensor with the requested dtype and device
    then :attr:`data` itself is returned, but if :attr:`data` is a
    tensor with a different dtype or device then it's copied as if using
    `data.to(dtype=dtype, device=device)`.

    If :attr:`data` is a NumPy array (an ndarray) with the same dtype and device then a
    tensor is constructed using :func:`torch.from_numpy`.

    If :attr:`data` is a CuPy array, the returned tensor will be located on the same device as the CuPy array unless
    specifically overwritten by :attr:`device` or a default device.

    .. seealso::

        :func:`torch.tensor` never shares its data and creates a new "leaf tensor" (see :doc:`/notes/autograd`).


    Args:
        data (array_like): Initial data for the tensor. Can be a list, tuple,
            NumPy ``ndarray``, scalar, and other types.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, infers data type from :attr:`data`.
        device (:class:`torch.device`, optional): the device of the constructed tensor. If None and data is a tensor
            then the device of data is used. If None and data is not a tensor then
            the result tensor is constructed on the current device.


    Example::

        >>> a = numpy.array([1, 2, 3])
        >>> t = torch.as_tensor(a)
        >>> t
        tensor([ 1,  2,  3])
        >>> t[0] = -1
        >>> a
        array([-1,  2,  3])

        >>> a = numpy.array([1, 2, 3])
        >>> t = torch.as_tensor(a, device=torch.device('cuda'))
        >>> t
        tensor([ 1,  2,  3])
        >>> t[0] = -1
        >>> a
        array([1,  2,  3])
    """

def asarray(
    obj: Any,
    *,
    dtype: _dtype | None = None,
    device: DeviceLikeType | None = None,
    copy: _bool | None = None,
    requires_grad: _bool = False,
) -> Tensor:
    r"""
    asarray(obj: Any, *, dtype: Optional[dtype], device: Optional[DeviceLikeType], copy: Optional[bool] = None, requires_grad: bool = False) -> Tensor # noqa: B950

    Converts :attr:`obj` to a tensor.

    :attr:`obj` can be one of:

    1. a tensor
    2. a NumPy array or a NumPy scalar
    3. a DLPack capsule
    4. an object that implements Python's buffer protocol
    5. a scalar
    6. a sequence of scalars

    When :attr:`obj` is a tensor, NumPy array, or DLPack capsule the returned tensor will,
    by default, not require a gradient, have the same datatype as :attr:`obj`, be on the
    same device, and share memory with it. These properties can be controlled with the
    :attr:`dtype`, :attr:`device`, :attr:`copy`, and :attr:`requires_grad` keyword arguments.
    If the returned tensor is of a different datatype, on a different device, or a copy is
    requested then it will not share its memory with :attr:`obj`. If :attr:`requires_grad`
    is ``True`` then the returned tensor will require a gradient, and if :attr:`obj` is
    also a tensor with an autograd history then the returned tensor will have the same history.

    When :attr:`obj` is not a tensor, NumPy array, or DLPack capsule but implements Python's
    buffer protocol then the buffer is interpreted as an array of bytes grouped according to
    the size of the datatype passed to the :attr:`dtype` keyword argument. (If no datatype is
    passed then the default floating point datatype is used, instead.) The returned tensor
    will have the specified datatype (or default floating point datatype if none is specified)
    and, by default, be on the CPU device and share memory with the buffer.

    When :attr:`obj` is a NumPy scalar, the returned tensor will be a 0-dimensional tensor on
    the CPU and that doesn't share its memory (i.e. ``copy=True``). By default datatype will
    be the PyTorch datatype corresponding to the NumPy's scalar's datatype.

    When :attr:`obj` is none of the above but a scalar, or a sequence of scalars then the
    returned tensor will, by default, infer its datatype from the scalar values, be on the
    current default device, and not share its memory.

    .. seealso::

        :func:`torch.tensor` creates a tensor that always copies the data from the input object.
        :func:`torch.from_numpy` creates a tensor that always shares memory from NumPy arrays.
        :func:`torch.frombuffer` creates a tensor that always shares memory from objects that
        implement the buffer protocol.
        :func:`torch.from_dlpack` creates a tensor that always shares memory from
        DLPack capsules.

    Args:
        obj (object): a tensor, NumPy array, DLPack Capsule, object that implements Python's
               buffer protocol, scalar, or sequence of scalars.

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the datatype of the returned tensor.
               Default: ``None``, which causes the datatype of the returned tensor to be
               inferred from :attr:`obj`.
        copy (bool, optional): controls whether the returned tensor shares memory with :attr:`obj`.
               Default: ``None``, which causes the returned tensor to share memory with :attr:`obj`
               whenever possible. If ``True`` then the returned tensor does not share its memory.
               If ``False`` then the returned tensor shares its memory with :attr:`obj` and an
               error is thrown if it cannot.
        device (:class:`torch.device`, optional): the device of the returned tensor.
               Default: ``None``, which causes the device of :attr:`obj` to be used. Or, if
               :attr:`obj` is a Python sequence, the current default device will be used.
        requires_grad (bool, optional): whether the returned tensor requires grad.
               Default: ``False``, which causes the returned tensor not to require a gradient.
               If ``True``, then the returned tensor will require a gradient, and if :attr:`obj`
               is also a tensor with an autograd history then the returned tensor will have
               the same history.

    Example::

        >>> a = torch.tensor([1, 2, 3])
        >>> # Shares memory with tensor 'a'
        >>> b = torch.asarray(a)
        >>> a.data_ptr() == b.data_ptr()
        True
        >>> # Forces memory copy
        >>> c = torch.asarray(a, copy=True)
        >>> a.data_ptr() == c.data_ptr()
        False

        >>> a = torch.tensor([1., 2., 3.], requires_grad=True)
        >>> b = a + 2
        >>> b
        tensor([3., 4., 5.], grad_fn=<AddBackward0>)
        >>> # Shares memory with tensor 'b', with no grad
        >>> c = torch.asarray(b)
        >>> c
        tensor([3., 4., 5.])
        >>> # Shares memory with tensor 'b', retaining autograd history
        >>> d = torch.asarray(b, requires_grad=True)
        >>> d
        tensor([3., 4., 5.], grad_fn=<AddBackward0>)

        >>> array = numpy.array([1, 2, 3])
        >>> # Shares memory with array 'array'
        >>> t1 = torch.asarray(array)
        >>> array.__array_interface__['data'][0] == t1.data_ptr()
        True
        >>> # Copies memory due to dtype mismatch
        >>> t2 = torch.asarray(array, dtype=torch.float32)
        >>> array.__array_interface__['data'][0] == t2.data_ptr()
        False

        >>> scalar = numpy.float64(0.5)
        >>> torch.asarray(scalar)
        tensor(0.5000, dtype=torch.float64)
    """

def asin(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    asin(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Returns a new tensor with the arcsine of the elements of :attr:`input`.

    .. math::
        \text{out}_{i} = \sin^{-1}(\text{input}_{i})

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4)
        >>> a
        tensor([-0.5962,  1.4985, -0.4396,  1.4525])
        >>> torch.asin(a)
        tensor([-0.6387,     nan, -0.4552,     nan])
    """

def asin_(input: Tensor) -> Tensor: ...
def asinh(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    asinh(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Returns a new tensor with the inverse hyperbolic sine of the elements of :attr:`input`.

    .. math::
        \text{out}_{i} = \sinh^{-1}(\text{input}_{i})

    Args:
        input (Tensor): the input tensor.

    Keyword arguments:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4)
        >>> a
        tensor([ 0.1606, -1.4267, -1.0899, -1.0250 ])
        >>> torch.asinh(a)
        tensor([ 0.1599, -1.1534, -0.9435, -0.8990 ])
    """

def asinh_(input: Tensor) -> Tensor: ...
def atan(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    atan(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Returns a new tensor with the arctangent of the elements of :attr:`input`.

    .. math::
        \text{out}_{i} = \tan^{-1}(\text{input}_{i})

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4)
        >>> a
        tensor([ 0.2341,  0.2539, -0.6256, -0.6448])
        >>> torch.atan(a)
        tensor([ 0.2299,  0.2487, -0.5591, -0.5727])
    """

def atan2(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    atan2(input: Tensor, other: Tensor, *, out: Optional[Tensor]) -> Tensor

    Element-wise arctangent of :math:`\text{input}_{i} / \text{other}_{i}`
    with consideration of the quadrant. Returns a new tensor with the signed angles
    in radians between vector :math:`(\text{other}_{i}, \text{input}_{i})`
    and vector :math:`(1, 0)`. (Note that :math:`\text{other}_{i}`, the second
    parameter, is the x-coordinate, while :math:`\text{input}_{i}`, the first
    parameter, is the y-coordinate.)

    The shapes of ``input`` and ``other`` must be
    :ref:`broadcastable <broadcasting-semantics>`.

    Args:
        input (Tensor): the first input tensor
        other (Tensor): the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4)
        >>> a
        tensor([ 0.9041,  0.0196, -0.3108, -2.4423])
        >>> torch.atan2(a, torch.randn(4))
        tensor([ 0.9833,  0.0811, -1.9743, -1.4151])
    """

def atan_(input: Tensor) -> Tensor: ...
def atanh(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    atanh(input: Tensor, *, out: Optional[Tensor]) -> Tensor

    Returns a new tensor with the inverse hyperbolic tangent of the elements of :attr:`input`.

    Note:
        The domain of the inverse hyperbolic tangent is `(-1, 1)` and values outside this range
        will be mapped to ``NaN``, except for the values `1` and `-1` for which the output is
        mapped to `+/-INF` respectively.

    .. math::
        \text{out}_{i} = \tanh^{-1}(\text{input}_{i})

    Args:
        input (Tensor): the input tensor.

    Keyword arguments:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4).uniform_(-1, 1)
        >>> a
        tensor([ -0.9385, 0.2968, -0.8591, -0.1871 ])
        >>> torch.atanh(a)
        tensor([ -1.7253, 0.3060, -1.2899, -0.1893 ])
    """

def atanh_(input: Tensor) -> Tensor: ...
def avg_pool1d(
    input: Tensor,
    kernel_size: _int | _size,
    stride: _int | _size = (),
    padding: _int | _size = 0,
    ceil_mode: _bool = False,
    count_include_pad: _bool = True,
) -> Tensor: ...
@overload
def baddbmm(
    beta: Number | _complex,
    self: Tensor,
    alpha: Number | _complex,
    batch1: Tensor,
    batch2: Tensor,
) -> Tensor:
    r"""
    baddbmm(input, batch1, batch2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices in :attr:`batch1`
    and :attr:`batch2`.
    :attr:`input` is added to the final result.

    :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the same
    number of matrices.

    If :attr:`batch1` is a :math:`(b \times n \times m)` tensor, :attr:`batch2` is a
    :math:`(b \times m \times p)` tensor, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a
    :math:`(b \times n \times p)` tensor and :attr:`out` will be a
    :math:`(b \times n \times p)` tensor. Both :attr:`alpha` and :attr:`beta` mean the
    same as the scaling factors used in :meth:`torch.addbmm`.

    .. math::
        \text{out}_i = \beta\ \text{input}_i + \alpha\ (\text{batch1}_i \mathbin{@} \text{batch2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): the tensor to be added
        batch1 (Tensor): the first batch of matrices to be multiplied
        batch2 (Tensor): the second batch of matrices to be multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`\text{batch1} \mathbin{@} \text{batch2}` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(10, 3, 5)
        >>> batch1 = torch.randn(10, 3, 4)
        >>> batch2 = torch.randn(10, 4, 5)
        >>> torch.baddbmm(M, batch1, batch2).size()
        torch.Size([10, 3, 5])
    """

@overload
def baddbmm(
    beta: Number | _complex,
    self: Tensor,
    alpha: Number | _complex,
    batch1: Tensor,
    batch2: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    baddbmm(input, batch1, batch2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices in :attr:`batch1`
    and :attr:`batch2`.
    :attr:`input` is added to the final result.

    :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the same
    number of matrices.

    If :attr:`batch1` is a :math:`(b \times n \times m)` tensor, :attr:`batch2` is a
    :math:`(b \times m \times p)` tensor, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a
    :math:`(b \times n \times p)` tensor and :attr:`out` will be a
    :math:`(b \times n \times p)` tensor. Both :attr:`alpha` and :attr:`beta` mean the
    same as the scaling factors used in :meth:`torch.addbmm`.

    .. math::
        \text{out}_i = \beta\ \text{input}_i + \alpha\ (\text{batch1}_i \mathbin{@} \text{batch2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): the tensor to be added
        batch1 (Tensor): the first batch of matrices to be multiplied
        batch2 (Tensor): the second batch of matrices to be multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`\text{batch1} \mathbin{@} \text{batch2}` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(10, 3, 5)
        >>> batch1 = torch.randn(10, 3, 4)
        >>> batch2 = torch.randn(10, 4, 5)
        >>> torch.baddbmm(M, batch1, batch2).size()
        torch.Size([10, 3, 5])
    """

@overload
def baddbmm(
    input: Tensor,
    batch1: Tensor,
    batch2: Tensor,
    *,
    beta: Number | _complex = 1,
    alpha: Number | _complex = 1,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    baddbmm(input, batch1, batch2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices in :attr:`batch1`
    and :attr:`batch2`.
    :attr:`input` is added to the final result.

    :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the same
    number of matrices.

    If :attr:`batch1` is a :math:`(b \times n \times m)` tensor, :attr:`batch2` is a
    :math:`(b \times m \times p)` tensor, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a
    :math:`(b \times n \times p)` tensor and :attr:`out` will be a
    :math:`(b \times n \times p)` tensor. Both :attr:`alpha` and :attr:`beta` mean the
    same as the scaling factors used in :meth:`torch.addbmm`.

    .. math::
        \text{out}_i = \beta\ \text{input}_i + \alpha\ (\text{batch1}_i \mathbin{@} \text{batch2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): the tensor to be added
        batch1 (Tensor): the first batch of matrices to be multiplied
        batch2 (Tensor): the second batch of matrices to be multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`\text{batch1} \mathbin{@} \text{batch2}` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(10, 3, 5)
        >>> batch1 = torch.randn(10, 3, 4)
        >>> batch2 = torch.randn(10, 4, 5)
        >>> torch.baddbmm(M, batch1, batch2).size()
        torch.Size([10, 3, 5])
    """

@overload
def baddbmm(
    input: Tensor,
    batch1: Tensor,
    batch2: Tensor,
    out_dtype: _dtype,
    *,
    beta: Number | _complex = 1,
    alpha: Number | _complex = 1,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    baddbmm(input, batch1, batch2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices in :attr:`batch1`
    and :attr:`batch2`.
    :attr:`input` is added to the final result.

    :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the same
    number of matrices.

    If :attr:`batch1` is a :math:`(b \times n \times m)` tensor, :attr:`batch2` is a
    :math:`(b \times m \times p)` tensor, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a
    :math:`(b \times n \times p)` tensor and :attr:`out` will be a
    :math:`(b \times n \times p)` tensor. Both :attr:`alpha` and :attr:`beta` mean the
    same as the scaling factors used in :meth:`torch.addbmm`.

    .. math::
        \text{out}_i = \beta\ \text{input}_i + \alpha\ (\text{batch1}_i \mathbin{@} \text{batch2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): the tensor to be added
        batch1 (Tensor): the first batch of matrices to be multiplied
        batch2 (Tensor): the second batch of matrices to be multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`\text{batch1} \mathbin{@} \text{batch2}` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(10, 3, 5)
        >>> batch1 = torch.randn(10, 3, 4)
        >>> batch2 = torch.randn(10, 4, 5)
        >>> torch.baddbmm(M, batch1, batch2).size()
        torch.Size([10, 3, 5])
    """

@overload
def baddbmm(
    beta: Number | _complex,
    self: Tensor,
    batch1: Tensor,
    batch2: Tensor,
) -> Tensor:
    r"""
    baddbmm(input, batch1, batch2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices in :attr:`batch1`
    and :attr:`batch2`.
    :attr:`input` is added to the final result.

    :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the same
    number of matrices.

    If :attr:`batch1` is a :math:`(b \times n \times m)` tensor, :attr:`batch2` is a
    :math:`(b \times m \times p)` tensor, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a
    :math:`(b \times n \times p)` tensor and :attr:`out` will be a
    :math:`(b \times n \times p)` tensor. Both :attr:`alpha` and :attr:`beta` mean the
    same as the scaling factors used in :meth:`torch.addbmm`.

    .. math::
        \text{out}_i = \beta\ \text{input}_i + \alpha\ (\text{batch1}_i \mathbin{@} \text{batch2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): the tensor to be added
        batch1 (Tensor): the first batch of matrices to be multiplied
        batch2 (Tensor): the second batch of matrices to be multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`\text{batch1} \mathbin{@} \text{batch2}` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(10, 3, 5)
        >>> batch1 = torch.randn(10, 3, 4)
        >>> batch2 = torch.randn(10, 4, 5)
        >>> torch.baddbmm(M, batch1, batch2).size()
        torch.Size([10, 3, 5])
    """

@overload
def baddbmm(
    beta: Number | _complex,
    self: Tensor,
    batch1: Tensor,
    batch2: Tensor,
    *,
    out: Tensor,
) -> Tensor:
    r"""
    baddbmm(input, batch1, batch2, out_dtype=None, *, beta=1, alpha=1, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices in :attr:`batch1`
    and :attr:`batch2`.
    :attr:`input` is added to the final result.

    :attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the same
    number of matrices.

    If :attr:`batch1` is a :math:`(b \times n \times m)` tensor, :attr:`batch2` is a
    :math:`(b \times m \times p)` tensor, then :attr:`input` must be
    :ref:`broadcastable <broadcasting-semantics>` with a
    :math:`(b \times n \times p)` tensor and :attr:`out` will be a
    :math:`(b \times n \times p)` tensor. Both :attr:`alpha` and :attr:`beta` mean the
    same as the scaling factors used in :meth:`torch.addbmm`.

    .. math::
        \text{out}_i = \beta\ \text{input}_i + \alpha\ (\text{batch1}_i \mathbin{@} \text{batch2}_i)

    If :attr:`beta` is 0, then the content of :attr:`input` will be ignored, and `nan` and `inf` in
    it will not be propagated.

    For inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and
    :attr:`alpha` must be real numbers, otherwise they should be integers.

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    Args:
        input (Tensor): the tensor to be added
        batch1 (Tensor): the first batch of matrices to be multiplied
        batch2 (Tensor): the second batch of matrices to be multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword args:
        beta (Number, optional): multiplier for :attr:`input` (:math:`\beta`)
        alpha (Number, optional): multiplier for :math:`\text{batch1} \mathbin{@} \text{batch2}` (:math:`\alpha`)
        out (Tensor, optional): the output tensor.

    Example::

        >>> M = torch.randn(10, 3, 5)
        >>> batch1 = torch.randn(10, 3, 4)
        >>> batch2 = torch.randn(10, 4, 5)
        >>> torch.baddbmm(M, batch1, batch2).size()
        torch.Size([10, 3, 5])
    """

@overload
def bartlett_window(
    window_length: _int,
    *,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    bartlett_window(window_length, periodic=True, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Bartlett window function.

    .. math::
        w[n] = 1 - \left| \frac{2n}{N-1} - 1 \right| = \begin{cases}
            \frac{2n}{N - 1} & \text{if } 0 \leq n \leq \frac{N - 1}{2} \\
            2 - \frac{2n}{N - 1} & \text{if } \frac{N - 1}{2} < n < N \\
        \end{cases},

    where :math:`N` is the full window size.

    The input :attr:`window_length` is a positive integer controlling the
    returned window size. :attr:`periodic` flag determines whether the returned
    window trims off the last duplicate value from the symmetric window and is
    ready to be used as a periodic window with functions like
    :meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in
    above formula is in fact :math:`\text{window\_length} + 1`. Also, we always have
    ``torch.bartlett_window(L, periodic=True)`` equal to
    ``torch.bartlett_window(L + 1, periodic=False)[:-1])``.

    .. note::
        If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.

    Arguments:
        window_length (int): the size of returned window
        periodic (bool, optional): If True, returns a window to be used as periodic
            function. If False, return a symmetric window.

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). Only floating point types are supported.
        layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only
              ``torch.strided`` (dense layout) is supported.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Returns:
        Tensor: A 1-D tensor of size :math:`(\text{window\_length},)` containing the window
    """

@overload
def bartlett_window(
    window_length: _int,
    periodic: _bool,
    *,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    bartlett_window(window_length, periodic=True, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Bartlett window function.

    .. math::
        w[n] = 1 - \left| \frac{2n}{N-1} - 1 \right| = \begin{cases}
            \frac{2n}{N - 1} & \text{if } 0 \leq n \leq \frac{N - 1}{2} \\
            2 - \frac{2n}{N - 1} & \text{if } \frac{N - 1}{2} < n < N \\
        \end{cases},

    where :math:`N` is the full window size.

    The input :attr:`window_length` is a positive integer controlling the
    returned window size. :attr:`periodic` flag determines whether the returned
    window trims off the last duplicate value from the symmetric window and is
    ready to be used as a periodic window with functions like
    :meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in
    above formula is in fact :math:`\text{window\_length} + 1`. Also, we always have
    ``torch.bartlett_window(L, periodic=True)`` equal to
    ``torch.bartlett_window(L + 1, periodic=False)[:-1])``.

    .. note::
        If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.

    Arguments:
        window_length (int): the size of returned window
        periodic (bool, optional): If True, returns a window to be used as periodic
            function. If False, return a symmetric window.

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). Only floating point types are supported.
        layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only
              ``torch.strided`` (dense layout) is supported.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Returns:
        Tensor: A 1-D tensor of size :math:`(\text{window\_length},)` containing the window
    """

def batch_norm(
    input: Tensor,
    weight: Tensor | None,
    bias: Tensor | None,
    running_mean: Tensor | None,
    running_var: Tensor | None,
    training: _bool,
    momentum: _float,
    eps: _float,
    cudnn_enabled: _bool,
) -> Tensor: ...
def batch_norm_backward_elemt(
    grad_out: Tensor,
    input: Tensor,
    mean: Tensor,
    invstd: Tensor,
    weight: Tensor | None,
    sum_dy: Tensor,
    sum_dy_xmu: Tensor,
    count: Tensor,
) -> Tensor: ...
def batch_norm_backward_reduce(
    grad_out: Tensor,
    input: Tensor,
    mean: Tensor,
    invstd: Tensor,
    weight: Tensor | None,
    input_g: _bool,
    weight_g: _bool,
    bias_g: _bool,
) -> tuple[Tensor, Tensor, Tensor, Tensor]: ...
def batch_norm_elemt(
    input: Tensor,
    weight: Tensor | None,
    bias: Tensor | None,
    mean: Tensor,
    invstd: Tensor,
    eps: _float,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def batch_norm_gather_stats(
    input: Tensor,
    mean: Tensor,
    invstd: Tensor,
    running_mean: Tensor | None,
    running_var: Tensor | None,
    momentum: _float,
    eps: _float,
    count: _int,
) -> tuple[Tensor, Tensor]: ...
def batch_norm_gather_stats_with_counts(
    input: Tensor,
    mean: Tensor,
    invstd: Tensor,
    running_mean: Tensor | None,
    running_var: Tensor | None,
    momentum: _float,
    eps: _float,
    counts: Tensor,
) -> tuple[Tensor, Tensor]: ...
def batch_norm_stats(input: Tensor, eps: _float) -> tuple[Tensor, Tensor]: ...
def batch_norm_update_stats(
    input: Tensor,
    running_mean: Tensor | None,
    running_var: Tensor | None,
    momentum: _float,
) -> tuple[Tensor, Tensor]: ...
@overload
def bernoulli(
    input: Tensor,
    *,
    generator: Generator | None = None,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bernoulli(input: Tensor, *, generator: Optional[Generator], out: Optional[Tensor]) -> Tensor

    Draws binary random numbers (0 or 1) from a Bernoulli distribution.

    The :attr:`input` tensor should be a tensor containing probabilities
    to be used for drawing the binary random number.
    Hence, all values in :attr:`input` have to be in the range:
    :math:`0 \leq \text{input}_i \leq 1`.

    The :math:`\text{i}^{th}` element of the output tensor will draw a
    value :math:`1` according to the :math:`\text{i}^{th}` probability value given
    in :attr:`input`.

    .. math::
        \text{out}_{i} \sim \mathrm{Bernoulli}(p = \text{input}_{i})

    The returned :attr:`out` tensor only has values 0 or 1 and is of the same
    shape as :attr:`input`.

    :attr:`out` can have integral ``dtype``, but :attr:`input` must have floating
    point ``dtype``.

    Args:
        input (Tensor): the input tensor of probability values for the Bernoulli distribution

    Keyword args:
        generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.empty(3, 3).uniform_(0, 1)  # generate a uniform random matrix with range [0, 1]
        >>> a
        tensor([[ 0.1737,  0.0950,  0.3609],
                [ 0.7148,  0.0289,  0.2676],
                [ 0.9456,  0.8937,  0.7202]])
        >>> torch.bernoulli(a)
        tensor([[ 1.,  0.,  0.],
                [ 0.,  0.,  0.],
                [ 1.,  1.,  1.]])

        >>> a = torch.ones(3, 3) # probability of drawing "1" is 1
        >>> torch.bernoulli(a)
        tensor([[ 1.,  1.,  1.],
                [ 1.,  1.,  1.],
                [ 1.,  1.,  1.]])
        >>> a = torch.zeros(3, 3) # probability of drawing "1" is 0
        >>> torch.bernoulli(a)
        tensor([[ 0.,  0.,  0.],
                [ 0.,  0.,  0.],
                [ 0.,  0.,  0.]])
    """

@overload
def bernoulli(
    input: Tensor,
    p: _float,
    *,
    generator: Generator | None = None,
) -> Tensor:
    r"""
    bernoulli(input: Tensor, *, generator: Optional[Generator], out: Optional[Tensor]) -> Tensor

    Draws binary random numbers (0 or 1) from a Bernoulli distribution.

    The :attr:`input` tensor should be a tensor containing probabilities
    to be used for drawing the binary random number.
    Hence, all values in :attr:`input` have to be in the range:
    :math:`0 \leq \text{input}_i \leq 1`.

    The :math:`\text{i}^{th}` element of the output tensor will draw a
    value :math:`1` according to the :math:`\text{i}^{th}` probability value given
    in :attr:`input`.

    .. math::
        \text{out}_{i} \sim \mathrm{Bernoulli}(p = \text{input}_{i})

    The returned :attr:`out` tensor only has values 0 or 1 and is of the same
    shape as :attr:`input`.

    :attr:`out` can have integral ``dtype``, but :attr:`input` must have floating
    point ``dtype``.

    Args:
        input (Tensor): the input tensor of probability values for the Bernoulli distribution

    Keyword args:
        generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.empty(3, 3).uniform_(0, 1)  # generate a uniform random matrix with range [0, 1]
        >>> a
        tensor([[ 0.1737,  0.0950,  0.3609],
                [ 0.7148,  0.0289,  0.2676],
                [ 0.9456,  0.8937,  0.7202]])
        >>> torch.bernoulli(a)
        tensor([[ 1.,  0.,  0.],
                [ 0.,  0.,  0.],
                [ 1.,  1.,  1.]])

        >>> a = torch.ones(3, 3) # probability of drawing "1" is 1
        >>> torch.bernoulli(a)
        tensor([[ 1.,  1.,  1.],
                [ 1.,  1.,  1.],
                [ 1.,  1.,  1.]])
        >>> a = torch.zeros(3, 3) # probability of drawing "1" is 0
        >>> torch.bernoulli(a)
        tensor([[ 0.,  0.,  0.],
                [ 0.,  0.,  0.],
                [ 0.,  0.,  0.]])
    """

def bilinear(
    input1: Tensor,
    input2: Tensor,
    weight: Tensor,
    bias: Tensor | None = None,
) -> Tensor: ...
def binary_cross_entropy_with_logits(
    input: Tensor,
    target: Tensor,
    weight: Tensor | None = None,
    pos_weight: Tensor | None = None,
    reduction: _int = 1,
) -> Tensor: ...
def bincount(
    input: Tensor,
    weights: Tensor | None = None,
    minlength: _int | SymInt = 0,
) -> Tensor:
    r"""
    bincount(input, weights=None, minlength=0) -> Tensor

    Count the frequency of each value in an array of non-negative ints.

    The number of bins (size 1) is one larger than the largest value in
    :attr:`input` unless :attr:`input` is empty, in which case the result is a
    tensor of size 0. If :attr:`minlength` is specified, the number of bins is at least
    :attr:`minlength` and if :attr:`input` is empty, then the result is tensor of size
    :attr:`minlength` filled with zeros. If ``n`` is the value at position ``i``,
    ``out[n] += weights[i]`` if :attr:`weights` is specified else
    ``out[n] += 1``.

    Note:
        This operation may produce nondeterministic gradients when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.

    Arguments:
        input (Tensor): 1-d int tensor
        weights (Tensor): optional, weight for each value in the input tensor.
            Should be of same size as input tensor.
        minlength (int): optional, minimum number of bins. Should be non-negative.

    Returns:
        output (Tensor): a tensor of shape ``Size([max(input) + 1])`` if
        :attr:`input` is non-empty, else ``Size(0)``

    Example::

        >>> input = torch.randint(0, 8, (5,), dtype=torch.int64)
        >>> weights = torch.linspace(0, 1, steps=5)
        >>> input, weights
        (tensor([4, 3, 6, 3, 4]),
         tensor([ 0.0000,  0.2500,  0.5000,  0.7500,  1.0000])

        >>> torch.bincount(input)
        tensor([0, 0, 0, 2, 2, 0, 1])

        >>> input.bincount(weights)
        tensor([0.0000, 0.0000, 0.0000, 1.0000, 1.0000, 0.0000, 0.5000])
    """

def binomial(
    count: Tensor,
    prob: Tensor,
    generator: Generator | None = None,
) -> Tensor: ...
@overload
def bitwise_and(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bitwise_and(input, other, *, out=None) -> Tensor

    Computes the bitwise AND of :attr:`input` and :attr:`other`. The input tensor must be of
    integral or Boolean types. For bool tensors, it computes the logical AND.

    Args:
        input: the first input tensor
        other: the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_and(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([1, 0,  3], dtype=torch.int8)
        >>> torch.bitwise_and(torch.tensor([True, True, False]), torch.tensor([False, True, False]))
        tensor([ False, True, False])
    """

@overload
def bitwise_and(self: Number | _complex, other: Tensor) -> Tensor:
    r"""
    bitwise_and(input, other, *, out=None) -> Tensor

    Computes the bitwise AND of :attr:`input` and :attr:`other`. The input tensor must be of
    integral or Boolean types. For bool tensors, it computes the logical AND.

    Args:
        input: the first input tensor
        other: the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_and(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([1, 0,  3], dtype=torch.int8)
        >>> torch.bitwise_and(torch.tensor([True, True, False]), torch.tensor([False, True, False]))
        tensor([ False, True, False])
    """

@overload
def bitwise_and(
    input: Tensor,
    other: Number | _complex,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bitwise_and(input, other, *, out=None) -> Tensor

    Computes the bitwise AND of :attr:`input` and :attr:`other`. The input tensor must be of
    integral or Boolean types. For bool tensors, it computes the logical AND.

    Args:
        input: the first input tensor
        other: the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_and(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([1, 0,  3], dtype=torch.int8)
        >>> torch.bitwise_and(torch.tensor([True, True, False]), torch.tensor([False, True, False]))
        tensor([ False, True, False])
    """

@overload
def bitwise_left_shift(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bitwise_left_shift(input, other, *, out=None) -> Tensor

    Computes the left arithmetic shift of :attr:`input` by :attr:`other` bits.
    The input tensor must be of integral type. This operator supports
    :ref:`broadcasting to a common shape <broadcasting-semantics>` and
    :ref:`type promotion <type-promotion-doc>`.

    The operation applied is:

    .. math::
        \text{out}_i = \text{input}_i << \text{other}_i

    Args:
        input (Tensor or Scalar): the first input tensor
        other (Tensor or Scalar): the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_left_shift(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([-2, -2, 24], dtype=torch.int8)
    """

@overload
def bitwise_left_shift(self: Number | _complex, other: Tensor) -> Tensor:
    r"""
    bitwise_left_shift(input, other, *, out=None) -> Tensor

    Computes the left arithmetic shift of :attr:`input` by :attr:`other` bits.
    The input tensor must be of integral type. This operator supports
    :ref:`broadcasting to a common shape <broadcasting-semantics>` and
    :ref:`type promotion <type-promotion-doc>`.

    The operation applied is:

    .. math::
        \text{out}_i = \text{input}_i << \text{other}_i

    Args:
        input (Tensor or Scalar): the first input tensor
        other (Tensor or Scalar): the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_left_shift(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([-2, -2, 24], dtype=torch.int8)
    """

@overload
def bitwise_left_shift(
    input: Tensor,
    other: Number | _complex,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bitwise_left_shift(input, other, *, out=None) -> Tensor

    Computes the left arithmetic shift of :attr:`input` by :attr:`other` bits.
    The input tensor must be of integral type. This operator supports
    :ref:`broadcasting to a common shape <broadcasting-semantics>` and
    :ref:`type promotion <type-promotion-doc>`.

    The operation applied is:

    .. math::
        \text{out}_i = \text{input}_i << \text{other}_i

    Args:
        input (Tensor or Scalar): the first input tensor
        other (Tensor or Scalar): the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_left_shift(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([-2, -2, 24], dtype=torch.int8)
    """

def bitwise_not(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    bitwise_not(input, *, out=None) -> Tensor

    Computes the bitwise NOT of the given input tensor. The input tensor must be of
    integral or Boolean types. For bool tensors, it computes the logical NOT.

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_not(torch.tensor([-1, -2, 3], dtype=torch.int8))
        tensor([ 0,  1, -4], dtype=torch.int8)
    """

@overload
def bitwise_or(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bitwise_or(input: Tensor, other: Tensor, *, out: Optional[Tensor]) -> Tensor

    Computes the bitwise OR of :attr:`input` and :attr:`other`. The input tensor must be of
    integral or Boolean types. For bool tensors, it computes the logical OR.

    Args:
        input: the first input tensor
        other: the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_or(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([-1, -2,  3], dtype=torch.int8)
        >>> torch.bitwise_or(torch.tensor([True, True, False]), torch.tensor([False, True, False]))
        tensor([ True, True, False])
    """

@overload
def bitwise_or(self: Number | _complex, other: Tensor) -> Tensor:
    r"""
    bitwise_or(input: Tensor, other: Tensor, *, out: Optional[Tensor]) -> Tensor

    Computes the bitwise OR of :attr:`input` and :attr:`other`. The input tensor must be of
    integral or Boolean types. For bool tensors, it computes the logical OR.

    Args:
        input: the first input tensor
        other: the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_or(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([-1, -2,  3], dtype=torch.int8)
        >>> torch.bitwise_or(torch.tensor([True, True, False]), torch.tensor([False, True, False]))
        tensor([ True, True, False])
    """

@overload
def bitwise_or(
    input: Tensor,
    other: Number | _complex,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bitwise_or(input: Tensor, other: Tensor, *, out: Optional[Tensor]) -> Tensor

    Computes the bitwise OR of :attr:`input` and :attr:`other`. The input tensor must be of
    integral or Boolean types. For bool tensors, it computes the logical OR.

    Args:
        input: the first input tensor
        other: the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_or(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([-1, -2,  3], dtype=torch.int8)
        >>> torch.bitwise_or(torch.tensor([True, True, False]), torch.tensor([False, True, False]))
        tensor([ True, True, False])
    """

@overload
def bitwise_right_shift(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bitwise_right_shift(input, other, *, out=None) -> Tensor

    Computes the right arithmetic shift of :attr:`input` by :attr:`other` bits.
    The input tensor must be of integral type. This operator supports
    :ref:`broadcasting to a common shape <broadcasting-semantics>` and
    :ref:`type promotion <type-promotion-doc>`.
    In any case, if the value of the right operand is negative or is greater
    or equal to the number of bits in the promoted left operand, the behavior is undefined.

    The operation applied is:

    .. math::
        \text{out}_i = \text{input}_i >> \text{other}_i

    Args:
        input (Tensor or Scalar): the first input tensor
        other (Tensor or Scalar): the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_right_shift(torch.tensor([-2, -7, 31], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([-1, -7,  3], dtype=torch.int8)
    """

@overload
def bitwise_right_shift(self: Number | _complex, other: Tensor) -> Tensor:
    r"""
    bitwise_right_shift(input, other, *, out=None) -> Tensor

    Computes the right arithmetic shift of :attr:`input` by :attr:`other` bits.
    The input tensor must be of integral type. This operator supports
    :ref:`broadcasting to a common shape <broadcasting-semantics>` and
    :ref:`type promotion <type-promotion-doc>`.
    In any case, if the value of the right operand is negative or is greater
    or equal to the number of bits in the promoted left operand, the behavior is undefined.

    The operation applied is:

    .. math::
        \text{out}_i = \text{input}_i >> \text{other}_i

    Args:
        input (Tensor or Scalar): the first input tensor
        other (Tensor or Scalar): the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_right_shift(torch.tensor([-2, -7, 31], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([-1, -7,  3], dtype=torch.int8)
    """

@overload
def bitwise_right_shift(
    input: Tensor,
    other: Number | _complex,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bitwise_right_shift(input, other, *, out=None) -> Tensor

    Computes the right arithmetic shift of :attr:`input` by :attr:`other` bits.
    The input tensor must be of integral type. This operator supports
    :ref:`broadcasting to a common shape <broadcasting-semantics>` and
    :ref:`type promotion <type-promotion-doc>`.
    In any case, if the value of the right operand is negative or is greater
    or equal to the number of bits in the promoted left operand, the behavior is undefined.

    The operation applied is:

    .. math::
        \text{out}_i = \text{input}_i >> \text{other}_i

    Args:
        input (Tensor or Scalar): the first input tensor
        other (Tensor or Scalar): the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_right_shift(torch.tensor([-2, -7, 31], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([-1, -7,  3], dtype=torch.int8)
    """

@overload
def bitwise_xor(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bitwise_xor(input, other, *, out=None) -> Tensor

    Computes the bitwise XOR of :attr:`input` and :attr:`other`. The input tensor must be of
    integral or Boolean types. For bool tensors, it computes the logical XOR.

    Args:
        input: the first input tensor
        other: the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_xor(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([-2, -2,  0], dtype=torch.int8)
        >>> torch.bitwise_xor(torch.tensor([True, True, False]), torch.tensor([False, True, False]))
        tensor([ True, False, False])
    """

@overload
def bitwise_xor(self: Number | _complex, other: Tensor) -> Tensor:
    r"""
    bitwise_xor(input, other, *, out=None) -> Tensor

    Computes the bitwise XOR of :attr:`input` and :attr:`other`. The input tensor must be of
    integral or Boolean types. For bool tensors, it computes the logical XOR.

    Args:
        input: the first input tensor
        other: the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_xor(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([-2, -2,  0], dtype=torch.int8)
        >>> torch.bitwise_xor(torch.tensor([True, True, False]), torch.tensor([False, True, False]))
        tensor([ True, False, False])
    """

@overload
def bitwise_xor(
    input: Tensor,
    other: Number | _complex,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bitwise_xor(input, other, *, out=None) -> Tensor

    Computes the bitwise XOR of :attr:`input` and :attr:`other`. The input tensor must be of
    integral or Boolean types. For bool tensors, it computes the logical XOR.

    Args:
        input: the first input tensor
        other: the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.bitwise_xor(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))
        tensor([-2, -2,  0], dtype=torch.int8)
        >>> torch.bitwise_xor(torch.tensor([True, True, False]), torch.tensor([False, True, False]))
        tensor([ True, False, False])
    """

@overload
def blackman_window(
    window_length: _int,
    *,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    blackman_window(window_length, periodic=True, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Blackman window function.

    .. math::
        w[n] = 0.42 - 0.5 \cos \left( \frac{2 \pi n}{N - 1} \right) + 0.08 \cos \left( \frac{4 \pi n}{N - 1} \right)

    where :math:`N` is the full window size.

    The input :attr:`window_length` is a positive integer controlling the
    returned window size. :attr:`periodic` flag determines whether the returned
    window trims off the last duplicate value from the symmetric window and is
    ready to be used as a periodic window with functions like
    :meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in
    above formula is in fact :math:`\text{window\_length} + 1`. Also, we always have
    ``torch.blackman_window(L, periodic=True)`` equal to
    ``torch.blackman_window(L + 1, periodic=False)[:-1]``.

    .. note::
        If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.

    Arguments:
        window_length (int): the size of returned window
        periodic (bool, optional): If True, returns a window to be used as periodic
            function. If False, return a symmetric window.

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). Only floating point types are supported.
        layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only
              ``torch.strided`` (dense layout) is supported.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Returns:
        Tensor: A 1-D tensor of size :math:`(\text{window\_length},)` containing the window
    """

@overload
def blackman_window(
    window_length: _int,
    periodic: _bool,
    *,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    blackman_window(window_length, periodic=True, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Blackman window function.

    .. math::
        w[n] = 0.42 - 0.5 \cos \left( \frac{2 \pi n}{N - 1} \right) + 0.08 \cos \left( \frac{4 \pi n}{N - 1} \right)

    where :math:`N` is the full window size.

    The input :attr:`window_length` is a positive integer controlling the
    returned window size. :attr:`periodic` flag determines whether the returned
    window trims off the last duplicate value from the symmetric window and is
    ready to be used as a periodic window with functions like
    :meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in
    above formula is in fact :math:`\text{window\_length} + 1`. Also, we always have
    ``torch.blackman_window(L, periodic=True)`` equal to
    ``torch.blackman_window(L + 1, periodic=False)[:-1]``.

    .. note::
        If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.

    Arguments:
        window_length (int): the size of returned window
        periodic (bool, optional): If True, returns a window to be used as periodic
            function. If False, return a symmetric window.

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`). Only floating point types are supported.
        layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only
              ``torch.strided`` (dense layout) is supported.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Returns:
        Tensor: A 1-D tensor of size :math:`(\text{window\_length},)` containing the window
    """

@overload
def bmm(
    input: Tensor,
    mat2: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bmm(input, mat2, out_dtype=None, *, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices stored in :attr:`input`
    and :attr:`mat2`.

    :attr:`input` and :attr:`mat2` must be 3-D tensors each containing
    the same number of matrices.

    If :attr:`input` is a :math:`(b \times n \times m)` tensor, :attr:`mat2` is a
    :math:`(b \times m \times p)` tensor, :attr:`out` will be a
    :math:`(b \times n \times p)` tensor.

    .. math::
        \text{out}_i = \text{input}_i \mathbin{@} \text{mat2}_i

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    .. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.
              For broadcasting matrix products, see :func:`torch.matmul`.

    Args:
        input (Tensor): the first batch of matrices to be multiplied
        mat2 (Tensor): the second batch of matrices to be multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword Args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> input = torch.randn(10, 3, 4)
        >>> mat2 = torch.randn(10, 4, 5)
        >>> res = torch.bmm(input, mat2)
        >>> res.size()
        torch.Size([10, 3, 5])
    """

@overload
def bmm(
    input: Tensor,
    mat2: Tensor,
    out_dtype: _dtype,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bmm(input, mat2, out_dtype=None, *, out=None) -> Tensor

    Performs a batch matrix-matrix product of matrices stored in :attr:`input`
    and :attr:`mat2`.

    :attr:`input` and :attr:`mat2` must be 3-D tensors each containing
    the same number of matrices.

    If :attr:`input` is a :math:`(b \times n \times m)` tensor, :attr:`mat2` is a
    :math:`(b \times m \times p)` tensor, :attr:`out` will be a
    :math:`(b \times n \times p)` tensor.

    .. math::
        \text{out}_i = \text{input}_i \mathbin{@} \text{mat2}_i

    This operator supports :ref:`TensorFloat32<tf32_on_ampere>`.

    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.

    .. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.
              For broadcasting matrix products, see :func:`torch.matmul`.

    Args:
        input (Tensor): the first batch of matrices to be multiplied
        mat2 (Tensor): the second batch of matrices to be multiplied
        out_dtype (dtype, optional): the dtype of the output tensor,
            Supported only on CUDA and for torch.float32 given
            torch.float16/torch.bfloat16 input dtypes

    Keyword Args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> input = torch.randn(10, 3, 4)
        >>> mat2 = torch.randn(10, 4, 5)
        >>> res = torch.bmm(input, mat2)
        >>> res.size()
        torch.Size([10, 3, 5])
    """

def broadcast_to(input: Tensor, size: Sequence[_int | SymInt]) -> Tensor:
    r"""
    broadcast_to(input, shape) -> Tensor

    Broadcasts :attr:`input` to the shape :attr:`\shape`.
    Equivalent to calling ``input.expand(shape)``. See :meth:`~Tensor.expand` for details.

    Args:
        input (Tensor): the input tensor.
        shape (list, tuple, or :class:`torch.Size`): the new shape.

    Example::

        >>> x = torch.tensor([1, 2, 3])
        >>> torch.broadcast_to(x, (3, 3))
        tensor([[1, 2, 3],
                [1, 2, 3],
                [1, 2, 3]])
    """

@overload
def bucketize(
    input: Tensor,
    boundaries: Tensor,
    *,
    out_int32: _bool = False,
    right: _bool = False,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    bucketize(input, boundaries, *, out_int32=False, right=False, out=None) -> Tensor

    Returns the indices of the buckets to which each value in the :attr:`input` belongs, where the
    boundaries of the buckets are set by :attr:`boundaries`. Return a new tensor with the same size
    as :attr:`input`. If :attr:`right` is False (default), then the left boundary is open. Note that
    this behavior is opposite the behavior of
    `numpy.digitize <https://numpy.org/doc/stable/reference/generated/numpy.digitize.html>`_.
    More formally, the returned index satisfies the following rules:

    .. list-table::
       :widths: 15 85
       :header-rows: 1

       * - :attr:`right`
         - *returned index satisfies*
       * - False
         - ``boundaries[i-1] < input[m][n]...[l][x] <= boundaries[i]``
       * - True
         - ``boundaries[i-1] <= input[m][n]...[l][x] < boundaries[i]``

    Args:
        input (Tensor or Scalar): N-D tensor or a Scalar containing the search value(s).
        boundaries (Tensor): 1-D tensor, must contain a strictly increasing sequence, or the return value is undefined.

    Keyword args:
        out_int32 (bool, optional): indicate the output data type. torch.int32 if True, torch.int64 otherwise.
                                    Default value is False, i.e. default output data type is torch.int64.
        right (bool, optional): determines the behavior for values in :attr:`boundaries`. See the table above.
        out (Tensor, optional): the output tensor, must be the same size as :attr:`input` if provided.


    Example::

        >>> boundaries = torch.tensor([1, 3, 5, 7, 9])
        >>> boundaries
        tensor([1, 3, 5, 7, 9])
        >>> v = torch.tensor([[3, 6, 9], [3, 6, 9]])
        >>> v
        tensor([[3, 6, 9],
                [3, 6, 9]])
        >>> torch.bucketize(v, boundaries)
        tensor([[1, 3, 4],
                [1, 3, 4]])
        >>> torch.bucketize(v, boundaries, right=True)
        tensor([[2, 3, 5],
                [2, 3, 5]])
    """

@overload
def bucketize(
    self: Number | _complex,
    boundaries: Tensor,
    *,
    out_int32: _bool = False,
    right: _bool = False,
) -> Tensor:
    r"""
    bucketize(input, boundaries, *, out_int32=False, right=False, out=None) -> Tensor

    Returns the indices of the buckets to which each value in the :attr:`input` belongs, where the
    boundaries of the buckets are set by :attr:`boundaries`. Return a new tensor with the same size
    as :attr:`input`. If :attr:`right` is False (default), then the left boundary is open. Note that
    this behavior is opposite the behavior of
    `numpy.digitize <https://numpy.org/doc/stable/reference/generated/numpy.digitize.html>`_.
    More formally, the returned index satisfies the following rules:

    .. list-table::
       :widths: 15 85
       :header-rows: 1

       * - :attr:`right`
         - *returned index satisfies*
       * - False
         - ``boundaries[i-1] < input[m][n]...[l][x] <= boundaries[i]``
       * - True
         - ``boundaries[i-1] <= input[m][n]...[l][x] < boundaries[i]``

    Args:
        input (Tensor or Scalar): N-D tensor or a Scalar containing the search value(s).
        boundaries (Tensor): 1-D tensor, must contain a strictly increasing sequence, or the return value is undefined.

    Keyword args:
        out_int32 (bool, optional): indicate the output data type. torch.int32 if True, torch.int64 otherwise.
                                    Default value is False, i.e. default output data type is torch.int64.
        right (bool, optional): determines the behavior for values in :attr:`boundaries`. See the table above.
        out (Tensor, optional): the output tensor, must be the same size as :attr:`input` if provided.


    Example::

        >>> boundaries = torch.tensor([1, 3, 5, 7, 9])
        >>> boundaries
        tensor([1, 3, 5, 7, 9])
        >>> v = torch.tensor([[3, 6, 9], [3, 6, 9]])
        >>> v
        tensor([[3, 6, 9],
                [3, 6, 9]])
        >>> torch.bucketize(v, boundaries)
        tensor([[1, 3, 4],
                [1, 3, 4]])
        >>> torch.bucketize(v, boundaries, right=True)
        tensor([[2, 3, 5],
                [2, 3, 5]])
    """

def can_cast(from_: _dtype, to: _dtype) -> _bool:
    r"""
    can_cast(from_, to) -> bool

    Determines if a type conversion is allowed under PyTorch casting rules
    described in the type promotion :ref:`documentation <type-promotion-doc>`.

    Args:
        from\_ (dtype): The original :class:`torch.dtype`.
        to (dtype): The target :class:`torch.dtype`.

    Example::

        >>> torch.can_cast(torch.double, torch.float)
        True
        >>> torch.can_cast(torch.float, torch.int)
        False
    """

@overload
def cat(
    tensors: tuple[Tensor, ...] | list[Tensor] | None,
    dim: _int = 0,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    cat(tensors, dim=0, *, out=None) -> Tensor

    Concatenates the given sequence of tensors in :attr:`tensors` in the given dimension.
    All tensors must either have the same shape (except in the concatenating
    dimension) or be a 1-D empty tensor with size ``(0,)``.

    :func:`torch.cat` can be seen as an inverse operation for :func:`torch.split`
    and :func:`torch.chunk`.

    :func:`torch.cat` can be best understood via examples.

    .. seealso::

        :func:`torch.stack` concatenates the given sequence along a new dimension.

    Args:
        tensors (sequence of Tensors): Non-empty tensors provided must have the same shape,
            except in the cat dimension.

        dim (int, optional): the dimension over which the tensors are concatenated

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> x = torch.randn(2, 3)
        >>> x
        tensor([[ 0.6580, -1.0969, -0.4614],
                [-0.1034, -0.5790,  0.1497]])
        >>> torch.cat((x, x, x), 0)
        tensor([[ 0.6580, -1.0969, -0.4614],
                [-0.1034, -0.5790,  0.1497],
                [ 0.6580, -1.0969, -0.4614],
                [-0.1034, -0.5790,  0.1497],
                [ 0.6580, -1.0969, -0.4614],
                [-0.1034, -0.5790,  0.1497]])
        >>> torch.cat((x, x, x), 1)
        tensor([[ 0.6580, -1.0969, -0.4614,  0.6580, -1.0969, -0.4614,  0.6580,
                 -1.0969, -0.4614],
                [-0.1034, -0.5790,  0.1497, -0.1034, -0.5790,  0.1497, -0.1034,
                 -0.5790,  0.1497]])
    """

@overload
def cat(
    tensors: tuple[Tensor, ...] | list[Tensor] | None,
    dim: str | EllipsisType | None,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    cat(tensors, dim=0, *, out=None) -> Tensor

    Concatenates the given sequence of tensors in :attr:`tensors` in the given dimension.
    All tensors must either have the same shape (except in the concatenating
    dimension) or be a 1-D empty tensor with size ``(0,)``.

    :func:`torch.cat` can be seen as an inverse operation for :func:`torch.split`
    and :func:`torch.chunk`.

    :func:`torch.cat` can be best understood via examples.

    .. seealso::

        :func:`torch.stack` concatenates the given sequence along a new dimension.

    Args:
        tensors (sequence of Tensors): Non-empty tensors provided must have the same shape,
            except in the cat dimension.

        dim (int, optional): the dimension over which the tensors are concatenated

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> x = torch.randn(2, 3)
        >>> x
        tensor([[ 0.6580, -1.0969, -0.4614],
                [-0.1034, -0.5790,  0.1497]])
        >>> torch.cat((x, x, x), 0)
        tensor([[ 0.6580, -1.0969, -0.4614],
                [-0.1034, -0.5790,  0.1497],
                [ 0.6580, -1.0969, -0.4614],
                [-0.1034, -0.5790,  0.1497],
                [ 0.6580, -1.0969, -0.4614],
                [-0.1034, -0.5790,  0.1497]])
        >>> torch.cat((x, x, x), 1)
        tensor([[ 0.6580, -1.0969, -0.4614,  0.6580, -1.0969, -0.4614,  0.6580,
                 -1.0969, -0.4614],
                [-0.1034, -0.5790,  0.1497, -0.1034, -0.5790,  0.1497, -0.1034,
                 -0.5790,  0.1497]])
    """

def ccol_indices_copy(
    input: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def ceil(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    ceil(input, *, out=None) -> Tensor

    Returns a new tensor with the ceil of the elements of :attr:`input`,
    the smallest integer greater than or equal to each element.

    For integer inputs, follows the array-api convention of returning a
    copy of the input tensor.

    .. math::
        \text{out}_{i} = \left\lceil \text{input}_{i} \right\rceil

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4)
        >>> a
        tensor([-0.6341, -1.4208, -1.0900,  0.5826])
        >>> torch.ceil(a)
        tensor([-0., -1., -1.,  1.])
    """

def ceil_(input: Tensor) -> Tensor: ...
def celu(input: Tensor, alpha: Number | _complex = 1.0) -> Tensor: ...
def celu_(input: Tensor, alpha: Number | _complex = 1.0) -> Tensor: ...
def channel_shuffle(input: Tensor, groups: _int | SymInt) -> Tensor: ...
def cholesky(
    input: Tensor,
    upper: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    cholesky(input, upper=False, *, out=None) -> Tensor

    Computes the Cholesky decomposition of a symmetric positive-definite
    matrix :math:`A` or for batches of symmetric positive-definite matrices.

    If :attr:`upper` is ``True``, the returned matrix ``U`` is upper-triangular, and
    the decomposition has the form:

    .. math::

      A = U^TU

    If :attr:`upper` is ``False``, the returned matrix ``L`` is lower-triangular, and
    the decomposition has the form:

    .. math::

        A = LL^T

    If :attr:`upper` is ``True``, and :math:`A` is a batch of symmetric positive-definite
    matrices, then the returned tensor will be composed of upper-triangular Cholesky factors
    of each of the individual matrices. Similarly, when :attr:`upper` is ``False``, the returned
    tensor will be composed of lower-triangular Cholesky factors of each of the individual
    matrices.

    .. warning::

        :func:`torch.cholesky` is deprecated in favor of :func:`torch.linalg.cholesky`
        and will be removed in a future PyTorch release.

        ``L = torch.cholesky(A)`` should be replaced with

        .. code:: python

            L = torch.linalg.cholesky(A)

        ``U = torch.cholesky(A, upper=True)`` should be replaced with

        .. code:: python

            U = torch.linalg.cholesky(A).mH

        This transform will produce equivalent results for all valid (symmetric positive definite) inputs.

    Args:
        input (Tensor): the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more
                    batch dimensions consisting of symmetric positive-definite matrices.
        upper (bool, optional): flag that indicates whether to return a
                                upper or lower triangular matrix. Default: ``False``

    Keyword args:
        out (Tensor, optional): the output matrix

    Example::

        >>> a = torch.randn(3, 3)
        >>> a = a @ a.mT + 1e-3 # make symmetric positive-definite
        >>> l = torch.cholesky(a)
        >>> a
        tensor([[ 2.4112, -0.7486,  1.4551],
                [-0.7486,  1.3544,  0.1294],
                [ 1.4551,  0.1294,  1.6724]])
        >>> l
        tensor([[ 1.5528,  0.0000,  0.0000],
                [-0.4821,  1.0592,  0.0000],
                [ 0.9371,  0.5487,  0.7023]])
        >>> l @ l.mT
        tensor([[ 2.4112, -0.7486,  1.4551],
                [-0.7486,  1.3544,  0.1294],
                [ 1.4551,  0.1294,  1.6724]])
        >>> a = torch.randn(3, 2, 2) # Example for batched input
        >>> a = a @ a.mT + 1e-03 # make symmetric positive-definite
        >>> l = torch.cholesky(a)
        >>> z = l @ l.mT
        >>> torch.dist(z, a)
        tensor(2.3842e-07)
    """

def cholesky_inverse(
    input: Tensor,
    upper: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    cholesky_inverse(L, upper=False, *, out=None) -> Tensor

    Computes the inverse of a complex Hermitian or real symmetric
    positive-definite matrix given its Cholesky decomposition.

    Let :math:`A` be a complex Hermitian or real symmetric positive-definite matrix,
    and :math:`L` its Cholesky decomposition such that:

    .. math::

        A = LL^{\text{H}}

    where :math:`L^{\text{H}}` is the conjugate transpose when :math:`L` is complex,
    and the transpose when :math:`L` is real-valued.

    Computes the inverse matrix :math:`A^{-1}`.

    Supports input of float, double, cfloat and cdouble dtypes.
    Also supports batches of matrices, and if :math:`A` is a batch of matrices
    then the output has the same batch dimensions.

    Args:
        L (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions
            consisting of lower or upper triangular Cholesky decompositions of
            symmetric or Hermitian positive-definite matrices.
        upper (bool, optional): flag that indicates whether :math:`L` is lower triangular
            or upper triangular. Default: ``False``

    Keyword args:
        out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.

    Example::

        >>> A = torch.randn(3, 3)
        >>> A = A @ A.T + torch.eye(3) * 1e-3 # Creates a symmetric positive-definite matrix
        >>> L = torch.linalg.cholesky(A) # Extract Cholesky decomposition
        >>> torch.cholesky_inverse(L)
        tensor([[ 1.9314,  1.2251, -0.0889],
                [ 1.2251,  2.4439,  0.2122],
                [-0.0889,  0.2122,  0.1412]])
        >>> A.inverse()
        tensor([[ 1.9314,  1.2251, -0.0889],
                [ 1.2251,  2.4439,  0.2122],
                [-0.0889,  0.2122,  0.1412]])

        >>> A = torch.randn(3, 2, 2, dtype=torch.complex64)
        >>> A = A @ A.mH + torch.eye(2) * 1e-3 # Batch of Hermitian positive-definite matrices
        >>> L = torch.linalg.cholesky(A)
        >>> torch.dist(torch.inverse(A), torch.cholesky_inverse(L))
        tensor(5.6358e-7)
    """

def cholesky_solve(
    input: Tensor,
    input2: Tensor,
    upper: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    cholesky_solve(B, L, upper=False, *, out=None) -> Tensor

    Computes the solution of a system of linear equations with complex Hermitian
    or real symmetric positive-definite lhs given its Cholesky decomposition.

    Let :math:`A` be a complex Hermitian or real symmetric positive-definite matrix,
    and :math:`L` its Cholesky decomposition such that:

    .. math::

        A = LL^{\text{H}}

    where :math:`L^{\text{H}}` is the conjugate transpose when :math:`L` is complex,
    and the transpose when :math:`L` is real-valued.

    Returns the solution :math:`X` of the following linear system:

    .. math::

        AX = B

    Supports inputs of float, double, cfloat and cdouble dtypes.
    Also supports batches of matrices, and if :math:`A` or :math:`B` is a batch of matrices
    then the output has the same batch dimensions.

    Args:
        B (Tensor): right-hand side tensor of shape `(*, n, k)`
            where :math:`*` is zero or more batch dimensions
        L (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions
            consisting of lower or upper triangular Cholesky decompositions of
            symmetric or Hermitian positive-definite matrices.
        upper (bool, optional): flag that indicates whether :math:`L` is lower triangular
            or upper triangular. Default: ``False``.

    Keyword args:
        out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.

    Example::

        >>> A = torch.randn(3, 3)
        >>> A = A @ A.T + torch.eye(3) * 1e-3 # Creates a symmetric positive-definite matrix
        >>> L = torch.linalg.cholesky(A) # Extract Cholesky decomposition
        >>> B = torch.randn(3, 2)
        >>> torch.cholesky_solve(B, L)
        tensor([[ -8.1625,  19.6097],
                [ -5.8398,  14.2387],
                [ -4.3771,  10.4173]])
        >>> A.inverse() @  B
        tensor([[ -8.1626,  19.6097],
                [ -5.8398,  14.2387],
                [ -4.3771,  10.4173]])

        >>> A = torch.randn(3, 2, 2, dtype=torch.complex64)
        >>> A = A @ A.mH + torch.eye(2) * 1e-3 # Batch of Hermitian positive-definite matrices
        >>> L = torch.linalg.cholesky(A)
        >>> B = torch.randn(2, 1, dtype=torch.complex64)
        >>> X = torch.cholesky_solve(B, L)
        >>> torch.dist(X, A.inverse() @ B)
        tensor(1.6881e-5)
    """

def choose_qparams_optimized(
    input: Tensor,
    numel: _int,
    n_bins: _int,
    ratio: _float,
    bit_width: _int,
) -> tuple[Tensor, Tensor]: ...
def chunk(input: Tensor, chunks: _int, dim: _int = 0) -> tuple[Tensor, ...]:
    r"""
    chunk(input: Tensor, chunks: int, dim: int = 0) -> Tuple[Tensor, ...]

    Attempts to split a tensor into the specified number of chunks. Each chunk is a view of
    the input tensor.


    .. note::

        This function may return fewer than the specified number of chunks!

    .. seealso::

        :func:`torch.tensor_split` a function that always returns exactly the specified number of chunks

    If the tensor size along the given dimension :attr:`dim` is divisible by :attr:`chunks`,
    all returned chunks will be the same size.
    If the tensor size along the given dimension :attr:`dim` is not divisible by :attr:`chunks`,
    all returned chunks will be the same size, except the last one.
    If such division is not possible, this function may return fewer
    than the specified number of chunks.

    Arguments:
        input (Tensor): the tensor to split
        chunks (int): number of chunks to return
        dim (int): dimension along which to split the tensor

    Example:
        >>> torch.arange(11).chunk(6)
        (tensor([0, 1]),
         tensor([2, 3]),
         tensor([4, 5]),
         tensor([6, 7]),
         tensor([8, 9]),
         tensor([10]))
        >>> torch.arange(12).chunk(6)
        (tensor([0, 1]),
         tensor([2, 3]),
         tensor([4, 5]),
         tensor([6, 7]),
         tensor([8, 9]),
         tensor([10, 11]))
        >>> torch.arange(13).chunk(6)
        (tensor([0, 1, 2]),
         tensor([3, 4, 5]),
         tensor([6, 7, 8]),
         tensor([ 9, 10, 11]),
         tensor([12]))
    """

@overload
def clamp(
    input: Tensor,
    min: Tensor | None = None,
    max: Tensor | None = None,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    clamp(input, min=None, max=None, *, out=None) -> Tensor

    Clamps all elements in :attr:`input` into the range `[` :attr:`min`, :attr:`max` `]`.
    Letting min_value and max_value be :attr:`min` and :attr:`max`, respectively, this returns:

    .. math::
        y_i = \min(\max(x_i, \text{min\_value}_i), \text{max\_value}_i)

    If :attr:`min` is ``None``, there is no lower bound.
    Or, if :attr:`max` is ``None`` there is no upper bound.


    .. note::
        If :attr:`min` is greater than :attr:`max` :func:`torch.clamp(..., min, max) <torch.clamp>`
        sets all elements in :attr:`input` to the value of :attr:`max`.

    Args:
        input (Tensor): the input tensor.
        min (Number or Tensor, optional): lower-bound of the range to be clamped to
        max (Number or Tensor, optional): upper-bound of the range to be clamped to

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4)
        >>> a
        tensor([-1.7120,  0.1734, -0.0478, -0.0922])
        >>> torch.clamp(a, min=-0.5, max=0.5)
        tensor([-0.5000,  0.1734, -0.0478, -0.0922])

        >>> min = torch.linspace(-1, 1, steps=4)
        >>> torch.clamp(a, min=min)
        tensor([-1.0000,  0.1734,  0.3333,  1.0000])
    """

@overload
def clamp(
    input: Tensor,
    min: Number | _complex | None = None,
    max: Number | _complex | None = None,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    clamp(input, min=None, max=None, *, out=None) -> Tensor

    Clamps all elements in :attr:`input` into the range `[` :attr:`min`, :attr:`max` `]`.
    Letting min_value and max_value be :attr:`min` and :attr:`max`, respectively, this returns:

    .. math::
        y_i = \min(\max(x_i, \text{min\_value}_i), \text{max\_value}_i)

    If :attr:`min` is ``None``, there is no lower bound.
    Or, if :attr:`max` is ``None`` there is no upper bound.


    .. note::
        If :attr:`min` is greater than :attr:`max` :func:`torch.clamp(..., min, max) <torch.clamp>`
        sets all elements in :attr:`input` to the value of :attr:`max`.

    Args:
        input (Tensor): the input tensor.
        min (Number or Tensor, optional): lower-bound of the range to be clamped to
        max (Number or Tensor, optional): upper-bound of the range to be clamped to

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4)
        >>> a
        tensor([-1.7120,  0.1734, -0.0478, -0.0922])
        >>> torch.clamp(a, min=-0.5, max=0.5)
        tensor([-0.5000,  0.1734, -0.0478, -0.0922])

        >>> min = torch.linspace(-1, 1, steps=4)
        >>> torch.clamp(a, min=min)
        tensor([-1.0000,  0.1734,  0.3333,  1.0000])
    """

@overload
def clamp_(
    input: Tensor,
    min: Tensor | None = None,
    max: Tensor | None = None,
) -> Tensor: ...
@overload
def clamp_(
    input: Tensor,
    min: Number | _complex | None = None,
    max: Number | _complex | None = None,
) -> Tensor: ...
@overload
def clamp_max(
    input: Tensor,
    max: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
@overload
def clamp_max(
    input: Tensor,
    max: Number | _complex,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
@overload
def clamp_max_(input: Tensor, max: Tensor) -> Tensor: ...
@overload
def clamp_max_(input: Tensor, max: Number | _complex) -> Tensor: ...
@overload
def clamp_min(
    input: Tensor,
    min: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
@overload
def clamp_min(
    input: Tensor,
    min: Number | _complex,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
@overload
def clamp_min_(input: Tensor, min: Tensor) -> Tensor: ...
@overload
def clamp_min_(input: Tensor, min: Number | _complex) -> Tensor: ...
@overload
def clip(
    input: Tensor,
    min: Tensor | None = None,
    max: Tensor | None = None,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    clip(input, min=None, max=None, *, out=None) -> Tensor

    Alias for :func:`torch.clamp`.
    """

@overload
def clip(
    input: Tensor,
    min: Number | _complex | None = None,
    max: Number | _complex | None = None,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    clip(input, min=None, max=None, *, out=None) -> Tensor

    Alias for :func:`torch.clamp`.
    """

@overload
def clip_(
    input: Tensor,
    min: Tensor | None = None,
    max: Tensor | None = None,
) -> Tensor: ...
@overload
def clip_(
    input: Tensor,
    min: Number | _complex | None = None,
    max: Number | _complex | None = None,
) -> Tensor: ...
def clone(
    input: Tensor,
    *,
    memory_format: memory_format | None = None,
) -> Tensor:
    r"""
    clone(input, *, memory_format=torch.preserve_format) -> Tensor

    Returns a copy of :attr:`input`.

    .. note::

        This function is differentiable, so gradients will flow back from the
        result of this operation to :attr:`input`. To create a tensor without an
        autograd relationship to :attr:`input` see :meth:`~Tensor.detach`.

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        memory_format (:class:`torch.memory_format`, optional): the desired memory format of
            returned tensor. Default: ``torch.preserve_format``.
    """

def col_indices_copy(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    Performs the same operation as :func:`torch.col_indices`, but all output tensors
    are freshly created instead of aliasing the input.
    """

def column_stack(
    tensors: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    column_stack(tensors, *, out=None) -> Tensor

    Creates a new tensor by horizontally stacking the tensors in :attr:`tensors`.

    Equivalent to ``torch.hstack(tensors)``, except each zero or one dimensional tensor ``t``
    in :attr:`tensors` is first reshaped into a ``(t.numel(), 1)`` column before being stacked horizontally.

    Args:
        tensors (sequence of Tensors): sequence of tensors to concatenate

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.tensor([1, 2, 3])
        >>> b = torch.tensor([4, 5, 6])
        >>> torch.column_stack((a, b))
        tensor([[1, 4],
            [2, 5],
            [3, 6]])
        >>> a = torch.arange(5)
        >>> b = torch.arange(10).reshape(5, 2)
        >>> torch.column_stack((a, b, b))
        tensor([[0, 0, 1, 0, 1],
                [1, 2, 3, 2, 3],
                [2, 4, 5, 4, 5],
                [3, 6, 7, 6, 7],
                [4, 8, 9, 8, 9]])
    """

def combinations(
    input: Tensor,
    r: _int = 2,
    with_replacement: _bool = False,
) -> Tensor:
    r"""
    combinations(input: Tensor, r: int = 2, with_replacement: bool = False) -> seq

    Compute combinations of length :math:`r` of the given tensor. The behavior is similar to
    python's `itertools.combinations` when `with_replacement` is set to `False`, and
    `itertools.combinations_with_replacement` when `with_replacement` is set to `True`.

    Arguments:
        input (Tensor): 1D vector.
        r (int, optional): number of elements to combine
        with_replacement (bool, optional): whether to allow duplication in combination

    Returns:
        Tensor: A tensor equivalent to converting all the input tensors into lists, do
        `itertools.combinations` or `itertools.combinations_with_replacement` on these
        lists, and finally convert the resulting list into tensor.

    Example::

        >>> a = [1, 2, 3]
        >>> list(itertools.combinations(a, r=2))
        [(1, 2), (1, 3), (2, 3)]
        >>> list(itertools.combinations(a, r=3))
        [(1, 2, 3)]
        >>> list(itertools.combinations_with_replacement(a, r=2))
        [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]
        >>> tensor_a = torch.tensor(a)
        >>> torch.combinations(tensor_a)
        tensor([[1, 2],
                [1, 3],
                [2, 3]])
        >>> torch.combinations(tensor_a, r=3)
        tensor([[1, 2, 3]])
        >>> torch.combinations(tensor_a, with_replacement=True)
        tensor([[1, 1],
                [1, 2],
                [1, 3],
                [2, 2],
                [2, 3],
                [3, 3]])
    """

def complex(
    real: Tensor,
    imag: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    complex(real, imag, *, out=None) -> Tensor

    Constructs a complex tensor with its real part equal to :attr:`real` and its
    imaginary part equal to :attr:`imag`.

    Args:
        real (Tensor): The real part of the complex tensor. Must be half, float or double.
        imag (Tensor): The imaginary part of the complex tensor. Must be same dtype
            as :attr:`real`.

    Keyword args:
        out (Tensor): If the inputs are ``torch.float32``, must be
            ``torch.complex64``. If the inputs are ``torch.float64``, must be
            ``torch.complex128``.

    Example::

        >>> real = torch.tensor([1, 2], dtype=torch.float32)
        >>> imag = torch.tensor([3, 4], dtype=torch.float32)
        >>> z = torch.complex(real, imag)
        >>> z
        tensor([(1.+3.j), (2.+4.j)])
        >>> z.dtype
        torch.complex64
    """

@overload
def concat(
    tensors: tuple[Tensor, ...] | list[Tensor] | None,
    dim: _int = 0,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    concat(tensors, dim=0, *, out=None) -> Tensor

    Alias of :func:`torch.cat`.
    """

@overload
def concat(
    tensors: tuple[Tensor, ...] | list[Tensor] | None,
    dim: str | EllipsisType | None,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    concat(tensors, dim=0, *, out=None) -> Tensor

    Alias of :func:`torch.cat`.
    """

@overload
def concatenate(
    tensors: tuple[Tensor, ...] | list[Tensor] | None,
    dim: _int = 0,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    concatenate(tensors, axis=0, out=None) -> Tensor

    Alias of :func:`torch.cat`.
    """

@overload
def concatenate(
    tensors: tuple[Tensor, ...] | list[Tensor] | None,
    dim: str | EllipsisType | None,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    concatenate(tensors, axis=0, out=None) -> Tensor

    Alias of :func:`torch.cat`.
    """

def conj(input: Tensor) -> Tensor:
    r"""
    conj(input) -> Tensor

    Returns a view of :attr:`input` with a flipped conjugate bit. If :attr:`input` has a non-complex dtype,
    this function just returns :attr:`input`.

    .. note::
        :func:`torch.conj` performs a lazy conjugation, but the actual conjugated tensor can be materialized
        at any time using :func:`torch.resolve_conj`.

    .. warning:: In the future, :func:`torch.conj` may return a non-writeable view for an :attr:`input` of
                 non-complex dtype. It's recommended that programs not modify the tensor returned by :func:`torch.conj_physical`
                 when :attr:`input` is of non-complex dtype to be compatible with this change.

    Args:
        input (Tensor): the input tensor.

    Example::

        >>> x = torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j])
        >>> x.is_conj()
        False
        >>> y = torch.conj(x)
        >>> y.is_conj()
        True
    """

def conj_physical(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    conj_physical(input, *, out=None) -> Tensor

    Computes the element-wise conjugate of the given :attr:`input` tensor.
    If :attr:`input` has a non-complex dtype, this function just returns :attr:`input`.

    .. note::
       This performs the conjugate operation regardless of the fact conjugate bit is set or not.

    .. warning:: In the future, :func:`torch.conj_physical` may return a non-writeable view for an :attr:`input` of
                 non-complex dtype. It's recommended that programs not modify the tensor returned by :func:`torch.conj_physical`
                 when :attr:`input` is of non-complex dtype to be compatible with this change.

    .. math::
        \text{out}_{i} = conj(\text{input}_{i})

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.conj_physical(torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j]))
        tensor([-1 - 1j, -2 - 2j, 3 + 3j])
    """

def conj_physical_(input: Tensor) -> Tensor: ...
def constant_pad_nd(
    input: Tensor,
    pad: Sequence[_int | SymInt],
    value: Number | _complex = 0,
) -> Tensor: ...
@overload
def conv1d(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None = None,
    stride: _int | SymInt | Sequence[_int | SymInt] = 1,
    padding: _int | SymInt | Sequence[_int | SymInt] = 0,
    dilation: _int | SymInt | Sequence[_int | SymInt] = 1,
    groups: _int | SymInt = 1,
) -> Tensor: ...
@overload
def conv1d(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None = None,
    stride: _int | SymInt | Sequence[_int | SymInt] = 1,
    padding: str = "valid",
    dilation: _int | SymInt | Sequence[_int | SymInt] = 1,
    groups: _int | SymInt = 1,
) -> Tensor: ...
@overload
def conv2d(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None = None,
    stride: _int | SymInt | Sequence[_int | SymInt] = 1,
    padding: _int | SymInt | Sequence[_int | SymInt] = 0,
    dilation: _int | SymInt | Sequence[_int | SymInt] = 1,
    groups: _int | SymInt = 1,
) -> Tensor: ...
@overload
def conv2d(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None = None,
    stride: _int | SymInt | Sequence[_int | SymInt] = 1,
    padding: str = "valid",
    dilation: _int | SymInt | Sequence[_int | SymInt] = 1,
    groups: _int | SymInt = 1,
) -> Tensor: ...
@overload
def conv3d(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None = None,
    stride: _int | SymInt | Sequence[_int | SymInt] = 1,
    padding: _int | SymInt | Sequence[_int | SymInt] = 0,
    dilation: _int | SymInt | Sequence[_int | SymInt] = 1,
    groups: _int | SymInt = 1,
) -> Tensor: ...
@overload
def conv3d(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None = None,
    stride: _int | SymInt | Sequence[_int | SymInt] = 1,
    padding: str = "valid",
    dilation: _int | SymInt | Sequence[_int | SymInt] = 1,
    groups: _int | SymInt = 1,
) -> Tensor: ...
def conv_tbc(
    input: Tensor,
    weight: Tensor,
    bias: Tensor,
    pad: _int = 0,
) -> Tensor: ...
def conv_transpose1d(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None = None,
    stride: _int | SymInt | Sequence[_int | SymInt] = 1,
    padding: _int | SymInt | Sequence[_int | SymInt] = 0,
    output_padding: _int | SymInt | Sequence[_int | SymInt] = 0,
    groups: _int | SymInt = 1,
    dilation: _int | SymInt | Sequence[_int | SymInt] = 1,
) -> Tensor: ...
def conv_transpose2d(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None = None,
    stride: _int | SymInt | Sequence[_int | SymInt] = 1,
    padding: _int | SymInt | Sequence[_int | SymInt] = 0,
    output_padding: _int | SymInt | Sequence[_int | SymInt] = 0,
    groups: _int | SymInt = 1,
    dilation: _int | SymInt | Sequence[_int | SymInt] = 1,
) -> Tensor: ...
def conv_transpose3d(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None = None,
    stride: _int | SymInt | Sequence[_int | SymInt] = 1,
    padding: _int | SymInt | Sequence[_int | SymInt] = 0,
    output_padding: _int | SymInt | Sequence[_int | SymInt] = 0,
    groups: _int | SymInt = 1,
    dilation: _int | SymInt | Sequence[_int | SymInt] = 1,
) -> Tensor: ...
def convolution(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None,
    stride: Sequence[_int | SymInt],
    padding: Sequence[_int | SymInt],
    dilation: Sequence[_int | SymInt],
    transposed: _bool,
    output_padding: Sequence[_int | SymInt],
    groups: _int | SymInt,
) -> Tensor: ...
@overload
def copysign(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    copysign(input, other, *, out=None) -> Tensor

    Create a new floating-point tensor with the magnitude of :attr:`input` and the sign of :attr:`other`, elementwise.

    .. math::
        \text{out}_{i} = \begin{cases}
            -|\text{input}_{i}| & \text{if } \text{other}_{i} \leq -0.0 \\
             |\text{input}_{i}| & \text{if } \text{other}_{i} \geq 0.0 \\
        \end{cases}


    Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
    and integer and float inputs.

    Args:
        input (Tensor): magnitudes.
        other (Tensor or Number): contains value(s) whose signbit(s) are
            applied to the magnitudes in :attr:`input`.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(5)
        >>> a
        tensor([-1.2557, -0.0026, -0.5387,  0.4740, -0.9244])
        >>> torch.copysign(a, 1)
        tensor([1.2557, 0.0026, 0.5387, 0.4740, 0.9244])
        >>> a = torch.randn(4, 4)
        >>> a
        tensor([[ 0.7079,  0.2778, -1.0249,  0.5719],
                [-0.0059, -0.2600, -0.4475, -1.3948],
                [ 0.3667, -0.9567, -2.5757, -0.1751],
                [ 0.2046, -0.0742,  0.2998, -0.1054]])
        >>> b = torch.randn(4)
        tensor([ 0.2373,  0.3120,  0.3190, -1.1128])
        >>> torch.copysign(a, b)
        tensor([[ 0.7079,  0.2778,  1.0249, -0.5719],
                [ 0.0059,  0.2600,  0.4475, -1.3948],
                [ 0.3667,  0.9567,  2.5757, -0.1751],
                [ 0.2046,  0.0742,  0.2998, -0.1054]])
        >>> a = torch.tensor([1.])
        >>> b = torch.tensor([-0.])
        >>> torch.copysign(a, b)
        tensor([-1.])

    .. note::
        copysign handles signed zeros. If the other argument has a negative zero (-0),
        the corresponding output value will be negative.
    """

@overload
def copysign(
    input: Tensor,
    other: Number | _complex,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    copysign(input, other, *, out=None) -> Tensor

    Create a new floating-point tensor with the magnitude of :attr:`input` and the sign of :attr:`other`, elementwise.

    .. math::
        \text{out}_{i} = \begin{cases}
            -|\text{input}_{i}| & \text{if } \text{other}_{i} \leq -0.0 \\
             |\text{input}_{i}| & \text{if } \text{other}_{i} \geq 0.0 \\
        \end{cases}


    Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
    and integer and float inputs.

    Args:
        input (Tensor): magnitudes.
        other (Tensor or Number): contains value(s) whose signbit(s) are
            applied to the magnitudes in :attr:`input`.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(5)
        >>> a
        tensor([-1.2557, -0.0026, -0.5387,  0.4740, -0.9244])
        >>> torch.copysign(a, 1)
        tensor([1.2557, 0.0026, 0.5387, 0.4740, 0.9244])
        >>> a = torch.randn(4, 4)
        >>> a
        tensor([[ 0.7079,  0.2778, -1.0249,  0.5719],
                [-0.0059, -0.2600, -0.4475, -1.3948],
                [ 0.3667, -0.9567, -2.5757, -0.1751],
                [ 0.2046, -0.0742,  0.2998, -0.1054]])
        >>> b = torch.randn(4)
        tensor([ 0.2373,  0.3120,  0.3190, -1.1128])
        >>> torch.copysign(a, b)
        tensor([[ 0.7079,  0.2778,  1.0249, -0.5719],
                [ 0.0059,  0.2600,  0.4475, -1.3948],
                [ 0.3667,  0.9567,  2.5757, -0.1751],
                [ 0.2046,  0.0742,  0.2998, -0.1054]])
        >>> a = torch.tensor([1.])
        >>> b = torch.tensor([-0.])
        >>> torch.copysign(a, b)
        tensor([-1.])

    .. note::
        copysign handles signed zeros. If the other argument has a negative zero (-0),
        the corresponding output value will be negative.
    """

def corrcoef(input: Tensor) -> Tensor:
    r"""
    corrcoef(input) -> Tensor

    Estimates the Pearson product-moment correlation coefficient matrix of the variables given by the :attr:`input` matrix,
    where rows are the variables and columns are the observations.

    .. note::

        The correlation coefficient matrix R is computed using the covariance matrix C as given by
        :math:`R_{ij} = \frac{ C_{ij} } { \sqrt{ C_{ii} * C_{jj} } }`

    .. note::

        Due to floating point rounding, the resulting array may not be Hermitian and its diagonal elements may not be 1.
        The real and imaginary values are clipped to the interval [-1, 1] in an attempt to improve this situation.

    Args:
        input (Tensor): A 2D matrix containing multiple variables and observations, or a
            Scalar or 1D vector representing a single variable.

    Returns:
        (Tensor) The correlation coefficient matrix of the variables.

    .. seealso::

            :func:`torch.cov` covariance matrix.

    Example::

        >>> x = torch.tensor([[0, 1, 2], [2, 1, 0]])
        >>> torch.corrcoef(x)
        tensor([[ 1., -1.],
                [-1.,  1.]])
        >>> x = torch.randn(2, 4)
        >>> x
        tensor([[-0.2678, -0.0908, -0.3766,  0.2780],
                [-0.5812,  0.1535,  0.2387,  0.2350]])
        >>> torch.corrcoef(x)
        tensor([[1.0000, 0.3582],
                [0.3582, 1.0000]])
        >>> torch.corrcoef(x[0])
        tensor(1.)
    """

def cos(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    cos(input, *, out=None) -> Tensor

    Returns a new tensor with the cosine  of the elements of :attr:`input`.

    .. math::
        \text{out}_{i} = \cos(\text{input}_{i})

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4)
        >>> a
        tensor([ 1.4309,  1.2706, -0.8562,  0.9796])
        >>> torch.cos(a)
        tensor([ 0.1395,  0.2957,  0.6553,  0.5574])
    """

def cos_(input: Tensor) -> Tensor: ...
def cosh(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    cosh(input, *, out=None) -> Tensor

    Returns a new tensor with the hyperbolic cosine  of the elements of
    :attr:`input`.

    .. math::
        \text{out}_{i} = \cosh(\text{input}_{i})

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4)
        >>> a
        tensor([ 0.1632,  1.1835, -0.6979, -0.7325])
        >>> torch.cosh(a)
        tensor([ 1.0133,  1.7860,  1.2536,  1.2805])

    .. note::
       When :attr:`input` is on the CPU, the implementation of torch.cosh may use
       the Sleef library, which rounds very large results to infinity or negative
       infinity. See `here <https://sleef.org/purec.xhtml>`_ for details.
    """

def cosh_(input: Tensor) -> Tensor: ...
def cosine_embedding_loss(
    input1: Tensor,
    input2: Tensor,
    target: Tensor,
    margin: _float = 0.0,
    reduction: _int = 1,
) -> Tensor: ...
def cosine_similarity(
    x1: Tensor,
    x2: Tensor,
    dim: _int = 1,
    eps: _float = 1e-08,
) -> Tensor: ...
@overload
def count_nonzero(input: Tensor, dim: _int | None = None) -> Tensor:
    r"""
    count_nonzero(input, dim=None) -> Tensor

    Counts the number of non-zero values in the tensor :attr:`input` along the given :attr:`dim`.
    If no dim is specified then all non-zeros in the tensor are counted.

    Args:
        input (Tensor): the input tensor.
        dim (int or tuple of ints, optional): Dim or tuple of dims along which to count non-zeros.

    Example::

        >>> x = torch.zeros(3,3)
        >>> x[torch.randn(3,3) > 0.5] = 1
        >>> x
        tensor([[0., 1., 1.],
                [0., 0., 0.],
                [0., 0., 1.]])
        >>> torch.count_nonzero(x)
        tensor(3)
        >>> torch.count_nonzero(x, dim=0)
        tensor([0, 1, 2])
    """

@overload
def count_nonzero(input: Tensor, dim: _size) -> Tensor:
    r"""
    count_nonzero(input, dim=None) -> Tensor

    Counts the number of non-zero values in the tensor :attr:`input` along the given :attr:`dim`.
    If no dim is specified then all non-zeros in the tensor are counted.

    Args:
        input (Tensor): the input tensor.
        dim (int or tuple of ints, optional): Dim or tuple of dims along which to count non-zeros.

    Example::

        >>> x = torch.zeros(3,3)
        >>> x[torch.randn(3,3) > 0.5] = 1
        >>> x
        tensor([[0., 1., 1.],
                [0., 0., 0.],
                [0., 0., 1.]])
        >>> torch.count_nonzero(x)
        tensor(3)
        >>> torch.count_nonzero(x, dim=0)
        tensor([0, 1, 2])
    """

def cov(
    input: Tensor,
    *,
    correction: _int = 1,
    fweights: Tensor | None = None,
    aweights: Tensor | None = None,
) -> Tensor:
    r"""
    cov(input, *, correction=1, fweights=None, aweights=None) -> Tensor

    Estimates the covariance matrix of the variables given by the :attr:`input` matrix, where rows are
    the variables and columns are the observations.

    A covariance matrix is a square matrix giving the covariance of each pair of variables. The diagonal contains
    the variance of each variable (covariance of a variable with itself). By definition, if :attr:`input` represents
    a single variable (Scalar or 1D) then its variance is returned.

    The sample covariance of the variables :math:`x` and :math:`y` is given by:

    .. math::
        \text{cov}(x,y) = \frac{\sum^{N}_{i = 1}(x_{i} - \bar{x})(y_{i} - \bar{y})}{\max(0,~N~-~\delta N)}

    where :math:`\bar{x}` and :math:`\bar{y}` are the simple means of the :math:`x` and :math:`y` respectively, and
    :math:`\delta N` is the :attr:`correction`.

    If :attr:`fweights` and/or :attr:`aweights` are provided, the weighted covariance
    is calculated, which is given by:

    .. math::
        \text{cov}_w(x,y) = \frac{\sum^{N}_{i = 1}w_i(x_{i} - \mu_x^*)(y_{i} - \mu_y^*)}
        {\max(0,~\sum^{N}_{i = 1}w_i~-~\frac{\sum^{N}_{i = 1}w_ia_i}{\sum^{N}_{i = 1}w_i}~\delta N)}

    where :math:`w` denotes :attr:`fweights` or :attr:`aweights` (``f`` and ``a`` for brevity) based on whichever is
    provided, or :math:`w = f \times a` if both are provided, and
    :math:`\mu_x^* = \frac{\sum^{N}_{i = 1}w_ix_{i} }{\sum^{N}_{i = 1}w_i}` is the weighted mean of the variable. If not
    provided, ``f`` and/or ``a`` can be seen as a :math:`\mathbb{1}` vector of appropriate size.

    Args:
        input (Tensor): A 2D matrix containing multiple variables and observations, or a
            Scalar or 1D vector representing a single variable.

    Keyword Args:
        correction (int, optional): difference between the sample size and sample degrees of freedom.
            Defaults to Bessel's correction, ``correction = 1`` which returns the unbiased estimate,
            even if both :attr:`fweights` and :attr:`aweights` are specified. ``correction = 0``
            will return the simple average. Defaults to ``1``.
        fweights (tensor, optional): A Scalar or 1D tensor of observation vector frequencies representing the number of
            times each observation should be repeated. Its numel must equal the number of columns of :attr:`input`.
            Must have integral dtype. Ignored if ``None``. Defaults to ``None``.
        aweights (tensor, optional): A Scalar or 1D array of observation vector weights.
            These relative weights are typically large for observations considered "important" and smaller for
            observations considered less "important". Its numel must equal the number of columns of :attr:`input`.
            Must have floating point dtype. Ignored if ``None``. Defaults to ``None``.

    Returns:
        (Tensor) The covariance matrix of the variables.

    .. seealso::

            :func:`torch.corrcoef` normalized covariance matrix.

    Example::

        >>> x = torch.tensor([[0, 2], [1, 1], [2, 0]]).T
        >>> x
        tensor([[0, 1, 2],
                [2, 1, 0]])
        >>> torch.cov(x)
        tensor([[ 1., -1.],
                [-1.,  1.]])
        >>> torch.cov(x, correction=0)
        tensor([[ 0.6667, -0.6667],
                [-0.6667,  0.6667]])
        >>> fw = torch.randint(1, 10, (3,))
        >>> fw
        tensor([1, 6, 9])
        >>> aw = torch.rand(3)
        >>> aw
        tensor([0.4282, 0.0255, 0.4144])
        >>> torch.cov(x, fweights=fw, aweights=aw)
        tensor([[ 0.4169, -0.4169],
                [-0.4169,  0.4169]])
    """

def cross(
    input: Tensor,
    other: Tensor,
    dim: _int | None = None,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    cross(input, other, dim=None, *, out=None) -> Tensor


    Returns the cross product of vectors in dimension :attr:`dim` of :attr:`input`
    and :attr:`other`.

    Supports input of float, double, cfloat and cdouble dtypes. Also supports batches
    of vectors, for which it computes the product along the dimension :attr:`dim`.
    In this case, the output has the same batch dimensions as the inputs.

    .. warning::
        If :attr:`dim` is not given, it defaults to the first dimension found
        with the size 3. Note that this might be unexpected.

        This behavior is deprecated and will be changed to match that of :func:`torch.linalg.cross`
        in a future release.

    .. seealso::
            :func:`torch.linalg.cross` which has dim=-1 as default.


    Args:
        input (Tensor): the input tensor.
        other (Tensor): the second input tensor
        dim  (int, optional): the dimension to take the cross-product in.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4, 3)
        >>> a
        tensor([[-0.3956,  1.1455,  1.6895],
                [-0.5849,  1.3672,  0.3599],
                [-1.1626,  0.7180, -0.0521],
                [-0.1339,  0.9902, -2.0225]])
        >>> b = torch.randn(4, 3)
        >>> b
        tensor([[-0.0257, -1.4725, -1.2251],
                [-1.1479, -0.7005, -1.9757],
                [-1.3904,  0.3726, -1.1836],
                [-0.9688, -0.7153,  0.2159]])
        >>> torch.cross(a, b, dim=1)
        tensor([[ 1.0844, -0.5281,  0.6120],
                [-2.4490, -1.5687,  1.9792],
                [-0.8304, -1.3037,  0.5650],
                [-1.2329,  1.9883,  1.0551]])
        >>> torch.cross(a, b)
        tensor([[ 1.0844, -0.5281,  0.6120],
                [-2.4490, -1.5687,  1.9792],
                [-0.8304, -1.3037,  0.5650],
                [-1.2329,  1.9883,  1.0551]])
    """

def crow_indices_copy(
    input: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    Performs the same operation as :func:`torch.crow_indices`, but all output tensors
    are freshly created instead of aliasing the input.
    """

@overload
def ctc_loss(
    log_probs: Tensor,
    targets: Tensor,
    input_lengths: _size,
    target_lengths: _size,
    blank: _int = 0,
    reduction: _int = 1,
    zero_infinity: _bool = False,
) -> Tensor: ...
@overload
def ctc_loss(
    log_probs: Tensor,
    targets: Tensor,
    input_lengths: Tensor,
    target_lengths: Tensor,
    blank: _int = 0,
    reduction: _int = 1,
    zero_infinity: _bool = False,
) -> Tensor: ...
def cudnn_affine_grid_generator(
    theta: Tensor,
    N: _int,
    C: _int,
    H: _int,
    W: _int,
) -> Tensor: ...
def cudnn_batch_norm(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None,
    running_mean: Tensor | None,
    running_var: Tensor | None,
    training: _bool,
    exponential_average_factor: _float,
    epsilon: _float,
) -> tuple[Tensor, Tensor, Tensor, Tensor]: ...
def cudnn_convolution(
    input: Tensor,
    weight: Tensor,
    padding: Sequence[_int | SymInt],
    stride: Sequence[_int | SymInt],
    dilation: Sequence[_int | SymInt],
    groups: _int | SymInt,
    benchmark: _bool,
    deterministic: _bool,
    allow_tf32: _bool,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def cudnn_convolution_add_relu(
    input: Tensor,
    weight: Tensor,
    z: Tensor,
    alpha: Number | _complex | None,
    bias: Tensor | None,
    stride: Sequence[_int | SymInt],
    padding: Sequence[_int | SymInt],
    dilation: Sequence[_int | SymInt],
    groups: _int | SymInt,
) -> Tensor: ...
def cudnn_convolution_relu(
    input: Tensor,
    weight: Tensor,
    bias: Tensor | None,
    stride: Sequence[_int | SymInt],
    padding: Sequence[_int | SymInt],
    dilation: Sequence[_int | SymInt],
    groups: _int | SymInt,
) -> Tensor: ...
def cudnn_convolution_transpose(
    input: Tensor,
    weight: Tensor,
    padding: Sequence[_int | SymInt],
    output_padding: Sequence[_int | SymInt],
    stride: Sequence[_int | SymInt],
    dilation: Sequence[_int | SymInt],
    groups: _int | SymInt,
    benchmark: _bool,
    deterministic: _bool,
    allow_tf32: _bool,
) -> Tensor: ...
def cudnn_grid_sampler(input: Tensor, grid: Tensor) -> Tensor: ...
def cudnn_is_acceptable(input: Tensor) -> _bool: ...
@overload
def cummax(
    input: Tensor,
    dim: _int,
    *,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> torch.return_types.cummax:
    r"""
    cummax(input, dim, *, out=None) -> (Tensor, LongTensor)
    Returns a namedtuple ``(values, indices)`` where ``values`` is the cumulative maximum of
    elements of :attr:`input` in the dimension :attr:`dim`. And ``indices`` is the index
    location of each maximum value found in the dimension :attr:`dim`.

    .. math::
        y_i = max(x_1, x_2, x_3, \dots, x_i)

    Args:
        input (Tensor): the input tensor.
        dim  (int): the dimension to do the operation over

    Keyword args:
        out (tuple, optional): the result tuple of two output tensors (values, indices)

    Example::

        >>> a = torch.randn(10)
        >>> a
        tensor([-0.3449, -1.5447,  0.0685, -1.5104, -1.1706,  0.2259,  1.4696, -1.3284,
             1.9946, -0.8209])
        >>> torch.cummax(a, dim=0)
        torch.return_types.cummax(
            values=tensor([-0.3449, -0.3449,  0.0685,  0.0685,  0.0685,  0.2259,  1.4696,  1.4696,
             1.9946,  1.9946]),
            indices=tensor([0, 0, 2, 2, 2, 5, 6, 6, 8, 8]))
    """

@overload
def cummax(
    input: Tensor,
    dim: str | EllipsisType | None,
    *,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> torch.return_types.cummax:
    r"""
    cummax(input, dim, *, out=None) -> (Tensor, LongTensor)
    Returns a namedtuple ``(values, indices)`` where ``values`` is the cumulative maximum of
    elements of :attr:`input` in the dimension :attr:`dim`. And ``indices`` is the index
    location of each maximum value found in the dimension :attr:`dim`.

    .. math::
        y_i = max(x_1, x_2, x_3, \dots, x_i)

    Args:
        input (Tensor): the input tensor.
        dim  (int): the dimension to do the operation over

    Keyword args:
        out (tuple, optional): the result tuple of two output tensors (values, indices)

    Example::

        >>> a = torch.randn(10)
        >>> a
        tensor([-0.3449, -1.5447,  0.0685, -1.5104, -1.1706,  0.2259,  1.4696, -1.3284,
             1.9946, -0.8209])
        >>> torch.cummax(a, dim=0)
        torch.return_types.cummax(
            values=tensor([-0.3449, -0.3449,  0.0685,  0.0685,  0.0685,  0.2259,  1.4696,  1.4696,
             1.9946,  1.9946]),
            indices=tensor([0, 0, 2, 2, 2, 5, 6, 6, 8, 8]))
    """

@overload
def cummin(
    input: Tensor,
    dim: _int,
    *,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> torch.return_types.cummin:
    r"""
    cummin(input, dim, *, out=None) -> (Tensor, LongTensor)
    Returns a namedtuple ``(values, indices)`` where ``values`` is the cumulative minimum of
    elements of :attr:`input` in the dimension :attr:`dim`. And ``indices`` is the index
    location of each maximum value found in the dimension :attr:`dim`.

    .. math::
        y_i = min(x_1, x_2, x_3, \dots, x_i)

    Args:
        input (Tensor): the input tensor.
        dim  (int): the dimension to do the operation over

    Keyword args:
        out (tuple, optional): the result tuple of two output tensors (values, indices)

    Example::

        >>> a = torch.randn(10)
        >>> a
        tensor([-0.2284, -0.6628,  0.0975,  0.2680, -1.3298, -0.4220, -0.3885,  1.1762,
             0.9165,  1.6684])
        >>> torch.cummin(a, dim=0)
        torch.return_types.cummin(
            values=tensor([-0.2284, -0.6628, -0.6628, -0.6628, -1.3298, -1.3298, -1.3298, -1.3298,
            -1.3298, -1.3298]),
            indices=tensor([0, 1, 1, 1, 4, 4, 4, 4, 4, 4]))
    """

@overload
def cummin(
    input: Tensor,
    dim: str | EllipsisType | None,
    *,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> torch.return_types.cummin:
    r"""
    cummin(input, dim, *, out=None) -> (Tensor, LongTensor)
    Returns a namedtuple ``(values, indices)`` where ``values`` is the cumulative minimum of
    elements of :attr:`input` in the dimension :attr:`dim`. And ``indices`` is the index
    location of each maximum value found in the dimension :attr:`dim`.

    .. math::
        y_i = min(x_1, x_2, x_3, \dots, x_i)

    Args:
        input (Tensor): the input tensor.
        dim  (int): the dimension to do the operation over

    Keyword args:
        out (tuple, optional): the result tuple of two output tensors (values, indices)

    Example::

        >>> a = torch.randn(10)
        >>> a
        tensor([-0.2284, -0.6628,  0.0975,  0.2680, -1.3298, -0.4220, -0.3885,  1.1762,
             0.9165,  1.6684])
        >>> torch.cummin(a, dim=0)
        torch.return_types.cummin(
            values=tensor([-0.2284, -0.6628, -0.6628, -0.6628, -1.3298, -1.3298, -1.3298, -1.3298,
            -1.3298, -1.3298]),
            indices=tensor([0, 1, 1, 1, 4, 4, 4, 4, 4, 4]))
    """

@overload
def cumprod(
    input: Tensor,
    dim: _int,
    *,
    dtype: _dtype | None = None,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    cumprod(input, dim, *, dtype=None, out=None) -> Tensor

    Returns the cumulative product of elements of :attr:`input` in the dimension
    :attr:`dim`.

    For example, if :attr:`input` is a vector of size N, the result will also be
    a vector of size N, with elements.

    .. math::
        y_i = x_1 \times x_2\times x_3\times \dots \times x_i

    Args:
        input (Tensor): the input tensor.
        dim  (int): the dimension to do the operation over

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            If specified, the input tensor is casted to :attr:`dtype` before the operation
            is performed. This is useful for preventing data type overflows. Default: None.
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(10)
        >>> a
        tensor([ 0.6001,  0.2069, -0.1919,  0.9792,  0.6727,  1.0062,  0.4126,
                -0.2129, -0.4206,  0.1968])
        >>> torch.cumprod(a, dim=0)
        tensor([ 0.6001,  0.1241, -0.0238, -0.0233, -0.0157, -0.0158, -0.0065,
                 0.0014, -0.0006, -0.0001])

        >>> a[5] = 0.0
        >>> torch.cumprod(a, dim=0)
        tensor([ 0.6001,  0.1241, -0.0238, -0.0233, -0.0157, -0.0000, -0.0000,
                 0.0000, -0.0000, -0.0000])
    """

@overload
def cumprod(
    input: Tensor,
    dim: str | EllipsisType | None,
    *,
    dtype: _dtype | None = None,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    cumprod(input, dim, *, dtype=None, out=None) -> Tensor

    Returns the cumulative product of elements of :attr:`input` in the dimension
    :attr:`dim`.

    For example, if :attr:`input` is a vector of size N, the result will also be
    a vector of size N, with elements.

    .. math::
        y_i = x_1 \times x_2\times x_3\times \dots \times x_i

    Args:
        input (Tensor): the input tensor.
        dim  (int): the dimension to do the operation over

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            If specified, the input tensor is casted to :attr:`dtype` before the operation
            is performed. This is useful for preventing data type overflows. Default: None.
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(10)
        >>> a
        tensor([ 0.6001,  0.2069, -0.1919,  0.9792,  0.6727,  1.0062,  0.4126,
                -0.2129, -0.4206,  0.1968])
        >>> torch.cumprod(a, dim=0)
        tensor([ 0.6001,  0.1241, -0.0238, -0.0233, -0.0157, -0.0158, -0.0065,
                 0.0014, -0.0006, -0.0001])

        >>> a[5] = 0.0
        >>> torch.cumprod(a, dim=0)
        tensor([ 0.6001,  0.1241, -0.0238, -0.0233, -0.0157, -0.0000, -0.0000,
                 0.0000, -0.0000, -0.0000])
    """

@overload
def cumsum(
    input: Tensor,
    dim: _int,
    *,
    dtype: _dtype | None = None,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    cumsum(input, dim, *, dtype=None, out=None) -> Tensor

    Returns the cumulative sum of elements of :attr:`input` in the dimension
    :attr:`dim`.

    For example, if :attr:`input` is a vector of size N, the result will also be
    a vector of size N, with elements.

    .. math::
        y_i = x_1 + x_2 + x_3 + \dots + x_i

    Args:
        input (Tensor): the input tensor.
        dim  (int): the dimension to do the operation over

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            If specified, the input tensor is casted to :attr:`dtype` before the operation
            is performed. This is useful for preventing data type overflows. Default: None.
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randint(1, 20, (10,))
        >>> a
        tensor([13,  7,  3, 10, 13,  3, 15, 10,  9, 10])
        >>> torch.cumsum(a, dim=0)
        tensor([13, 20, 23, 33, 46, 49, 64, 74, 83, 93])
    """

@overload
def cumsum(
    input: Tensor,
    dim: str | EllipsisType | None,
    *,
    dtype: _dtype | None = None,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    cumsum(input, dim, *, dtype=None, out=None) -> Tensor

    Returns the cumulative sum of elements of :attr:`input` in the dimension
    :attr:`dim`.

    For example, if :attr:`input` is a vector of size N, the result will also be
    a vector of size N, with elements.

    .. math::
        y_i = x_1 + x_2 + x_3 + \dots + x_i

    Args:
        input (Tensor): the input tensor.
        dim  (int): the dimension to do the operation over

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            If specified, the input tensor is casted to :attr:`dtype` before the operation
            is performed. This is useful for preventing data type overflows. Default: None.
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randint(1, 20, (10,))
        >>> a
        tensor([13,  7,  3, 10, 13,  3, 15, 10,  9, 10])
        >>> torch.cumsum(a, dim=0)
        tensor([13, 20, 23, 33, 46, 49, 64, 74, 83, 93])
    """

@overload
def cumulative_trapezoid(y: Tensor, x: Tensor, *, dim: _int = -1) -> Tensor:
    r"""
    cumulative_trapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor

    Cumulatively computes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_
    along :attr:`dim`. By default the spacing between elements is assumed to be 1, but
    :attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be
    used to specify arbitrary spacing along :attr:`dim`.

    For more details, please read :func:`torch.trapezoid`. The difference between :func:`torch.trapezoid`
    and this function is that, :func:`torch.trapezoid` returns a value for each integration,
    where as this function returns a cumulative value for every spacing within the integration. This
    is analogous to how `.sum` returns a value and `.cumsum` returns a cumulative sum.

    Arguments:
        y (Tensor): Values to use when computing the trapezoidal rule.
        x (Tensor): If specified, defines spacing between values as specified above.

    Keyword arguments:
        dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`
            are specified then this defaults to 1. Effectively multiplies the result by its value.
        dim (int): The dimension along which to compute the trapezoidal rule.
            The last (inner-most) dimension by default.

    Examples::

        >>> # Cumulatively computes the trapezoidal rule in 1D, spacing is implicitly 1.
        >>> y = torch.tensor([1, 5, 10])
        >>> torch.cumulative_trapezoid(y)
        tensor([3., 10.5])

        >>> # Computes the same trapezoidal rule directly up to each element to verify
        >>> (1 + 5) / 2
        3.0
        >>> (1 + 10 + 10) / 2
        10.5

        >>> # Cumulatively computes the trapezoidal rule in 1D with constant spacing of 2
        >>> # NOTE: the result is the same as before, but multiplied by 2
        >>> torch.cumulative_trapezoid(y, dx=2)
        tensor([6., 21.])

        >>> # Cumulatively computes the trapezoidal rule in 1D with arbitrary spacing
        >>> x = torch.tensor([1, 3, 6])
        >>> torch.cumulative_trapezoid(y, x)
        tensor([6., 28.5])

        >>> # Computes the same trapezoidal rule directly up to each element to verify
        >>> ((3 - 1) * (1 + 5)) / 2
        6.0
        >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2
        28.5

        >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 matrix
        >>> y = torch.arange(9).reshape(3, 3)
        tensor([[0, 1, 2],
                [3, 4, 5],
                [6, 7, 8]])
        >>> torch.cumulative_trapezoid(y)
        tensor([[ 0.5,  2.],
                [ 3.5,  8.],
                [ 6.5, 14.]])

        >>> # Cumulatively computes the trapezoidal rule for each column of the matrix
        >>> torch.cumulative_trapezoid(y, dim=0)
        tensor([[ 1.5,  2.5,  3.5],
                [ 6.0,  8.0, 10.0]])

        >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
        >>> #   with the same arbitrary spacing
        >>> y = torch.ones(3, 3)
        >>> x = torch.tensor([1, 3, 6])
        >>> torch.cumulative_trapezoid(y, x)
        tensor([[2., 5.],
                [2., 5.],
                [2., 5.]])

        >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
        >>> #   with different arbitrary spacing per row
        >>> y = torch.ones(3, 3)
        >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])
        >>> torch.cumulative_trapezoid(y, x)
        tensor([[1., 2.],
                [2., 4.],
                [3., 6.]])
    """

@overload
def cumulative_trapezoid(
    y: Tensor,
    *,
    dx: Number | _complex = 1,
    dim: _int = -1,
) -> Tensor:
    r"""
    cumulative_trapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor

    Cumulatively computes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_
    along :attr:`dim`. By default the spacing between elements is assumed to be 1, but
    :attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be
    used to specify arbitrary spacing along :attr:`dim`.

    For more details, please read :func:`torch.trapezoid`. The difference between :func:`torch.trapezoid`
    and this function is that, :func:`torch.trapezoid` returns a value for each integration,
    where as this function returns a cumulative value for every spacing within the integration. This
    is analogous to how `.sum` returns a value and `.cumsum` returns a cumulative sum.

    Arguments:
        y (Tensor): Values to use when computing the trapezoidal rule.
        x (Tensor): If specified, defines spacing between values as specified above.

    Keyword arguments:
        dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`
            are specified then this defaults to 1. Effectively multiplies the result by its value.
        dim (int): The dimension along which to compute the trapezoidal rule.
            The last (inner-most) dimension by default.

    Examples::

        >>> # Cumulatively computes the trapezoidal rule in 1D, spacing is implicitly 1.
        >>> y = torch.tensor([1, 5, 10])
        >>> torch.cumulative_trapezoid(y)
        tensor([3., 10.5])

        >>> # Computes the same trapezoidal rule directly up to each element to verify
        >>> (1 + 5) / 2
        3.0
        >>> (1 + 10 + 10) / 2
        10.5

        >>> # Cumulatively computes the trapezoidal rule in 1D with constant spacing of 2
        >>> # NOTE: the result is the same as before, but multiplied by 2
        >>> torch.cumulative_trapezoid(y, dx=2)
        tensor([6., 21.])

        >>> # Cumulatively computes the trapezoidal rule in 1D with arbitrary spacing
        >>> x = torch.tensor([1, 3, 6])
        >>> torch.cumulative_trapezoid(y, x)
        tensor([6., 28.5])

        >>> # Computes the same trapezoidal rule directly up to each element to verify
        >>> ((3 - 1) * (1 + 5)) / 2
        6.0
        >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2
        28.5

        >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 matrix
        >>> y = torch.arange(9).reshape(3, 3)
        tensor([[0, 1, 2],
                [3, 4, 5],
                [6, 7, 8]])
        >>> torch.cumulative_trapezoid(y)
        tensor([[ 0.5,  2.],
                [ 3.5,  8.],
                [ 6.5, 14.]])

        >>> # Cumulatively computes the trapezoidal rule for each column of the matrix
        >>> torch.cumulative_trapezoid(y, dim=0)
        tensor([[ 1.5,  2.5,  3.5],
                [ 6.0,  8.0, 10.0]])

        >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
        >>> #   with the same arbitrary spacing
        >>> y = torch.ones(3, 3)
        >>> x = torch.tensor([1, 3, 6])
        >>> torch.cumulative_trapezoid(y, x)
        tensor([[2., 5.],
                [2., 5.],
                [2., 5.]])

        >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix
        >>> #   with different arbitrary spacing per row
        >>> y = torch.ones(3, 3)
        >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])
        >>> torch.cumulative_trapezoid(y, x)
        tensor([[1., 2.],
                [2., 4.],
                [3., 6.]])
    """

def deg2rad(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    deg2rad(input, *, out=None) -> Tensor

    Returns a new tensor with each of the elements of :attr:`input`
    converted from angles in degrees to radians.

    Args:
        input (Tensor): the input tensor.

    Keyword arguments:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.tensor([[180.0, -180.0], [360.0, -360.0], [90.0, -90.0]])
        >>> torch.deg2rad(a)
        tensor([[ 3.1416, -3.1416],
                [ 6.2832, -6.2832],
                [ 1.5708, -1.5708]])
    """

def deg2rad_(input: Tensor) -> Tensor: ...
@overload
def dequantize(input: Tensor) -> Tensor:
    r"""
    dequantize(tensor) -> Tensor

    Returns an fp32 Tensor by dequantizing a quantized Tensor

    Args:
        tensor (Tensor): A quantized Tensor

    .. function:: dequantize(tensors) -> sequence of Tensors
       :noindex:

    Given a list of quantized Tensors, dequantize them and return a list of fp32 Tensors

    Args:
         tensors (sequence of Tensors): A list of quantized Tensors
    """

@overload
def dequantize(
    tensors: tuple[Tensor, ...] | list[Tensor] | None,
) -> tuple[Tensor, ...]:
    r"""
    dequantize(tensor) -> Tensor

    Returns an fp32 Tensor by dequantizing a quantized Tensor

    Args:
        tensor (Tensor): A quantized Tensor

    .. function:: dequantize(tensors) -> sequence of Tensors
       :noindex:

    Given a list of quantized Tensors, dequantize them and return a list of fp32 Tensors

    Args:
         tensors (sequence of Tensors): A list of quantized Tensors
    """

def det(input: Tensor) -> Tensor:
    r"""
    det(input) -> Tensor

    Alias for :func:`torch.linalg.det`
    """

def detach(input: Tensor) -> Tensor: ...
def detach_(input: Tensor) -> Tensor: ...
def detach_copy(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    Performs the same operation as :func:`torch.detach`, but all output tensors
    are freshly created instead of aliasing the input.
    """

def diag(
    input: Tensor,
    diagonal: _int = 0,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    diag(input, diagonal=0, *, out=None) -> Tensor

    - If :attr:`input` is a vector (1-D tensor), then returns a 2-D square tensor
      with the elements of :attr:`input` as the diagonal.
    - If :attr:`input` is a matrix (2-D tensor), then returns a 1-D tensor with
      the diagonal elements of :attr:`input`.

    The argument :attr:`diagonal` controls which diagonal to consider:

    - If :attr:`diagonal` = 0, it is the main diagonal.
    - If :attr:`diagonal` > 0, it is above the main diagonal.
    - If :attr:`diagonal` < 0, it is below the main diagonal.

    Args:
        input (Tensor): the input tensor.
        diagonal (int, optional): the diagonal to consider

    Keyword args:
        out (Tensor, optional): the output tensor.

    .. seealso::

            :func:`torch.diagonal` always returns the diagonal of its input.

            :func:`torch.diagflat` always constructs a tensor with diagonal elements
            specified by the input.

    Examples:

    Get the square matrix where the input vector is the diagonal::

        >>> a = torch.randn(3)
        >>> a
        tensor([ 0.5950,-0.0872, 2.3298])
        >>> torch.diag(a)
        tensor([[ 0.5950, 0.0000, 0.0000],
                [ 0.0000,-0.0872, 0.0000],
                [ 0.0000, 0.0000, 2.3298]])
        >>> torch.diag(a, 1)
        tensor([[ 0.0000, 0.5950, 0.0000, 0.0000],
                [ 0.0000, 0.0000,-0.0872, 0.0000],
                [ 0.0000, 0.0000, 0.0000, 2.3298],
                [ 0.0000, 0.0000, 0.0000, 0.0000]])

    Get the k-th diagonal of a given matrix::

        >>> a = torch.randn(3, 3)
        >>> a
        tensor([[-0.4264, 0.0255,-0.1064],
                [ 0.8795,-0.2429, 0.1374],
                [ 0.1029,-0.6482,-1.6300]])
        >>> torch.diag(a, 0)
        tensor([-0.4264,-0.2429,-1.6300])
        >>> torch.diag(a, 1)
        tensor([ 0.0255, 0.1374])
    """

def diag_embed(
    input: Tensor,
    offset: _int = 0,
    dim1: _int = -2,
    dim2: _int = -1,
) -> Tensor:
    r"""
    diag_embed(input, offset=0, dim1=-2, dim2=-1) -> Tensor

    Creates a tensor whose diagonals of certain 2D planes (specified by
    :attr:`dim1` and :attr:`dim2`) are filled by :attr:`input`.
    To facilitate creating batched diagonal matrices, the 2D planes formed by
    the last two dimensions of the returned tensor are chosen by default.

    The argument :attr:`offset` controls which diagonal to consider:

    - If :attr:`offset` = 0, it is the main diagonal.
    - If :attr:`offset` > 0, it is above the main diagonal.
    - If :attr:`offset` < 0, it is below the main diagonal.

    The size of the new matrix will be calculated to make the specified diagonal
    of the size of the last input dimension.
    Note that for :attr:`offset` other than :math:`0`, the order of :attr:`dim1`
    and :attr:`dim2` matters. Exchanging them is equivalent to changing the
    sign of :attr:`offset`.

    Applying :meth:`torch.diagonal` to the output of this function with
    the same arguments yields a matrix identical to input. However,
    :meth:`torch.diagonal` has different default dimensions, so those
    need to be explicitly specified.

    Args:
        input (Tensor): the input tensor. Must be at least 1-dimensional.
        offset (int, optional): which diagonal to consider. Default: 0
            (main diagonal).
        dim1 (int, optional): first dimension with respect to which to
            take diagonal. Default: -2.
        dim2 (int, optional): second dimension with respect to which to
            take diagonal. Default: -1.

    Example::

        >>> a = torch.randn(2, 3)
        >>> torch.diag_embed(a)
        tensor([[[ 1.5410,  0.0000,  0.0000],
                 [ 0.0000, -0.2934,  0.0000],
                 [ 0.0000,  0.0000, -2.1788]],

                [[ 0.5684,  0.0000,  0.0000],
                 [ 0.0000, -1.0845,  0.0000],
                 [ 0.0000,  0.0000, -1.3986]]])

        >>> torch.diag_embed(a, offset=1, dim1=0, dim2=2)
        tensor([[[ 0.0000,  1.5410,  0.0000,  0.0000],
                 [ 0.0000,  0.5684,  0.0000,  0.0000]],

                [[ 0.0000,  0.0000, -0.2934,  0.0000],
                 [ 0.0000,  0.0000, -1.0845,  0.0000]],

                [[ 0.0000,  0.0000,  0.0000, -2.1788],
                 [ 0.0000,  0.0000,  0.0000, -1.3986]],

                [[ 0.0000,  0.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000,  0.0000,  0.0000]]])
    """

def diagflat(input: Tensor, offset: _int = 0) -> Tensor:
    r"""
    diagflat(input, offset=0) -> Tensor

    - If :attr:`input` is a vector (1-D tensor), then returns a 2-D square tensor
      with the elements of :attr:`input` as the diagonal.
    - If :attr:`input` is a tensor with more than one dimension, then returns a
      2-D tensor with diagonal elements equal to a flattened :attr:`input`.

    The argument :attr:`offset` controls which diagonal to consider:

    - If :attr:`offset` = 0, it is the main diagonal.
    - If :attr:`offset` > 0, it is above the main diagonal.
    - If :attr:`offset` < 0, it is below the main diagonal.

    Args:
        input (Tensor): the input tensor.
        offset (int, optional): the diagonal to consider. Default: 0 (main
            diagonal).

    Examples::

        >>> a = torch.randn(3)
        >>> a
        tensor([-0.2956, -0.9068,  0.1695])
        >>> torch.diagflat(a)
        tensor([[-0.2956,  0.0000,  0.0000],
                [ 0.0000, -0.9068,  0.0000],
                [ 0.0000,  0.0000,  0.1695]])
        >>> torch.diagflat(a, 1)
        tensor([[ 0.0000, -0.2956,  0.0000,  0.0000],
                [ 0.0000,  0.0000, -0.9068,  0.0000],
                [ 0.0000,  0.0000,  0.0000,  0.1695],
                [ 0.0000,  0.0000,  0.0000,  0.0000]])

        >>> a = torch.randn(2, 2)
        >>> a
        tensor([[ 0.2094, -0.3018],
                [-0.1516,  1.9342]])
        >>> torch.diagflat(a)
        tensor([[ 0.2094,  0.0000,  0.0000,  0.0000],
                [ 0.0000, -0.3018,  0.0000,  0.0000],
                [ 0.0000,  0.0000, -0.1516,  0.0000],
                [ 0.0000,  0.0000,  0.0000,  1.9342]])
    """

@overload
def diagonal(
    input: Tensor,
    offset: _int = 0,
    dim1: _int = 0,
    dim2: _int = 1,
) -> Tensor:
    r"""
    diagonal(input, offset=0, dim1=0, dim2=1) -> Tensor

    Returns a partial view of :attr:`input` with the its diagonal elements
    with respect to :attr:`dim1` and :attr:`dim2` appended as a dimension
    at the end of the shape.

    The argument :attr:`offset` controls which diagonal to consider:

    - If :attr:`offset` = 0, it is the main diagonal.
    - If :attr:`offset` > 0, it is above the main diagonal.
    - If :attr:`offset` < 0, it is below the main diagonal.

    Applying :meth:`torch.diag_embed` to the output of this function with
    the same arguments yields a diagonal matrix with the diagonal entries
    of the input. However, :meth:`torch.diag_embed` has different default
    dimensions, so those need to be explicitly specified.

    Args:
        input (Tensor): the input tensor. Must be at least 2-dimensional.
        offset (int, optional): which diagonal to consider. Default: 0
            (main diagonal).
        dim1 (int, optional): first dimension with respect to which to
            take diagonal. Default: 0.
        dim2 (int, optional): second dimension with respect to which to
            take diagonal. Default: 1.

    .. note::  To take a batch diagonal, pass in dim1=-2, dim2=-1.

    Examples::

        >>> a = torch.randn(3, 3)
        >>> a
        tensor([[-1.0854,  1.1431, -0.1752],
                [ 0.8536, -0.0905,  0.0360],
                [ 0.6927, -0.3735, -0.4945]])


        >>> torch.diagonal(a)
        tensor([-1.0854, -0.0905, -0.4945])


        >>> torch.diagonal(a, 1)
        tensor([ 1.1431,  0.0360])

        >>> b = torch.randn(2, 5)
        >>> b
        tensor([[-1.7948, -1.2731, -0.3181,  2.0200, -1.6745],
                [ 1.8262, -1.5049,  0.4114,  1.0704, -1.2607]])

        >>> torch.diagonal(b, 1, 1, 0)
        tensor([1.8262])

        >>> x = torch.randn(2, 5, 4, 2)
        >>> torch.diagonal(x, offset=-1, dim1=1, dim2=2)
        tensor([[[-1.2631,  0.3755, -1.5977, -1.8172],
                 [-1.1065,  1.0401, -0.2235, -0.7938]],

                [[-1.7325, -0.3081,  0.6166,  0.2335],
                 [ 1.0500,  0.7336, -0.3836, -1.1015]]])
    """

@overload
def diagonal(
    input: Tensor,
    *,
    outdim: str | EllipsisType | None,
    dim1: str | EllipsisType | None,
    dim2: str | EllipsisType | None,
    offset: _int = 0,
) -> Tensor:
    r"""
    diagonal(input, offset=0, dim1=0, dim2=1) -> Tensor

    Returns a partial view of :attr:`input` with the its diagonal elements
    with respect to :attr:`dim1` and :attr:`dim2` appended as a dimension
    at the end of the shape.

    The argument :attr:`offset` controls which diagonal to consider:

    - If :attr:`offset` = 0, it is the main diagonal.
    - If :attr:`offset` > 0, it is above the main diagonal.
    - If :attr:`offset` < 0, it is below the main diagonal.

    Applying :meth:`torch.diag_embed` to the output of this function with
    the same arguments yields a diagonal matrix with the diagonal entries
    of the input. However, :meth:`torch.diag_embed` has different default
    dimensions, so those need to be explicitly specified.

    Args:
        input (Tensor): the input tensor. Must be at least 2-dimensional.
        offset (int, optional): which diagonal to consider. Default: 0
            (main diagonal).
        dim1 (int, optional): first dimension with respect to which to
            take diagonal. Default: 0.
        dim2 (int, optional): second dimension with respect to which to
            take diagonal. Default: 1.

    .. note::  To take a batch diagonal, pass in dim1=-2, dim2=-1.

    Examples::

        >>> a = torch.randn(3, 3)
        >>> a
        tensor([[-1.0854,  1.1431, -0.1752],
                [ 0.8536, -0.0905,  0.0360],
                [ 0.6927, -0.3735, -0.4945]])


        >>> torch.diagonal(a)
        tensor([-1.0854, -0.0905, -0.4945])


        >>> torch.diagonal(a, 1)
        tensor([ 1.1431,  0.0360])

        >>> b = torch.randn(2, 5)
        >>> b
        tensor([[-1.7948, -1.2731, -0.3181,  2.0200, -1.6745],
                [ 1.8262, -1.5049,  0.4114,  1.0704, -1.2607]])

        >>> torch.diagonal(b, 1, 1, 0)
        tensor([1.8262])

        >>> x = torch.randn(2, 5, 4, 2)
        >>> torch.diagonal(x, offset=-1, dim1=1, dim2=2)
        tensor([[[-1.2631,  0.3755, -1.5977, -1.8172],
                 [-1.1065,  1.0401, -0.2235, -0.7938]],

                [[-1.7325, -0.3081,  0.6166,  0.2335],
                 [ 1.0500,  0.7336, -0.3836, -1.1015]]])
    """

def diagonal_copy(
    input: Tensor,
    offset: _int = 0,
    dim1: _int = 0,
    dim2: _int = 1,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    Performs the same operation as :func:`torch.diagonal`, but all output tensors
    are freshly created instead of aliasing the input.
    """

def diagonal_scatter(
    input: Tensor,
    src: Tensor,
    offset: _int = 0,
    dim1: _int = 0,
    dim2: _int = 1,
) -> Tensor:
    r"""
    diagonal_scatter(input, src, offset=0, dim1=0, dim2=1) -> Tensor

    Embeds the values of the :attr:`src` tensor into :attr:`input` along
    the diagonal elements of :attr:`input`, with respect to :attr:`dim1`
    and :attr:`dim2`.

    This function returns a tensor with fresh storage; it does not
    return a view.

    The argument :attr:`offset` controls which diagonal to consider:

    - If :attr:`offset` = 0, it is the main diagonal.
    - If :attr:`offset` > 0, it is above the main diagonal.
    - If :attr:`offset` < 0, it is below the main diagonal.

    Args:
        input (Tensor): the input tensor. Must be at least 2-dimensional.
        src (Tensor): the tensor to embed into :attr:`input`.
        offset (int, optional): which diagonal to consider. Default: 0
            (main diagonal).
        dim1 (int, optional): first dimension with respect to which to
            take diagonal. Default: 0.
        dim2 (int, optional): second dimension with respect to which to
            take diagonal. Default: 1.

    .. note::

        :attr:`src` must be of the proper size in order to be embedded
        into :attr:`input`. Specifically, it should have the same shape as
        ``torch.diagonal(input, offset, dim1, dim2)``

    Examples::

        >>> a = torch.zeros(3, 3)
        >>> a
        tensor([[0., 0., 0.],
                [0., 0., 0.],
                [0., 0., 0.]])

        >>> torch.diagonal_scatter(a, torch.ones(3), 0)
        tensor([[1., 0., 0.],
                [0., 1., 0.],
                [0., 0., 1.]])

        >>> torch.diagonal_scatter(a, torch.ones(2), 1)
        tensor([[0., 1., 0.],
                [0., 0., 1.],
                [0., 0., 0.]])
    """

def diff(
    input: Tensor,
    n: _int = 1,
    dim: _int = -1,
    prepend: Tensor | None = None,
    append: Tensor | None = None,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    diff(input, n=1, dim=-1, prepend=None, append=None) -> Tensor

    Computes the n-th forward difference along the given dimension.

    The first-order differences are given by `out[i] = input[i + 1] - input[i]`. Higher-order
    differences are calculated by using :func:`torch.diff` recursively.

    Args:
        input (Tensor): the tensor to compute the differences on
        n (int, optional): the number of times to recursively compute the difference
        dim (int, optional): the dimension to compute the difference along.
            Default is the last dimension.
        prepend, append (Tensor, optional): values to prepend or append to
            :attr:`input` along :attr:`dim` before computing the difference.
            Their dimensions must be equivalent to that of input, and their shapes
            must match input's shape except on :attr:`dim`.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.tensor([1, 3, 2])
        >>> torch.diff(a)
        tensor([ 2, -1])
        >>> b = torch.tensor([4, 5])
        >>> torch.diff(a, append=b)
        tensor([ 2, -1,  2,  1])
        >>> c = torch.tensor([[1, 2, 3], [3, 4, 5]])
        >>> torch.diff(c, dim=0)
        tensor([[2, 2, 2]])
        >>> torch.diff(c, dim=1)
        tensor([[1, 1],
                [1, 1]])
    """

def digamma(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    digamma(input, *, out=None) -> Tensor

    Alias for :func:`torch.special.digamma`.
    """

def dist(input: Tensor, other: Tensor, p: Number | _complex = 2) -> Tensor:
    r"""
    dist(input, other, p=2) -> Tensor

    Returns the p-norm of (:attr:`input` - :attr:`other`)

    The shapes of :attr:`input` and :attr:`other` must be
    :ref:`broadcastable <broadcasting-semantics>`.

    Args:
        input (Tensor): the input tensor.
        other (Tensor): the Right-hand-side input tensor
        p (float, optional): the norm to be computed

    Example::

        >>> x = torch.randn(4)
        >>> x
        tensor([-1.5393, -0.8675,  0.5916,  1.6321])
        >>> y = torch.randn(4)
        >>> y
        tensor([ 0.0967, -1.0511,  0.6295,  0.8360])
        >>> torch.dist(x, y, 3.5)
        tensor(1.6727)
        >>> torch.dist(x, y, 3)
        tensor(1.6973)
        >>> torch.dist(x, y, 0)
        tensor(4.)
        >>> torch.dist(x, y, 1)
        tensor(2.6537)
    """

def div(
    input: Tensor | Number,
    other: Tensor | Number,
    *,
    rounding_mode: str | None = None,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    div(input, other, *, rounding_mode=None, out=None) -> Tensor

    Divides each element of the input ``input`` by the corresponding element of
    :attr:`other`.

    .. math::
        \text{out}_i = \frac{\text{input}_i}{\text{other}_i}

    .. note::
        By default, this performs a "true" division like Python 3.
        See the :attr:`rounding_mode` argument for floor division.

    Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
    :ref:`type promotion <type-promotion-doc>`, and integer, float, and complex inputs.
    Always promotes integer types to the default scalar type.

    Args:
        input (Tensor): the dividend
        other (Tensor or Number): the divisor

    Keyword args:
        rounding_mode (str, optional): Type of rounding applied to the result:

            * None - default behavior. Performs no rounding and, if both :attr:`input` and
              :attr:`other` are integer types, promotes the inputs to the default scalar type.
              Equivalent to true division in Python (the ``/`` operator) and NumPy's ``np.true_divide``.
            * ``"trunc"`` - rounds the results of the division towards zero.
              Equivalent to C-style integer division.
            * ``"floor"`` - rounds the results of the division down.
              Equivalent to floor division in Python (the ``//`` operator) and NumPy's ``np.floor_divide``.

        out (Tensor, optional): the output tensor.

    Examples::

        >>> x = torch.tensor([ 0.3810,  1.2774, -0.2972, -0.3719,  0.4637])
        >>> torch.div(x, 0.5)
        tensor([ 0.7620,  2.5548, -0.5944, -0.7438,  0.9274])

        >>> a = torch.tensor([[-0.3711, -1.9353, -0.4605, -0.2917],
        ...                   [ 0.1815, -1.0111,  0.9805, -1.5923],
        ...                   [ 0.1062,  1.4581,  0.7759, -1.2344],
        ...                   [-0.1830, -0.0313,  1.1908, -1.4757]])
        >>> b = torch.tensor([ 0.8032,  0.2930, -0.8113, -0.2308])
        >>> torch.div(a, b)
        tensor([[-0.4620, -6.6051,  0.5676,  1.2639],
                [ 0.2260, -3.4509, -1.2086,  6.8990],
                [ 0.1322,  4.9764, -0.9564,  5.3484],
                [-0.2278, -0.1068, -1.4678,  6.3938]])

        >>> torch.div(a, b, rounding_mode='trunc')
        tensor([[-0., -6.,  0.,  1.],
                [ 0., -3., -1.,  6.],
                [ 0.,  4., -0.,  5.],
                [-0., -0., -1.,  6.]])

        >>> torch.div(a, b, rounding_mode='floor')
        tensor([[-1., -7.,  0.,  1.],
                [ 0., -4., -2.,  6.],
                [ 0.,  4., -1.,  5.],
                [-1., -1., -2.,  6.]])
    """

@overload
def divide(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    divide(input, other, *, rounding_mode=None, out=None) -> Tensor

    Alias for :func:`torch.div`.
    """

@overload
def divide(
    input: Tensor,
    other: Tensor,
    *,
    rounding_mode: str | None,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    divide(input, other, *, rounding_mode=None, out=None) -> Tensor

    Alias for :func:`torch.div`.
    """

@overload
def divide(
    input: Tensor,
    other: Number | _complex,
    *,
    rounding_mode: str | None,
) -> Tensor:
    r"""
    divide(input, other, *, rounding_mode=None, out=None) -> Tensor

    Alias for :func:`torch.div`.
    """

@overload
def divide(input: Tensor, other: Number | _complex) -> Tensor:
    r"""
    divide(input, other, *, rounding_mode=None, out=None) -> Tensor

    Alias for :func:`torch.div`.
    """

def dot(
    input: Tensor,
    tensor: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    dot(input, tensor, *, out=None) -> Tensor

    Computes the dot product of two 1D tensors.

    .. note::

        Unlike NumPy's dot, torch.dot intentionally only supports computing the dot product
        of two 1D tensors with the same number of elements.

    Args:
        input (Tensor): first tensor in the dot product, must be 1D.
        tensor (Tensor): second tensor in the dot product, must be 1D.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.dot(torch.tensor([2, 3]), torch.tensor([2, 1]))
        tensor(7)

        >>> t1, t2 = torch.tensor([0, 1]), torch.tensor([2, 3])
        >>> torch.dot(t1, t2)
        tensor(3)
    """

def dropout(input: Tensor, p: _float, train: _bool) -> Tensor: ...
def dropout_(input: Tensor, p: _float, train: _bool) -> Tensor: ...
def dsmm(input: Tensor, mat2: Tensor) -> Tensor: ...
@overload
def dsplit(input: Tensor, sections: _int) -> tuple[Tensor, ...]:
    r"""
    dsplit(input, indices_or_sections) -> List of Tensors

    Splits :attr:`input`, a tensor with three or more dimensions, into multiple tensors
    depthwise according to :attr:`indices_or_sections`. Each split is a view of
    :attr:`input`.

    This is equivalent to calling torch.tensor_split(input, indices_or_sections, dim=2)
    (the split dimension is 2), except that if :attr:`indices_or_sections` is an integer
    it must evenly divide the split dimension or a runtime error will be thrown.

    This function is based on NumPy's :func:`numpy.dsplit`.

    Args:
        input (Tensor): tensor to split.
        indices_or_sections (int or list or tuple of ints): See argument in :func:`torch.tensor_split`.

    Example::

        >>> t = torch.arange(16.0).reshape(2, 2, 4)
        >>> t
        tensor([[[ 0.,  1.,  2.,  3.],
                 [ 4.,  5.,  6.,  7.]],
                [[ 8.,  9., 10., 11.],
                 [12., 13., 14., 15.]]])
        >>> torch.dsplit(t, 2)
        (tensor([[[ 0.,  1.],
                [ 4.,  5.]],
               [[ 8.,  9.],
                [12., 13.]]]),
         tensor([[[ 2.,  3.],
                  [ 6.,  7.]],
                 [[10., 11.],
                  [14., 15.]]]))

        >>> torch.dsplit(t, [3, 6])
        (tensor([[[ 0.,  1.,  2.],
                  [ 4.,  5.,  6.]],
                 [[ 8.,  9., 10.],
                  [12., 13., 14.]]]),
         tensor([[[ 3.],
                  [ 7.]],
                 [[11.],
                  [15.]]]),
         tensor([], size=(2, 2, 0)))
    """

@overload
def dsplit(input: Tensor, indices: _size) -> tuple[Tensor, ...]:
    r"""
    dsplit(input, indices_or_sections) -> List of Tensors

    Splits :attr:`input`, a tensor with three or more dimensions, into multiple tensors
    depthwise according to :attr:`indices_or_sections`. Each split is a view of
    :attr:`input`.

    This is equivalent to calling torch.tensor_split(input, indices_or_sections, dim=2)
    (the split dimension is 2), except that if :attr:`indices_or_sections` is an integer
    it must evenly divide the split dimension or a runtime error will be thrown.

    This function is based on NumPy's :func:`numpy.dsplit`.

    Args:
        input (Tensor): tensor to split.
        indices_or_sections (int or list or tuple of ints): See argument in :func:`torch.tensor_split`.

    Example::

        >>> t = torch.arange(16.0).reshape(2, 2, 4)
        >>> t
        tensor([[[ 0.,  1.,  2.,  3.],
                 [ 4.,  5.,  6.,  7.]],
                [[ 8.,  9., 10., 11.],
                 [12., 13., 14., 15.]]])
        >>> torch.dsplit(t, 2)
        (tensor([[[ 0.,  1.],
                [ 4.,  5.]],
               [[ 8.,  9.],
                [12., 13.]]]),
         tensor([[[ 2.,  3.],
                  [ 6.,  7.]],
                 [[10., 11.],
                  [14., 15.]]]))

        >>> torch.dsplit(t, [3, 6])
        (tensor([[[ 0.,  1.,  2.],
                  [ 4.,  5.,  6.]],
                 [[ 8.,  9., 10.],
                  [12., 13., 14.]]]),
         tensor([[[ 3.],
                  [ 7.]],
                 [[11.],
                  [15.]]]),
         tensor([], size=(2, 2, 0)))
    """

def dstack(
    tensors: tuple[Tensor, ...] | list[Tensor] | None,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    dstack(tensors, *, out=None) -> Tensor

    Stack tensors in sequence depthwise (along third axis).

    This is equivalent to concatenation along the third axis after 1-D and 2-D tensors have been reshaped by :func:`torch.atleast_3d`.

    Args:
        tensors (sequence of Tensors): sequence of tensors to concatenate

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.tensor([1, 2, 3])
        >>> b = torch.tensor([4, 5, 6])
        >>> torch.dstack((a,b))
        tensor([[[1, 4],
                 [2, 5],
                 [3, 6]]])
        >>> a = torch.tensor([[1],[2],[3]])
        >>> b = torch.tensor([[4],[5],[6]])
        >>> torch.dstack((a,b))
        tensor([[[1, 4]],
                [[2, 5]],
                [[3, 6]]])
    """

def embedding(
    weight: Tensor,
    indices: Tensor,
    padding_idx: _int | SymInt = -1,
    scale_grad_by_freq: _bool = False,
    sparse: _bool = False,
) -> Tensor: ...
@overload
def embedding_bag(
    weight: Tensor,
    indices: Tensor,
    offsets: Tensor,
    scale_grad_by_freq: _bool,
    mode: _int,
    sparse: _bool,
    per_sample_weights: Tensor | None,
    include_last_offset: _bool,
    padding_idx: _int | None,
) -> tuple[Tensor, Tensor, Tensor, Tensor]: ...
@overload
def embedding_bag(
    weight: Tensor,
    indices: Tensor,
    offsets: Tensor,
    scale_grad_by_freq: _bool = False,
    mode: _int = 0,
    sparse: _bool = False,
    per_sample_weights: Tensor | None = None,
    include_last_offset: _bool = False,
) -> tuple[Tensor, Tensor, Tensor, Tensor]: ...
def embedding_renorm_(
    input: Tensor,
    indices: Tensor,
    max_norm: _float,
    norm_type: _float,
) -> Tensor: ...
@overload
def empty(
    size: Sequence[_int | SymInt],
    *,
    memory_format: memory_format | None = None,
    out: Tensor | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    empty(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False, pin_memory=False, memory_format=torch.contiguous_format) -> Tensor

    Returns a tensor filled with uninitialized data. The shape of the tensor is
    defined by the variable argument :attr:`size`.

    .. note::
        If :func:`torch.use_deterministic_algorithms()` and
        :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
        ``True``, the output tensor is initialized to prevent any possible
        nondeterministic behavior from using the data as an input to an operation.
        Floating point and complex tensors are filled with NaN, and integer tensors
        are filled with the maximum value.

    Args:
        size (int...): a sequence of integers defining the shape of the output tensor.
            Can be a variable number of arguments or a collection like a list or tuple.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.
        pin_memory (bool, optional): If set, returned tensor would be allocated in
            the pinned memory. Works only for CPU tensors. Default: ``False``.
        memory_format (:class:`torch.memory_format`, optional): the desired memory format of
            returned Tensor. Default: ``torch.contiguous_format``.

    Example::

        >>> torch.empty((2,3), dtype=torch.int64)
        tensor([[ 9.4064e+13,  2.8000e+01,  9.3493e+13],
                [ 7.5751e+18,  7.1428e+18,  7.5955e+18]])
    """

@overload
def empty(
    *size: _int | SymInt,
    memory_format: memory_format | None = None,
    out: Tensor | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    empty(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False, pin_memory=False, memory_format=torch.contiguous_format) -> Tensor

    Returns a tensor filled with uninitialized data. The shape of the tensor is
    defined by the variable argument :attr:`size`.

    .. note::
        If :func:`torch.use_deterministic_algorithms()` and
        :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
        ``True``, the output tensor is initialized to prevent any possible
        nondeterministic behavior from using the data as an input to an operation.
        Floating point and complex tensors are filled with NaN, and integer tensors
        are filled with the maximum value.

    Args:
        size (int...): a sequence of integers defining the shape of the output tensor.
            Can be a variable number of arguments or a collection like a list or tuple.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.
        pin_memory (bool, optional): If set, returned tensor would be allocated in
            the pinned memory. Works only for CPU tensors. Default: ``False``.
        memory_format (:class:`torch.memory_format`, optional): the desired memory format of
            returned Tensor. Default: ``torch.contiguous_format``.

    Example::

        >>> torch.empty((2,3), dtype=torch.int64)
        tensor([[ 9.4064e+13,  2.8000e+01,  9.3493e+13],
                [ 7.5751e+18,  7.1428e+18,  7.5955e+18]])
    """

@overload
def empty(
    size: _size,
    *,
    names: Sequence[str | EllipsisType | None] | None,
    memory_format: memory_format | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    empty(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False, pin_memory=False, memory_format=torch.contiguous_format) -> Tensor

    Returns a tensor filled with uninitialized data. The shape of the tensor is
    defined by the variable argument :attr:`size`.

    .. note::
        If :func:`torch.use_deterministic_algorithms()` and
        :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
        ``True``, the output tensor is initialized to prevent any possible
        nondeterministic behavior from using the data as an input to an operation.
        Floating point and complex tensors are filled with NaN, and integer tensors
        are filled with the maximum value.

    Args:
        size (int...): a sequence of integers defining the shape of the output tensor.
            Can be a variable number of arguments or a collection like a list or tuple.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.
        pin_memory (bool, optional): If set, returned tensor would be allocated in
            the pinned memory. Works only for CPU tensors. Default: ``False``.
        memory_format (:class:`torch.memory_format`, optional): the desired memory format of
            returned Tensor. Default: ``torch.contiguous_format``.

    Example::

        >>> torch.empty((2,3), dtype=torch.int64)
        tensor([[ 9.4064e+13,  2.8000e+01,  9.3493e+13],
                [ 7.5751e+18,  7.1428e+18,  7.5955e+18]])
    """

@overload
def empty(
    *size: _int,
    names: Sequence[str | EllipsisType | None] | None,
    memory_format: memory_format | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    empty(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False, pin_memory=False, memory_format=torch.contiguous_format) -> Tensor

    Returns a tensor filled with uninitialized data. The shape of the tensor is
    defined by the variable argument :attr:`size`.

    .. note::
        If :func:`torch.use_deterministic_algorithms()` and
        :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
        ``True``, the output tensor is initialized to prevent any possible
        nondeterministic behavior from using the data as an input to an operation.
        Floating point and complex tensors are filled with NaN, and integer tensors
        are filled with the maximum value.

    Args:
        size (int...): a sequence of integers defining the shape of the output tensor.
            Can be a variable number of arguments or a collection like a list or tuple.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.
        pin_memory (bool, optional): If set, returned tensor would be allocated in
            the pinned memory. Works only for CPU tensors. Default: ``False``.
        memory_format (:class:`torch.memory_format`, optional): the desired memory format of
            returned Tensor. Default: ``torch.contiguous_format``.

    Example::

        >>> torch.empty((2,3), dtype=torch.int64)
        tensor([[ 9.4064e+13,  2.8000e+01,  9.3493e+13],
                [ 7.5751e+18,  7.1428e+18,  7.5955e+18]])
    """

def empty_like(
    input: Tensor,
    *,
    memory_format: memory_format | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    empty_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

    Returns an uninitialized tensor with the same size as :attr:`input`.
    ``torch.empty_like(input)`` is equivalent to
    ``torch.empty(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.

    .. note::
        If :func:`torch.use_deterministic_algorithms()` and
        :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
        ``True``, the output tensor is initialized to prevent any possible
        nondeterministic behavior from using the data as an input to an operation.
        Floating point and complex tensors are filled with NaN, and integer tensors
        are filled with the maximum value.

    Args:
        input (Tensor): the size of :attr:`input` will determine size of the output tensor.

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
            Default: if ``None``, defaults to the dtype of :attr:`input`.
        layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
            Default: if ``None``, defaults to the layout of :attr:`input`.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, defaults to the device of :attr:`input`.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.
        memory_format (:class:`torch.memory_format`, optional): the desired memory format of
            returned Tensor. Default: ``torch.preserve_format``.

    Example::

        >>> a=torch.empty((2,3), dtype=torch.int32, device = 'cuda')
        >>> torch.empty_like(a)
        tensor([[0, 0, 0],
                [0, 0, 0]], device='cuda:0', dtype=torch.int32)
    """

def empty_permuted(
    size: Sequence[_int | SymInt],
    physical_layout: _size,
    *,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    empty_permuted(size, physical_layout, *, dtype=None, layout=None, device=None, requires_grad=False, pin_memory=False) -> Tensor

    Creates an uninitialized, non-overlapping and dense tensor with the
    specified :attr:`size`, with :attr:`physical_layout` specifying how the
    dimensions are physically laid out in memory (each logical dimension is listed
    from outermost to innermost).  :attr:`physical_layout` is a generalization
    of NCHW/NHWC notation: if each dimension is assigned a number according to
    what order they occur in size (N=0, C=1, H=2, W=3), then NCHW is ``(0, 1, 2, 3)``
    while NHWC is ``(0, 2, 3, 1)``.  Equivalently, the strides of the output
    tensor ``t`` are such that ``t.stride(physical_layout[i]) == contiguous_strides[i]``
    (notably, this function is *not* equivalent to ``torch.empty(size).permute(physical_layout)``).

    Unlike :func:`torch.empty_strided`, this is guaranteed to produce a dense
    tensor with no overlaps.  If possible, prefer using this function over
    :func:`torch.empty_strided` or manual use of :func:`torch.as_strided`.

    .. note::
        If :func:`torch.use_deterministic_algorithms()` and
        :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
        ``True``, the output tensor is initialized to prevent any possible
        nondeterministic behavior from using the data as an input to an operation.
        Floating point and complex tensors are filled with NaN, and integer tensors
        are filled with the maximum value.

    Args:
        size (tuple of int): the shape of the output tensor
        physical_layout (tuple of int): the ordering of dimensions physically in memory

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.
        pin_memory (bool, optional): If set, returned tensor would be allocated in
            the pinned memory. Works only for CPU tensors. Default: ``False``.

    Examples:

        >>> torch.empty((2, 3, 5, 7)).stride()
        (105, 35, 7, 1)
        >>> torch.empty_permuted((2, 3, 5, 7), (0, 1, 2, 3)).stride()
        (105, 35, 7, 1)
        >>> torch.empty((2, 3, 5, 7), memory_format=torch.channels_last).stride()
        (105, 1, 21, 3)
        >>> torch.empty_permuted((2, 3, 5, 7), (0, 2, 3, 1)).stride()
        (105, 1, 21, 3)
        >>> torch.empty_permuted((2, 3, 5, 7), (0, 2, 3, 1)).dim_order()
        (0, 2, 3, 1)
    """

def empty_quantized(
    size: _size,
    qtensor: Tensor,
    *,
    memory_format: memory_format | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor: ...
def empty_strided(
    size: Sequence[_int | SymInt],
    stride: Sequence[_int | SymInt],
    *,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    empty_strided(size, stride, *, dtype=None, layout=None, device=None, requires_grad=False, pin_memory=False) -> Tensor

    Creates a tensor with the specified :attr:`size` and :attr:`stride` and filled with undefined data.

    .. warning::
        If the constructed tensor is "overlapped" (with multiple indices referring to the same element
        in memory) its behavior is undefined.

    .. note::
        If :func:`torch.use_deterministic_algorithms()` and
        :attr:`torch.utils.deterministic.fill_uninitialized_memory` are both set to
        ``True``, the output tensor is initialized to prevent any possible
        nondeterministic behavior from using the data as an input to an operation.
        Floating point and complex tensors are filled with NaN, and integer tensors
        are filled with the maximum value.

    Args:
        size (tuple of int): the shape of the output tensor
        stride (tuple of int): the strides of the output tensor

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.
        pin_memory (bool, optional): If set, returned tensor would be allocated in
            the pinned memory. Works only for CPU tensors. Default: ``False``.

    Example::

        >>> a = torch.empty_strided((2, 3), (1, 2))
        >>> a
        tensor([[8.9683e-44, 4.4842e-44, 5.1239e+07],
                [0.0000e+00, 0.0000e+00, 3.0705e-41]])
        >>> a.stride()
        (1, 2)
        >>> a.size()
        torch.Size([2, 3])
    """

@overload
def eq(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    eq(input, other, *, out=None) -> Tensor

    Computes element-wise equality

    The second argument can be a number or a tensor whose shape is
    :ref:`broadcastable <broadcasting-semantics>` with the first argument.

    Args:
        input (Tensor): the tensor to compare
        other (Tensor or float): the tensor or value to compare

    Keyword args:
        out (Tensor, optional): the output tensor.

    Returns:
        A boolean tensor that is True where :attr:`input` is equal to :attr:`other` and False elsewhere

    Example::

        >>> torch.eq(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
        tensor([[ True, False],
                [False, True]])
    """

@overload
def eq(
    input: Tensor,
    other: Number | _complex,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    eq(input, other, *, out=None) -> Tensor

    Computes element-wise equality

    The second argument can be a number or a tensor whose shape is
    :ref:`broadcastable <broadcasting-semantics>` with the first argument.

    Args:
        input (Tensor): the tensor to compare
        other (Tensor or float): the tensor or value to compare

    Keyword args:
        out (Tensor, optional): the output tensor.

    Returns:
        A boolean tensor that is True where :attr:`input` is equal to :attr:`other` and False elsewhere

    Example::

        >>> torch.eq(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
        tensor([[ True, False],
                [False, True]])
    """

def equal(input: Tensor, other: Tensor) -> _bool:
    r"""
    equal(input, other) -> bool

    ``True`` if two tensors have the same size and elements, ``False`` otherwise.

    .. note::

        Tensors containing NaNs are never equal to each other. Additionally, this function does not
        differentiate between the data types of the tensors during comparison. For more thorough tensor checks,
        use :meth:`torch.testing.assert_close`.

    Example::

        >>> torch.equal(torch.tensor([1, 2]), torch.tensor([1, 2]))
        True
        >>> torch.equal(torch.tensor([3, torch.nan]), torch.tensor([3, torch.nan]))
        False
        >>> torch.equal(torch.tensor([1, 2, 3], dtype=torch.int32), torch.tensor([1, 2, 3], dtype=torch.float32))
        True
    """

def erf(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    erf(input, *, out=None) -> Tensor

    Alias for :func:`torch.special.erf`.
    """

def erf_(input: Tensor) -> Tensor: ...
def erfc(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    erfc(input, *, out=None) -> Tensor

    Alias for :func:`torch.special.erfc`.
    """

def erfc_(input: Tensor) -> Tensor: ...
def erfinv(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    erfinv(input, *, out=None) -> Tensor

    Alias for :func:`torch.special.erfinv`.
    """

def exp(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    exp(input, *, out=None) -> Tensor

    Returns a new tensor with the exponential of the elements
    of the input tensor :attr:`input`.

    .. math::
        y_{i} = e^{x_{i}}

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.exp(torch.tensor([0, math.log(2.)]))
        tensor([ 1.,  2.])
    """

def exp2(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    exp2(input, *, out=None) -> Tensor

    Alias for :func:`torch.special.exp2`.
    """

def exp2_(input: Tensor) -> Tensor: ...
def exp_(input: Tensor) -> Tensor: ...
def expand_copy(
    input: Tensor,
    size: Sequence[_int | SymInt],
    *,
    implicit: _bool = False,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    Performs the same operation as :func:`torch.Tensor.expand`, but all output tensors
    are freshly created instead of aliasing the input.
    """

def expm1(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    expm1(input, *, out=None) -> Tensor

    Alias for :func:`torch.special.expm1`.
    """

def expm1_(input: Tensor) -> Tensor: ...
@overload
def eye(
    n: _int | SymInt,
    *,
    out: Tensor | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    eye(n, m=None, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Returns a 2-D tensor with ones on the diagonal and zeros elsewhere.

    Args:
        n (int): the number of rows
        m (int, optional): the number of columns with default being :attr:`n`

    Keyword arguments:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Returns:
        Tensor: A 2-D tensor with ones on the diagonal and zeros elsewhere

    Example::

        >>> torch.eye(3)
        tensor([[ 1.,  0.,  0.],
                [ 0.,  1.,  0.],
                [ 0.,  0.,  1.]])
    """

@overload
def eye(
    n: _int | SymInt,
    m: _int | SymInt,
    *,
    out: Tensor | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    eye(n, m=None, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Returns a 2-D tensor with ones on the diagonal and zeros elsewhere.

    Args:
        n (int): the number of rows
        m (int, optional): the number of columns with default being :attr:`n`

    Keyword arguments:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Returns:
        Tensor: A 2-D tensor with ones on the diagonal and zeros elsewhere

    Example::

        >>> torch.eye(3)
        tensor([[ 1.,  0.,  0.],
                [ 0.,  1.,  0.],
                [ 0.,  0.,  1.]])
    """

def fake_quantize_per_channel_affine(
    input: Tensor,
    scale: Tensor,
    zero_point: Tensor,
    axis: _int,
    quant_min: _int,
    quant_max: _int,
) -> Tensor:
    r"""
    fake_quantize_per_channel_affine(input, scale, zero_point, axis, quant_min, quant_max) -> Tensor

    Returns a new tensor with the data in :attr:`input` fake quantized per channel using :attr:`scale`,
    :attr:`zero_point`, :attr:`quant_min` and :attr:`quant_max`, across the channel specified by :attr:`axis`.

    .. math::
        \text{output} = (
            min(
                \text{quant\_max},
                max(
                    \text{quant\_min},
                    \text{std::nearby\_int}(\text{input} / \text{scale}) + \text{zero\_point}
                )
            ) - \text{zero\_point}
        ) \times \text{scale}

    Args:
        input (Tensor): the input value(s), in ``torch.float32``
        scale (Tensor): quantization scale, per channel in ``torch.float32``
        zero_point (Tensor): quantization zero_point, per channel in ``torch.int32`` or ``torch.half`` or ``torch.float32``
        axis (int32): channel axis
        quant_min (int64): lower bound of the quantized domain
        quant_max (int64): upper bound of the quantized domain

    Returns:
        Tensor: A newly fake_quantized per channel ``torch.float32`` tensor

    Example::

        >>> x = torch.randn(2, 2, 2)
        >>> x
        tensor([[[-0.2525, -0.0466],
                 [ 0.3491, -0.2168]],

                [[-0.5906,  1.6258],
                 [ 0.6444, -0.0542]]])
        >>> scales = (torch.randn(2) + 1) * 0.05
        >>> scales
        tensor([0.0475, 0.0486])
        >>> zero_points = torch.zeros(2).to(torch.int32)
        >>> zero_points
        tensor([0, 0])
        >>> torch.fake_quantize_per_channel_affine(x, scales, zero_points, 1, 0, 255)
        tensor([[[0.0000, 0.0000],
                 [0.3405, 0.0000]],

                [[0.0000, 1.6134],
                [0.6323, 0.0000]]])
    """

@overload
def fake_quantize_per_tensor_affine(
    input: Tensor,
    scale: _float,
    zero_point: _int,
    quant_min: _int,
    quant_max: _int,
) -> Tensor:
    r"""
    fake_quantize_per_tensor_affine(input, scale, zero_point, quant_min, quant_max) -> Tensor

    Returns a new tensor with the data in :attr:`input` fake quantized using :attr:`scale`,
    :attr:`zero_point`, :attr:`quant_min` and :attr:`quant_max`.

    .. math::
        \text{output} = (
            min(
                \text{quant\_max},
                max(
                    \text{quant\_min},
                    \text{std::nearby\_int}(\text{input} / \text{scale}) + \text{zero\_point}
                )
            ) - \text{zero\_point}
        ) \times \text{scale}

    Args:
        input (Tensor): the input value(s), ``torch.float32`` tensor
        scale (double scalar or ``float32`` Tensor): quantization scale
        zero_point (int64 scalar or ``int32`` Tensor): quantization zero_point
        quant_min (int64): lower bound of the quantized domain
        quant_max (int64): upper bound of the quantized domain

    Returns:
        Tensor: A newly fake_quantized ``torch.float32`` tensor

    Example::

        >>> x = torch.randn(4)
        >>> x
        tensor([ 0.0552,  0.9730,  0.3973, -1.0780])
        >>> torch.fake_quantize_per_tensor_affine(x, 0.1, 0, 0, 255)
        tensor([0.1000, 1.0000, 0.4000, 0.0000])
        >>> torch.fake_quantize_per_tensor_affine(x, torch.tensor(0.1), torch.tensor(0), 0, 255)
        tensor([0.1000, 1.0000, 0.4000, 0.0000])
    """

@overload
def fake_quantize_per_tensor_affine(
    input: Tensor,
    scale: Tensor,
    zero_point: Tensor,
    quant_min: _int,
    quant_max: _int,
) -> Tensor:
    r"""
    fake_quantize_per_tensor_affine(input, scale, zero_point, quant_min, quant_max) -> Tensor

    Returns a new tensor with the data in :attr:`input` fake quantized using :attr:`scale`,
    :attr:`zero_point`, :attr:`quant_min` and :attr:`quant_max`.

    .. math::
        \text{output} = (
            min(
                \text{quant\_max},
                max(
                    \text{quant\_min},
                    \text{std::nearby\_int}(\text{input} / \text{scale}) + \text{zero\_point}
                )
            ) - \text{zero\_point}
        ) \times \text{scale}

    Args:
        input (Tensor): the input value(s), ``torch.float32`` tensor
        scale (double scalar or ``float32`` Tensor): quantization scale
        zero_point (int64 scalar or ``int32`` Tensor): quantization zero_point
        quant_min (int64): lower bound of the quantized domain
        quant_max (int64): upper bound of the quantized domain

    Returns:
        Tensor: A newly fake_quantized ``torch.float32`` tensor

    Example::

        >>> x = torch.randn(4)
        >>> x
        tensor([ 0.0552,  0.9730,  0.3973, -1.0780])
        >>> torch.fake_quantize_per_tensor_affine(x, 0.1, 0, 0, 255)
        tensor([0.1000, 1.0000, 0.4000, 0.0000])
        >>> torch.fake_quantize_per_tensor_affine(x, torch.tensor(0.1), torch.tensor(0), 0, 255)
        tensor([0.1000, 1.0000, 0.4000, 0.0000])
    """

def fbgemm_linear_fp16_weight(
    input: Tensor,
    packed_weight: Tensor,
    bias: Tensor,
) -> Tensor: ...
def fbgemm_linear_fp16_weight_fp32_activation(
    input: Tensor,
    packed_weight: Tensor,
    bias: Tensor,
) -> Tensor: ...
def fbgemm_linear_int8_weight(
    input: Tensor,
    weight: Tensor,
    packed: Tensor,
    col_offsets: Tensor,
    weight_scale: Number | _complex,
    weight_zero_point: Number | _complex,
    bias: Tensor,
) -> Tensor: ...
def fbgemm_linear_int8_weight_fp32_activation(
    input: Tensor,
    weight: Tensor,
    packed: Tensor,
    col_offsets: Tensor,
    weight_scale: Number | _complex,
    weight_zero_point: Number | _complex,
    bias: Tensor,
) -> Tensor: ...
def fbgemm_linear_quantize_weight(
    input: Tensor,
) -> tuple[Tensor, Tensor, _float, _int]: ...
def fbgemm_pack_gemm_matrix_fp16(input: Tensor) -> Tensor: ...
@overload
def fbgemm_pack_quantized_matrix(input: Tensor) -> Tensor: ...
@overload
def fbgemm_pack_quantized_matrix(input: Tensor, K: _int, N: _int) -> Tensor: ...
def feature_alpha_dropout(input: Tensor, p: _float, train: _bool) -> Tensor: ...
def feature_alpha_dropout_(
    input: Tensor,
    p: _float,
    train: _bool,
) -> Tensor: ...
def feature_dropout(input: Tensor, p: _float, train: _bool) -> Tensor: ...
def feature_dropout_(input: Tensor, p: _float, train: _bool) -> Tensor: ...
@overload
def fill(input: Tensor, value: Tensor) -> Tensor: ...
@overload
def fill(input: Tensor, value: Number | _complex) -> Tensor: ...
@overload
def fill_(input: Tensor, value: Tensor) -> Tensor: ...
@overload
def fill_(input: Tensor, value: Number | _complex) -> Tensor: ...
def fix(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    fix(input, *, out=None) -> Tensor

    Alias for :func:`torch.trunc`
    """

def fix_(input: Tensor) -> Tensor: ...
@overload
def flatten(
    input: Tensor,
    start_dim: _int = 0,
    end_dim: _int = -1,
) -> Tensor:
    r"""
    flatten(input, start_dim=0, end_dim=-1) -> Tensor

    Flattens :attr:`input` by reshaping it into a one-dimensional tensor. If :attr:`start_dim` or :attr:`end_dim`
    are passed, only dimensions starting with :attr:`start_dim` and ending with :attr:`end_dim` are flattened.
    The order of elements in :attr:`input` is unchanged.

    Unlike NumPy's flatten, which always copies input's data, this function may return the original object, a view,
    or copy. If no dimensions are flattened, then the original object :attr:`input` is returned. Otherwise, if input can
    be viewed as the flattened shape, then that view is returned. Finally, only if the input cannot be viewed as the
    flattened shape is input's data copied. See :meth:`torch.Tensor.view` for details on when a view will be returned.

    .. note::
        Flattening a zero-dimensional tensor will return a one-dimensional view.

    Args:
        input (Tensor): the input tensor.
        start_dim (int): the first dim to flatten
        end_dim (int): the last dim to flatten

    Example::

        >>> t = torch.tensor([[[1, 2],
        ...                    [3, 4]],
        ...                   [[5, 6],
        ...                    [7, 8]]])
        >>> torch.flatten(t)
        tensor([1, 2, 3, 4, 5, 6, 7, 8])
        >>> torch.flatten(t, start_dim=1)
        tensor([[1, 2, 3, 4],
                [5, 6, 7, 8]])
    """

@overload
def flatten(
    input: Tensor,
    start_dim: _int,
    end_dim: _int,
    out_dim: str | EllipsisType | None,
) -> Tensor:
    r"""
    flatten(input, start_dim=0, end_dim=-1) -> Tensor

    Flattens :attr:`input` by reshaping it into a one-dimensional tensor. If :attr:`start_dim` or :attr:`end_dim`
    are passed, only dimensions starting with :attr:`start_dim` and ending with :attr:`end_dim` are flattened.
    The order of elements in :attr:`input` is unchanged.

    Unlike NumPy's flatten, which always copies input's data, this function may return the original object, a view,
    or copy. If no dimensions are flattened, then the original object :attr:`input` is returned. Otherwise, if input can
    be viewed as the flattened shape, then that view is returned. Finally, only if the input cannot be viewed as the
    flattened shape is input's data copied. See :meth:`torch.Tensor.view` for details on when a view will be returned.

    .. note::
        Flattening a zero-dimensional tensor will return a one-dimensional view.

    Args:
        input (Tensor): the input tensor.
        start_dim (int): the first dim to flatten
        end_dim (int): the last dim to flatten

    Example::

        >>> t = torch.tensor([[[1, 2],
        ...                    [3, 4]],
        ...                   [[5, 6],
        ...                    [7, 8]]])
        >>> torch.flatten(t)
        tensor([1, 2, 3, 4, 5, 6, 7, 8])
        >>> torch.flatten(t, start_dim=1)
        tensor([[1, 2, 3, 4],
                [5, 6, 7, 8]])
    """

@overload
def flatten(
    input: Tensor,
    start_dim: str | EllipsisType | None,
    end_dim: str | EllipsisType | None,
    out_dim: str | EllipsisType | None,
) -> Tensor:
    r"""
    flatten(input, start_dim=0, end_dim=-1) -> Tensor

    Flattens :attr:`input` by reshaping it into a one-dimensional tensor. If :attr:`start_dim` or :attr:`end_dim`
    are passed, only dimensions starting with :attr:`start_dim` and ending with :attr:`end_dim` are flattened.
    The order of elements in :attr:`input` is unchanged.

    Unlike NumPy's flatten, which always copies input's data, this function may return the original object, a view,
    or copy. If no dimensions are flattened, then the original object :attr:`input` is returned. Otherwise, if input can
    be viewed as the flattened shape, then that view is returned. Finally, only if the input cannot be viewed as the
    flattened shape is input's data copied. See :meth:`torch.Tensor.view` for details on when a view will be returned.

    .. note::
        Flattening a zero-dimensional tensor will return a one-dimensional view.

    Args:
        input (Tensor): the input tensor.
        start_dim (int): the first dim to flatten
        end_dim (int): the last dim to flatten

    Example::

        >>> t = torch.tensor([[[1, 2],
        ...                    [3, 4]],
        ...                   [[5, 6],
        ...                    [7, 8]]])
        >>> torch.flatten(t)
        tensor([1, 2, 3, 4, 5, 6, 7, 8])
        >>> torch.flatten(t, start_dim=1)
        tensor([[1, 2, 3, 4],
                [5, 6, 7, 8]])
    """

@overload
def flatten(
    input: Tensor,
    dims: Sequence[str | EllipsisType | None],
    out_dim: str | EllipsisType | None,
) -> Tensor:
    r"""
    flatten(input, start_dim=0, end_dim=-1) -> Tensor

    Flattens :attr:`input` by reshaping it into a one-dimensional tensor. If :attr:`start_dim` or :attr:`end_dim`
    are passed, only dimensions starting with :attr:`start_dim` and ending with :attr:`end_dim` are flattened.
    The order of elements in :attr:`input` is unchanged.

    Unlike NumPy's flatten, which always copies input's data, this function may return the original object, a view,
    or copy. If no dimensions are flattened, then the original object :attr:`input` is returned. Otherwise, if input can
    be viewed as the flattened shape, then that view is returned. Finally, only if the input cannot be viewed as the
    flattened shape is input's data copied. See :meth:`torch.Tensor.view` for details on when a view will be returned.

    .. note::
        Flattening a zero-dimensional tensor will return a one-dimensional view.

    Args:
        input (Tensor): the input tensor.
        start_dim (int): the first dim to flatten
        end_dim (int): the last dim to flatten

    Example::

        >>> t = torch.tensor([[[1, 2],
        ...                    [3, 4]],
        ...                   [[5, 6],
        ...                    [7, 8]]])
        >>> torch.flatten(t)
        tensor([1, 2, 3, 4, 5, 6, 7, 8])
        >>> torch.flatten(t, start_dim=1)
        tensor([[1, 2, 3, 4],
                [5, 6, 7, 8]])
    """

def flip(input: Tensor, dims: _size) -> Tensor:
    r"""
    flip(input, dims) -> Tensor

    Reverse the order of an n-D tensor along given axis in dims.

    .. note::
        `torch.flip` makes a copy of :attr:`input`'s data. This is different from NumPy's `np.flip`,
        which returns a view in constant time. Since copying a tensor's data is more work than viewing that data,
        `torch.flip` is expected to be slower than `np.flip`.

    Args:
        input (Tensor): the input tensor.
        dims (a list or tuple): axis to flip on

    Example::

        >>> x = torch.arange(8).view(2, 2, 2)
        >>> x
        tensor([[[ 0,  1],
                 [ 2,  3]],

                [[ 4,  5],
                 [ 6,  7]]])
        >>> torch.flip(x, [0, 1])
        tensor([[[ 6,  7],
                 [ 4,  5]],

                [[ 2,  3],
                 [ 0,  1]]])
    """

def fliplr(input: Tensor) -> Tensor:
    r"""
    fliplr(input) -> Tensor

    Flip tensor in the left/right direction, returning a new tensor.

    Flip the entries in each row in the left/right direction.
    Columns are preserved, but appear in a different order than before.

    Note:
        Requires the tensor to be at least 2-D.

    .. note::
        `torch.fliplr` makes a copy of :attr:`input`'s data. This is different from NumPy's `np.fliplr`,
        which returns a view in constant time. Since copying a tensor's data is more work than viewing that data,
        `torch.fliplr` is expected to be slower than `np.fliplr`.

    Args:
        input (Tensor): Must be at least 2-dimensional.

    Example::

        >>> x = torch.arange(4).view(2, 2)
        >>> x
        tensor([[0, 1],
                [2, 3]])
        >>> torch.fliplr(x)
        tensor([[1, 0],
                [3, 2]])
    """

def flipud(input: Tensor) -> Tensor:
    r"""
    flipud(input) -> Tensor

    Flip tensor in the up/down direction, returning a new tensor.

    Flip the entries in each column in the up/down direction.
    Rows are preserved, but appear in a different order than before.

    Note:
        Requires the tensor to be at least 1-D.

    .. note::
        `torch.flipud` makes a copy of :attr:`input`'s data. This is different from NumPy's `np.flipud`,
        which returns a view in constant time. Since copying a tensor's data is more work than viewing that data,
        `torch.flipud` is expected to be slower than `np.flipud`.

    Args:
        input (Tensor): Must be at least 1-dimensional.

    Example::

        >>> x = torch.arange(4).view(2, 2)
        >>> x
        tensor([[0, 1],
                [2, 3]])
        >>> torch.flipud(x)
        tensor([[2, 3],
                [0, 1]])
    """

@overload
def float_power(
    input: Tensor,
    exponent: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    float_power(input, exponent, *, out=None) -> Tensor

    Raises :attr:`input` to the power of :attr:`exponent`, elementwise, in double precision.
    If neither input is complex returns a ``torch.float64`` tensor,
    and if one or more inputs is complex returns a ``torch.complex128`` tensor.

    .. note::
        This function always computes in double precision, unlike :func:`torch.pow`,
        which implements more typical :ref:`type promotion <type-promotion-doc>`.
        This is useful when the computation needs to be performed in a wider or more precise dtype,
        or the results of the computation may contain fractional values not representable in the input dtypes,
        like when an integer base is raised to a negative integer exponent.

    Args:
        input (Tensor or Number): the base value(s)
        exponent (Tensor or Number): the exponent value(s)

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randint(10, (4,))
        >>> a
        tensor([6, 4, 7, 1])
        >>> torch.float_power(a, 2)
        tensor([36., 16., 49.,  1.], dtype=torch.float64)

        >>> a = torch.arange(1, 5)
        >>> a
        tensor([ 1,  2,  3,  4])
        >>> exp = torch.tensor([2, -3, 4, -5])
        >>> exp
        tensor([ 2, -3,  4, -5])
        >>> torch.float_power(a, exp)
        tensor([1.0000e+00, 1.2500e-01, 8.1000e+01, 9.7656e-04], dtype=torch.float64)
    """

@overload
def float_power(
    self: Number | _complex,
    exponent: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    float_power(input, exponent, *, out=None) -> Tensor

    Raises :attr:`input` to the power of :attr:`exponent`, elementwise, in double precision.
    If neither input is complex returns a ``torch.float64`` tensor,
    and if one or more inputs is complex returns a ``torch.complex128`` tensor.

    .. note::
        This function always computes in double precision, unlike :func:`torch.pow`,
        which implements more typical :ref:`type promotion <type-promotion-doc>`.
        This is useful when the computation needs to be performed in a wider or more precise dtype,
        or the results of the computation may contain fractional values not representable in the input dtypes,
        like when an integer base is raised to a negative integer exponent.

    Args:
        input (Tensor or Number): the base value(s)
        exponent (Tensor or Number): the exponent value(s)

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randint(10, (4,))
        >>> a
        tensor([6, 4, 7, 1])
        >>> torch.float_power(a, 2)
        tensor([36., 16., 49.,  1.], dtype=torch.float64)

        >>> a = torch.arange(1, 5)
        >>> a
        tensor([ 1,  2,  3,  4])
        >>> exp = torch.tensor([2, -3, 4, -5])
        >>> exp
        tensor([ 2, -3,  4, -5])
        >>> torch.float_power(a, exp)
        tensor([1.0000e+00, 1.2500e-01, 8.1000e+01, 9.7656e-04], dtype=torch.float64)
    """

@overload
def float_power(
    input: Tensor,
    exponent: Number | _complex,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    float_power(input, exponent, *, out=None) -> Tensor

    Raises :attr:`input` to the power of :attr:`exponent`, elementwise, in double precision.
    If neither input is complex returns a ``torch.float64`` tensor,
    and if one or more inputs is complex returns a ``torch.complex128`` tensor.

    .. note::
        This function always computes in double precision, unlike :func:`torch.pow`,
        which implements more typical :ref:`type promotion <type-promotion-doc>`.
        This is useful when the computation needs to be performed in a wider or more precise dtype,
        or the results of the computation may contain fractional values not representable in the input dtypes,
        like when an integer base is raised to a negative integer exponent.

    Args:
        input (Tensor or Number): the base value(s)
        exponent (Tensor or Number): the exponent value(s)

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randint(10, (4,))
        >>> a
        tensor([6, 4, 7, 1])
        >>> torch.float_power(a, 2)
        tensor([36., 16., 49.,  1.], dtype=torch.float64)

        >>> a = torch.arange(1, 5)
        >>> a
        tensor([ 1,  2,  3,  4])
        >>> exp = torch.tensor([2, -3, 4, -5])
        >>> exp
        tensor([ 2, -3,  4, -5])
        >>> torch.float_power(a, exp)
        tensor([1.0000e+00, 1.2500e-01, 8.1000e+01, 9.7656e-04], dtype=torch.float64)
    """

def floor(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    floor(input, *, out=None) -> Tensor

    Returns a new tensor with the floor of the elements of :attr:`input`,
    the largest integer less than or equal to each element.

    For integer inputs, follows the array-api convention of returning a
    copy of the input tensor.

    .. math::
        \text{out}_{i} = \left\lfloor \text{input}_{i} \right\rfloor

    Args:
        input (Tensor): the input tensor.

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.randn(4)
        >>> a
        tensor([-0.8166,  1.5308, -0.2530, -0.2091])
        >>> torch.floor(a)
        tensor([-1.,  1., -1., -1.])
    """

def floor_(input: Tensor) -> Tensor: ...
def floor_divide(
    input: Tensor | Number,
    other: Tensor | Number,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    floor_divide(input, other, *, out=None) -> Tensor

    .. note::

        Before PyTorch 1.13 :func:`torch.floor_divide` incorrectly performed
        truncation division. To restore the previous behavior use
        :func:`torch.div` with ``rounding_mode='trunc'``.

    Computes :attr:`input` divided by :attr:`other`, elementwise, and floors
    the result.

    .. math::
        \text{{out}}_i = \text{floor} \left( \frac{{\text{{input}}_i}}{{\text{{other}}_i}} \right)



    Supports broadcasting to a common shape, type promotion, and integer and float inputs.

    Args:
        input (Tensor or Number): the dividend
        other (Tensor or Number): the divisor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.tensor([4.0, 3.0])
        >>> b = torch.tensor([2.0, 2.0])
        >>> torch.floor_divide(a, b)
        tensor([2.0, 1.0])
        >>> torch.floor_divide(a, 1.4)
        tensor([2.0, 2.0])
    """

def fmax(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    fmax(input, other, *, out=None) -> Tensor

    Computes the element-wise maximum of :attr:`input` and :attr:`other`.

    This is like :func:`torch.maximum` except it handles NaNs differently:
    if exactly one of the two elements being compared is a NaN then the non-NaN element is taken as the maximum.
    Only if both elements are NaN is NaN propagated.

    This function is a wrapper around C++'s ``std::fmax`` and is similar to NumPy's ``fmax`` function.

    Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
    :ref:`type promotion <type-promotion-doc>`, and integer and floating-point inputs.

    Args:
        input (Tensor): the input tensor.
        other (Tensor): the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.tensor([9.7, float('nan'), 3.1, float('nan')])
        >>> b = torch.tensor([-2.2, 0.5, float('nan'), float('nan')])
        >>> torch.fmax(a, b)
        tensor([9.7000, 0.5000, 3.1000,    nan])
    """

def fmin(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    fmin(input, other, *, out=None) -> Tensor

    Computes the element-wise minimum of :attr:`input` and :attr:`other`.

    This is like :func:`torch.minimum` except it handles NaNs differently:
    if exactly one of the two elements being compared is a NaN then the non-NaN element is taken as the minimum.
    Only if both elements are NaN is NaN propagated.

    This function is a wrapper around C++'s ``std::fmin`` and is similar to NumPy's ``fmin`` function.

    Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
    :ref:`type promotion <type-promotion-doc>`, and integer and floating-point inputs.

    Args:
        input (Tensor): the input tensor.
        other (Tensor): the second input tensor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.tensor([2.2, float('nan'), 2.1, float('nan')])
        >>> b = torch.tensor([-9.3, 0.1, float('nan'), float('nan')])
        >>> torch.fmin(a, b)
        tensor([-9.3000, 0.1000, 2.1000,    nan])
    """

@overload
def fmod(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    fmod(input, other, *, out=None) -> Tensor

    Applies C++'s `std::fmod <https://en.cppreference.com/w/cpp/numeric/math/fmod>`_ entrywise.
    The result has the same sign as the dividend :attr:`input` and its absolute value
    is less than that of :attr:`other`.

    This function may be defined in terms of :func:`torch.div` as

    .. code:: python

        torch.fmod(a, b) == a - a.div(b, rounding_mode="trunc") * b

    Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
    :ref:`type promotion <type-promotion-doc>`, and integer and float inputs.

    .. note::

        When the divisor is zero, returns ``NaN`` for floating point dtypes
        on both CPU and GPU; raises ``RuntimeError`` for integer division by
        zero on CPU; Integer division by zero on GPU may return any value.

    .. note::

       Complex inputs are not supported. In some cases, it is not mathematically
       possible to satisfy the definition of a modulo operation with complex numbers.

    .. seealso::

        :func:`torch.remainder` which implements Python's modulus operator.
        This one is defined using division rounding down the result.

    Args:
        input (Tensor): the dividend
        other (Tensor or Scalar): the divisor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.fmod(torch.tensor([-3., -2, -1, 1, 2, 3]), 2)
        tensor([-1., -0., -1.,  1.,  0.,  1.])
        >>> torch.fmod(torch.tensor([1, 2, 3, 4, 5]), -1.5)
        tensor([1.0000, 0.5000, 0.0000, 1.0000, 0.5000])
    """

@overload
def fmod(
    input: Tensor,
    other: Number | _complex,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    fmod(input, other, *, out=None) -> Tensor

    Applies C++'s `std::fmod <https://en.cppreference.com/w/cpp/numeric/math/fmod>`_ entrywise.
    The result has the same sign as the dividend :attr:`input` and its absolute value
    is less than that of :attr:`other`.

    This function may be defined in terms of :func:`torch.div` as

    .. code:: python

        torch.fmod(a, b) == a - a.div(b, rounding_mode="trunc") * b

    Supports :ref:`broadcasting to a common shape <broadcasting-semantics>`,
    :ref:`type promotion <type-promotion-doc>`, and integer and float inputs.

    .. note::

        When the divisor is zero, returns ``NaN`` for floating point dtypes
        on both CPU and GPU; raises ``RuntimeError`` for integer division by
        zero on CPU; Integer division by zero on GPU may return any value.

    .. note::

       Complex inputs are not supported. In some cases, it is not mathematically
       possible to satisfy the definition of a modulo operation with complex numbers.

    .. seealso::

        :func:`torch.remainder` which implements Python's modulus operator.
        This one is defined using division rounding down the result.

    Args:
        input (Tensor): the dividend
        other (Tensor or Scalar): the divisor

    Keyword args:
        out (Tensor, optional): the output tensor.

    Example::

        >>> torch.fmod(torch.tensor([-3., -2, -1, 1, 2, 3]), 2)
        tensor([-1., -0., -1.,  1.,  0.,  1.])
        >>> torch.fmod(torch.tensor([1, 2, 3, 4, 5]), -1.5)
        tensor([1.0000, 0.5000, 0.0000, 1.0000, 0.5000])
    """

def frac(input: Tensor, *, out: Tensor | None = None) -> Tensor:
    r"""
    frac(input, *, out=None) -> Tensor

    Computes the fractional portion of each element in :attr:`input`.

    .. math::
        \text{out}_{i} = \text{input}_{i} - \left\lfloor |\text{input}_{i}| \right\rfloor * \operatorname{sgn}(\text{input}_{i})

    Example::

        >>> torch.frac(torch.tensor([1, 2.5, -3.2]))
        tensor([ 0.0000,  0.5000, -0.2000])
    """

def frac_(input: Tensor) -> Tensor: ...
def frexp(
    input: Tensor,
    *,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> torch.return_types.frexp:
    r"""
    frexp(input, *, out=None) -> (Tensor mantissa, Tensor exponent)

    Decomposes :attr:`input` into mantissa and exponent tensors
    such that :math:`\text{input} = \text{mantissa} \times 2^{\text{exponent}}`.

    The range of mantissa is the open interval (-1, 1).

    Supports float inputs.

    Args:
        input (Tensor): the input tensor


    Keyword args:
        out (tuple, optional): the output tensors

    Example::

        >>> x = torch.arange(9.)
        >>> mantissa, exponent = torch.frexp(x)
        >>> mantissa
        tensor([0.0000, 0.5000, 0.5000, 0.7500, 0.5000, 0.6250, 0.7500, 0.8750, 0.5000])
        >>> exponent
        tensor([0, 1, 2, 2, 3, 3, 3, 3, 4], dtype=torch.int32)
        >>> torch.ldexp(mantissa, exponent)
        tensor([0., 1., 2., 3., 4., 5., 6., 7., 8.])
    """

def frobenius_norm(
    input: Tensor,
    dim: _int | _size,
    keepdim: _bool = False,
    *,
    out: Tensor | None = None,
) -> Tensor: ...
def from_file(
    filename: str,
    shared: _bool | None = None,
    size: _int | None = 0,
    *,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    from_file(filename, shared=None, size=0, *, dtype=None, layout=None, device=None, pin_memory=False)

    Creates a CPU tensor with a storage backed by a memory-mapped file.

    If ``shared`` is True, then memory is shared between processes. All changes are written to the file.
    If ``shared`` is False, then changes to the tensor do not affect the file.

    ``size`` is the number of elements in the Tensor. If ``shared`` is ``False``, then the file must contain
    at least ``size * sizeof(dtype)`` bytes. If ``shared`` is ``True`` the file will be created if needed.

    .. note::
        Only CPU tensors can be mapped to files.

    .. note::
        For now, tensors with storages backed by a memory-mapped file cannot be created in pinned memory.


    Args:
        filename (str): file name to map
        shared (bool): whether to share memory (whether ``MAP_SHARED`` or ``MAP_PRIVATE`` is passed to the
                        underlying `mmap(2) call <https://man7.org/linux/man-pages/man2/mmap.2.html>`_)
        size (int): number of elements in the tensor

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        pin_memory (bool, optional): If set, returned tensor would be allocated in
            the pinned memory. Works only for CPU tensors. Default: ``False``.

    Example::

        >>> t = torch.randn(2, 5, dtype=torch.float64)
        >>> t.numpy().tofile('storage.pt')
        >>> t_mapped = torch.from_file('storage.pt', shared=False, size=10, dtype=torch.float64)
    """

def from_numpy(ndarray) -> Tensor:
    r"""
    from_numpy(ndarray) -> Tensor

    Creates a :class:`Tensor` from a :class:`numpy.ndarray`.

    The returned tensor and :attr:`ndarray` share the same memory. Modifications to
    the tensor will be reflected in the :attr:`ndarray` and vice versa. The returned
    tensor is not resizable.

    It currently accepts :attr:`ndarray` with dtypes of ``numpy.float64``,
    ``numpy.float32``, ``numpy.float16``, ``numpy.complex64``, ``numpy.complex128``,
    ``numpy.int64``, ``numpy.int32``, ``numpy.int16``, ``numpy.int8``, ``numpy.uint8``,
    and ``bool``.

    .. warning::
        Writing to a tensor created from a read-only NumPy array is not supported and will result in undefined behavior.

    Example::

        >>> a = numpy.array([1, 2, 3])
        >>> t = torch.from_numpy(a)
        >>> t
        tensor([ 1,  2,  3])
        >>> t[0] = -1
        >>> a
        array([-1,  2,  3])
    """

def frombuffer(
    buffer: Any,
    *,
    dtype: _dtype,
    count: int = -1,
    offset: int = 0,
    requires_grad: _bool = False,
) -> Tensor:
    r"""
    frombuffer(buffer, *, dtype, count=-1, offset=0, requires_grad=False) -> Tensor

    Creates a 1-dimensional :class:`Tensor` from an object that implements
    the Python buffer protocol.

    Skips the first :attr:`offset` bytes in the buffer, and interprets the rest of
    the raw bytes as a 1-dimensional tensor of type :attr:`dtype` with :attr:`count`
    elements.

    Note that either of the following must be true:

    1. :attr:`count` is a positive non-zero number, and the total number of bytes
    in the buffer is more than :attr:`offset` plus :attr:`count` times the size
    (in bytes) of :attr:`dtype`.

    2. :attr:`count` is negative, and the length (number of bytes) of the buffer
    subtracted by the :attr:`offset` is a multiple of the size (in bytes) of
    :attr:`dtype`.

    The returned tensor and buffer share the same memory. Modifications to
    the tensor will be reflected in the buffer and vice versa. The returned
    tensor is not resizable.

    .. note::
        This function increments the reference count for the object that
        owns the shared memory. Therefore, such memory will not be deallocated
        before the returned tensor goes out of scope.

    .. warning::
        This function's behavior is undefined when passed an object implementing
        the buffer protocol whose data is not on the CPU. Doing so is likely to
        cause a segmentation fault.

    .. warning::
        This function does not try to infer the :attr:`dtype` (hence, it is not
        optional). Passing a different :attr:`dtype` than its source may result
        in unexpected behavior.

    Args:
        buffer (object): a Python object that exposes the buffer interface.

    Keyword args:
        dtype (:class:`torch.dtype`): the desired data type of returned tensor.
        count (int, optional): the number of desired elements to be read.
            If negative, all the elements (until the end of the buffer) will be
            read. Default: -1.
        offset (int, optional): the number of bytes to skip at the start of
            the buffer. Default: 0.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Example::

        >>> import array
        >>> a = array.array('i', [1, 2, 3])
        >>> t = torch.frombuffer(a, dtype=torch.int32)
        >>> t
        tensor([ 1,  2,  3])
        >>> t[0] = -1
        >>> a
        array([-1,  2,  3])

        >>> # Interprets the signed char bytes as 32-bit integers.
        >>> # Each 4 signed char elements will be interpreted as
        >>> # 1 signed 32-bit integer.
        >>> import array
        >>> a = array.array('b', [-1, 0, 0, 0])
        >>> torch.frombuffer(a, dtype=torch.int32)
        tensor([255], dtype=torch.int32)
    """

@overload
def full(
    size: _size,
    fill_value: Number | _complex,
    *,
    out: Tensor | None = None,
    layout: _layout = strided,
    dtype: _dtype | None = None,
    device: DeviceLikeType | None = None,
    requires_grad: _bool = False,
    pin_memory: _bool = False,
) -> Tensor:
    r"""
    full(size, fill_value, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Creates a tensor of size :attr:`size` filled with :attr:`fill_value`. The
    tensor's dtype is inferred from :attr:`fill_value`.

    Args:
        size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
            shape of the output tensor.
        fill_value (Scalar): the value to fill the output tensor with.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Example::

        >>> torch.full((2, 3), 3.141592)
        tensor([[ 3.1416,  3.1416,  3.1416],
                [ 3.1416,  3.1416,  3.1416]])
    """

@overload
def full(
    size: _size,
    fill_value: Number | _complex,
    *,
    names: list[str | None],
    layout: _layout = strided,
    dtype: _dtype | None = None,
    device: DeviceLikeType | None = None,
    requires_grad: _bool = False,
    pin_memory: _bool = False,
) -> Tensor:
    r"""
    full(size, fill_value, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Creates a tensor of size :attr:`size` filled with :attr:`fill_value`. The
    tensor's dtype is inferred from :attr:`fill_value`.

    Args:
        size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
            shape of the output tensor.
        fill_value (Scalar): the value to fill the output tensor with.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Example::

        >>> torch.full((2, 3), 3.141592)
        tensor([[ 3.1416,  3.1416,  3.1416],
                [ 3.1416,  3.1416,  3.1416]])
    """

@overload
def full(
    size: Sequence[_int | SymInt],
    fill_value: Number | _complex,
    *,
    out: Tensor | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    full(size, fill_value, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Creates a tensor of size :attr:`size` filled with :attr:`fill_value`. The
    tensor's dtype is inferred from :attr:`fill_value`.

    Args:
        size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
            shape of the output tensor.
        fill_value (Scalar): the value to fill the output tensor with.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Example::

        >>> torch.full((2, 3), 3.141592)
        tensor([[ 3.1416,  3.1416,  3.1416],
                [ 3.1416,  3.1416,  3.1416]])
    """

@overload
def full(
    size: _size,
    fill_value: Number | _complex,
    *,
    names: Sequence[str | EllipsisType | None] | None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    full(size, fill_value, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor

    Creates a tensor of size :attr:`size` filled with :attr:`fill_value`. The
    tensor's dtype is inferred from :attr:`fill_value`.

    Args:
        size (int...): a list, tuple, or :class:`torch.Size` of integers defining the
            shape of the output tensor.
        fill_value (Scalar): the value to fill the output tensor with.

    Keyword args:
        out (Tensor, optional): the output tensor.
        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
        layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
            Default: ``torch.strided``.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, uses the current device for the default tensor type
            (see :func:`torch.set_default_device`). :attr:`device` will be the CPU
            for CPU tensor types and the current CUDA device for CUDA tensor types.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.

    Example::

        >>> torch.full((2, 3), 3.141592)
        tensor([[ 3.1416,  3.1416,  3.1416],
                [ 3.1416,  3.1416,  3.1416]])
    """

def full_like(
    input: Tensor,
    fill_value: Number | _complex,
    *,
    memory_format: memory_format | None = None,
    dtype: _dtype | None = None,
    layout: _layout | None = None,
    device: DeviceLikeType | None = None,
    pin_memory: _bool | None = False,
    requires_grad: _bool | None = False,
) -> Tensor:
    r"""
    full_like(input, fill_value, \*, dtype=None, layout=torch.strided, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor

    Returns a tensor with the same size as :attr:`input` filled with :attr:`fill_value`.
    ``torch.full_like(input, fill_value)`` is equivalent to
    ``torch.full(input.size(), fill_value, dtype=input.dtype, layout=input.layout, device=input.device)``.

    Args:
        input (Tensor): the size of :attr:`input` will determine size of the output tensor.
        fill_value: the number to fill the output tensor with.

    Keyword args:
        dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.
            Default: if ``None``, defaults to the dtype of :attr:`input`.
        layout (:class:`torch.layout`, optional): the desired layout of returned tensor.
            Default: if ``None``, defaults to the layout of :attr:`input`.
        device (:class:`torch.device`, optional): the desired device of returned tensor.
            Default: if ``None``, defaults to the device of :attr:`input`.
        requires_grad (bool, optional): If autograd should record operations on the
            returned tensor. Default: ``False``.
        memory_format (:class:`torch.memory_format`, optional): the desired memory format of
            returned Tensor. Default: ``torch.preserve_format``.
    """

def fused_moving_avg_obs_fake_quant(
    input: Tensor,
    observer_on: Tensor,
    fake_quant_on: Tensor,
    running_min: Tensor,
    running_max: Tensor,
    scale: Tensor,
    zero_point: Tensor,
    averaging_const: _float,
    quant_min: _int,
    quant_max: _int,
    ch_axis: _int,
    per_row_fake_quant: _bool = False,
    symmetric_quant: _bool = False,
) -> Tensor: ...
@overload
def gather(
    input: Tensor,
    dim: _int,
    index: Tensor,
    *,
    sparse_grad: _bool = False,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    gather(input, dim, index, *, sparse_grad=False, out=None) -> Tensor

    Gathers values along an axis specified by `dim`.

    For a 3-D tensor the output is specified by::

        out[i][j][k] = input[index[i][j][k]][j][k]  # if dim == 0
        out[i][j][k] = input[i][index[i][j][k]][k]  # if dim == 1
        out[i][j][k] = input[i][j][index[i][j][k]]  # if dim == 2

    :attr:`input` and :attr:`index` must have the same number of dimensions.
    It is also required that ``index.size(d) <= input.size(d)`` for all
    dimensions ``d != dim``.  :attr:`out` will have the same shape as :attr:`index`.
    Note that ``input`` and ``index`` do not broadcast against each other.

    Args:
        input (Tensor): the source tensor
        dim (int): the axis along which to index
        index (LongTensor): the indices of elements to gather

    Keyword arguments:
        sparse_grad (bool, optional): If ``True``, gradient w.r.t. :attr:`input` will be a sparse tensor.
        out (Tensor, optional): the destination tensor

    Example::

        >>> t = torch.tensor([[1, 2], [3, 4]])
        >>> torch.gather(t, 1, torch.tensor([[0, 0], [1, 0]]))
        tensor([[ 1,  1],
                [ 4,  3]])
    """

@overload
def gather(
    input: Tensor,
    dim: str | EllipsisType | None,
    index: Tensor,
    *,
    sparse_grad: _bool = False,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    gather(input, dim, index, *, sparse_grad=False, out=None) -> Tensor

    Gathers values along an axis specified by `dim`.

    For a 3-D tensor the output is specified by::

        out[i][j][k] = input[index[i][j][k]][j][k]  # if dim == 0
        out[i][j][k] = input[i][index[i][j][k]][k]  # if dim == 1
        out[i][j][k] = input[i][j][index[i][j][k]]  # if dim == 2

    :attr:`input` and :attr:`index` must have the same number of dimensions.
    It is also required that ``index.size(d) <= input.size(d)`` for all
    dimensions ``d != dim``.  :attr:`out` will have the same shape as :attr:`index`.
    Note that ``input`` and ``index`` do not broadcast against each other.

    Args:
        input (Tensor): the source tensor
        dim (int): the axis along which to index
        index (LongTensor): the indices of elements to gather

    Keyword arguments:
        sparse_grad (bool, optional): If ``True``, gradient w.r.t. :attr:`input` will be a sparse tensor.
        out (Tensor, optional): the destination tensor

    Example::

        >>> t = torch.tensor([[1, 2], [3, 4]])
        >>> torch.gather(t, 1, torch.tensor([[0, 0], [1, 0]]))
        tensor([[ 1,  1],
                [ 4,  3]])
    """

def gcd(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    gcd(input, other, *, out=None) -> Tensor

    Computes the element-wise greatest common divisor (GCD) of :attr:`input` and :attr:`other`.

    Both :attr:`input` and :attr:`other` must have integer types.

    .. note::
        This defines :math:`gcd(0, 0) = 0`.

    Args:
        input (Tensor): the input tensor.
        other (Tensor): the second input tensor

    Keyword arguments:
        out (Tensor, optional): the output tensor.

    Example::

        >>> a = torch.tensor([5, 10, 15])
        >>> b = torch.tensor([3, 4, 5])
        >>> torch.gcd(a, b)
        tensor([1, 2, 5])
        >>> c = torch.tensor([3])
        >>> torch.gcd(a, c)
        tensor([1, 1, 3])
    """

def gcd_(input: Tensor, other: Tensor) -> Tensor: ...
@overload
def ge(
    input: Tensor,
    other: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    ge(input, other, *, out=None) -> Tensor

    Computes :math:`\text{input} \geq \text{other}` element-wise.


    The second argument can be a number or a tensor whose shape is
    :ref:`broadcastable <broadcasting-semantics>` with the first argument.

    Args:
        input (Tensor): the tensor to compare
        other (Tensor or float): the tensor or value to compare

    Keyword args:
        out (Tensor, optional): the output tensor.

    Returns:
        A boolean tensor that is True where :attr:`input` is greater than or equal to :attr:`other` and False elsewhere

    Example::

        >>> torch.ge(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
        tensor([[True, True], [False, True]])
    """

@overload
def ge(
    input: Tensor,
    other: Number | _complex,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    ge(input, other, *, out=None) -> Tensor

    Computes :math:`\text{input} \geq \text{other}` element-wise.


    The second argument can be a number or a tensor whose shape is
    :ref:`broadcastable <broadcasting-semantics>` with the first argument.

    Args:
        input (Tensor): the tensor to compare
        other (Tensor or float): the tensor or value to compare

    Keyword args:
        out (Tensor, optional): the output tensor.

    Returns:
        A boolean tensor that is True where :attr:`input` is greater than or equal to :attr:`other` and False elsewhere

    Example::

        >>> torch.ge(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))
        tensor([[True, True], [False, True]])
    """

def geqrf(
    input: Tensor,
    *,
    out: Tensor | tuple[Tensor, ...] | list[Tensor] | None = None,
) -> torch.return_types.geqrf:
    r"""
    geqrf(input, *, out=None) -> (Tensor, Tensor)

    This is a low-level function for calling LAPACK's geqrf directly. This function
    returns a namedtuple (a, tau) as defined in `LAPACK documentation for geqrf`_ .

    Computes a QR decomposition of :attr:`input`.
    Both `Q` and `R` matrices are stored in the same output tensor `a`.
    The elements of `R` are stored on and above the diagonal.
    Elementary reflectors (or Householder vectors) implicitly defining matrix `Q`
    are stored below the diagonal.
    The results of this function can be used together with :func:`torch.linalg.householder_product`
    to obtain the `Q` matrix or
    with :func:`torch.ormqr`, which uses an implicit representation of the `Q` matrix,
    for an efficient matrix-matrix multiplication.

    See `LAPACK documentation for geqrf`_ for further details.

    .. note::
        See also :func:`torch.linalg.qr`, which computes Q and R matrices, and :func:`torch.linalg.lstsq`
        with the ``driver="gels"`` option for a function that can solve matrix equations using a QR decomposition.

    Args:
        input (Tensor): the input matrix

    Keyword args:
        out (tuple, optional): the output tuple of (Tensor, Tensor). Ignored if `None`. Default: `None`.

    .. _LAPACK documentation for geqrf:
        http://www.netlib.org/lapack/explore-html/df/dc5/group__variants_g_ecomputational_ga3766ea903391b5cf9008132f7440ec7b.html
    """

def ger(
    input: Tensor,
    vec2: Tensor,
    *,
    out: Tensor | None = None,
) -> Tensor:
    r"""
    ger(input, vec2, *, out=None) -> Tensor

    Alias of :func:`torch.outer`.

    .. warning::
        This function is deprecated and will be removed in a future PyTorch release.
        Use :func:`torch.outer` instead.
    """

def get_default_dtype() -> _dtype:
    r"""
    get_default_dtype() -> torch.dtype

    Get the current default floating point :class:`torch.dtype`.

    Example::

        >>> torch.get_default_dtype()  # initial default for floating point is torch.float32
        torch.float32
        >>> torch.set_default_dtype(torch.float64)
        >>> torch.get_default_dtype()  # default is now changed to torch.float64
        torch.float64
    """

def get_num_interop_threads() -> _int:
    r"""
    get_num_interop_threads() -> int

    Returns the number of threads used for inter-op parallelism on CPU
    (e.g. in JIT interpreter)
    """

def get_num_threads() -> _int:
    r"""
    get_num_threads() -> int

    Returns the number of threads used for parallelizing CPU operations
    """

@overload
def gradient(
    input: Tensor,
    *,
    spacing: Number | _complex | None = None,
    dim: _int | None = None,
    edge_order: _int = 1,
) -> tuple[Tensor, ...]:
    r"""
    gradient(input, *, spacing=1, dim=None, edge_order=1) -> List of Tensors

    Estimates the gradient of a function :math:`g : \mathbb{R}^n \rightarrow \mathbb{R}` in
    one or more dimensions using the `second-order accurate central differences method
    <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ and
    either first or second order estimates at the boundaries.

    The gradient of :math:`g` is estimated using samples. By default, when :attr:`spacing` is not
    specified, the samples are entirely described by :attr:`input`, and the mapping of input coordinates
    to an output is the same as the tensor's mapping of indices to values. For example, for a three-dimensional
    :attr:`input` the function described is :math:`g : \mathbb{R}^3 \rightarrow \mathbb{R}`, and
    :math:`g(1, 2, 3)\ == input[1, 2, 3]`.

    When :attr:`spacing` is specified, it modifies the relationship between :attr:`input` and input coordinates.
    This is detailed in the "Keyword Arguments" section below.

    The gradient is estimated by estimating each partial derivative of :math:`g` independently. This estimation is
    accurate if :math:`g` is in :math:`C^3` (it has at least 3 continuous derivatives), and the estimation can be
    improved by providing closer samples. Mathematically, the value at each interior point of a partial derivative
    is estimated using `Taylor's theorem with remainder <https://en.wikipedia.org/wiki/Taylor%27s_theorem>`_.
    Letting :math:`x` be an interior point with :math:`x-h_l` and :math:`x+h_r` be points neighboring
    it to the left and right respectively, :math:`f(x+h_r)` and :math:`f(x-h_l)` can be estimated using:

    .. math::
        \begin{aligned}
            f(x+h_r) = f(x) + h_r f'(x) + {h_r}^2  \frac{f''(x)}{2} + {h_r}^3 \frac{f'''(\xi_1)}{6}, \xi_1 \in (x, x+h_r) \\
            f(x-h_l) = f(x) - h_l f'(x) + {h_l}^2  \frac{f''(x)}{2} - {h_l}^3 \frac{f'''(\xi_2)}{6}, \xi_2 \in (x, x-h_l) \\
        \end{aligned}

    Using the fact that :math:`f \in C^3` and solving the linear system, we derive:

    .. math::
        f'(x) \approx \frac{ {h_l}^2 f(x+h_r) - {h_r}^2 f(x-h_l)
              + ({h_r}^2-{h_l}^2 ) f(x) }{ {h_r} {h_l}^2 + {h_r}^2 {h_l} }

    .. note::
        We estimate the gradient of functions in complex domain
        :math:`g : \mathbb{C}^n \rightarrow \mathbb{C}` in the same way.

    The value of each partial derivative at the boundary points is computed differently. See edge_order below.

    Args:
        input (``Tensor``): the tensor that represents the values of the function

    Keyword args:
        spacing (``scalar``, ``list of scalar``, ``list of Tensor``, optional): :attr:`spacing` can be used to modify
            how the :attr:`input` tensor's indices relate to sample coordinates. If :attr:`spacing` is a scalar then
            the indices are multiplied by the scalar to produce the coordinates. For example, if :attr:`spacing=2` the
            indices (1, 2, 3) become coordinates (2, 4, 6). If :attr:`spacing` is a list of scalars then the corresponding
            indices are multiplied. For example, if :attr:`spacing=(2, -1, 3)` the indices (1, 2, 3) become coordinates (2, -2, 9).
            Finally, if :attr:`spacing` is a list of one-dimensional tensors then each tensor specifies the coordinates for
            the corresponding dimension. For example, if the indices are (1, 2, 3) and the tensors are (t0, t1, t2), then
            the coordinates are (t0[1], t1[2], t2[3])

        dim (``int``, ``list of int``, optional): the dimension or dimensions to approximate the gradient over.  By default
            the partial  gradient in every dimension is computed. Note that when :attr:`dim` is  specified the elements of
            the :attr:`spacing` argument must correspond with the specified dims."

        edge_order (``int``, optional): 1 or 2, for `first-order
            <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ or
            `second-order <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_
            estimation of the boundary ("edge") values, respectively.

    Examples::

        >>> # Estimates the gradient of f(x)=x^2 at points [-2, -1, 2, 4]
        >>> coordinates = (torch.tensor([-2., -1., 1., 4.]),)
        >>> values = torch.tensor([4., 1., 1., 16.], )
        >>> torch.gradient(values, spacing = coordinates)
        (tensor([-3., -2., 2., 5.]),)

        >>> # Estimates the gradient of the R^2 -> R function whose samples are
        >>> # described by the tensor t. Implicit coordinates are [0, 1] for the outermost
        >>> # dimension and [0, 1, 2, 3] for the innermost dimension, and function estimates
        >>> # partial derivative for both dimensions.
        >>> t = torch.tensor([[1, 2, 4, 8], [10, 20, 40, 80]])
        >>> torch.gradient(t)
        (tensor([[ 9., 18., 36., 72.],
                 [ 9., 18., 36., 72.]]),
         tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]))

        >>> # A scalar value for spacing modifies the relationship between tensor indices
        >>> # and input coordinates by multiplying the indices to find the
        >>> # coordinates. For example, below the indices of the innermost
        >>> # 0, 1, 2, 3 translate to coordinates of [0, 2, 4, 6], and the indices of
        >>> # the outermost dimension 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = 2.0) # dim = None (implicitly [0, 1])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                  [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.5000, 0.7500, 1.5000, 2.0000],
                  [ 5.0000, 7.5000, 15.0000, 20.0000]]))
        >>> # doubling the spacing between samples halves the estimated partial gradients.

        >>>
        >>> # Estimates only the partial derivative for dimension 1
        >>> torch.gradient(t, dim = 1) # spacing = None (implicitly 1.)
        (tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]),)

        >>> # When spacing is a list of scalars, the relationship between the tensor
        >>> # indices and input coordinates changes based on dimension.
        >>> # For example, below, the indices of the innermost dimension 0, 1, 2, 3 translate
        >>> # to coordinates of [0, 3, 6, 9], and the indices of the outermost dimension
        >>> # 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = [3., 2.])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                 [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                 [ 3.3333, 5.0000, 10.0000, 13.3333]]))

        >>> # The following example is a replication of the previous one with explicit
        >>> # coordinates.
        >>> coords = (torch.tensor([0, 2]), torch.tensor([0, 3, 6, 9]))
        >>> torch.gradient(t, spacing = coords)
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                 [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                 [ 3.3333, 5.0000, 10.0000, 13.3333]]))
    """

@overload
def gradient(
    input: Tensor,
    *,
    spacing: Sequence[Number | _complex],
    dim: _int | None = None,
    edge_order: _int = 1,
) -> tuple[Tensor, ...]:
    r"""
    gradient(input, *, spacing=1, dim=None, edge_order=1) -> List of Tensors

    Estimates the gradient of a function :math:`g : \mathbb{R}^n \rightarrow \mathbb{R}` in
    one or more dimensions using the `second-order accurate central differences method
    <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ and
    either first or second order estimates at the boundaries.

    The gradient of :math:`g` is estimated using samples. By default, when :attr:`spacing` is not
    specified, the samples are entirely described by :attr:`input`, and the mapping of input coordinates
    to an output is the same as the tensor's mapping of indices to values. For example, for a three-dimensional
    :attr:`input` the function described is :math:`g : \mathbb{R}^3 \rightarrow \mathbb{R}`, and
    :math:`g(1, 2, 3)\ == input[1, 2, 3]`.

    When :attr:`spacing` is specified, it modifies the relationship between :attr:`input` and input coordinates.
    This is detailed in the "Keyword Arguments" section below.

    The gradient is estimated by estimating each partial derivative of :math:`g` independently. This estimation is
    accurate if :math:`g` is in :math:`C^3` (it has at least 3 continuous derivatives), and the estimation can be
    improved by providing closer samples. Mathematically, the value at each interior point of a partial derivative
    is estimated using `Taylor's theorem with remainder <https://en.wikipedia.org/wiki/Taylor%27s_theorem>`_.
    Letting :math:`x` be an interior point with :math:`x-h_l` and :math:`x+h_r` be points neighboring
    it to the left and right respectively, :math:`f(x+h_r)` and :math:`f(x-h_l)` can be estimated using:

    .. math::
        \begin{aligned}
            f(x+h_r) = f(x) + h_r f'(x) + {h_r}^2  \frac{f''(x)}{2} + {h_r}^3 \frac{f'''(\xi_1)}{6}, \xi_1 \in (x, x+h_r) \\
            f(x-h_l) = f(x) - h_l f'(x) + {h_l}^2  \frac{f''(x)}{2} - {h_l}^3 \frac{f'''(\xi_2)}{6}, \xi_2 \in (x, x-h_l) \\
        \end{aligned}

    Using the fact that :math:`f \in C^3` and solving the linear system, we derive:

    .. math::
        f'(x) \approx \frac{ {h_l}^2 f(x+h_r) - {h_r}^2 f(x-h_l)
              + ({h_r}^2-{h_l}^2 ) f(x) }{ {h_r} {h_l}^2 + {h_r}^2 {h_l} }

    .. note::
        We estimate the gradient of functions in complex domain
        :math:`g : \mathbb{C}^n \rightarrow \mathbb{C}` in the same way.

    The value of each partial derivative at the boundary points is computed differently. See edge_order below.

    Args:
        input (``Tensor``): the tensor that represents the values of the function

    Keyword args:
        spacing (``scalar``, ``list of scalar``, ``list of Tensor``, optional): :attr:`spacing` can be used to modify
            how the :attr:`input` tensor's indices relate to sample coordinates. If :attr:`spacing` is a scalar then
            the indices are multiplied by the scalar to produce the coordinates. For example, if :attr:`spacing=2` the
            indices (1, 2, 3) become coordinates (2, 4, 6). If :attr:`spacing` is a list of scalars then the corresponding
            indices are multiplied. For example, if :attr:`spacing=(2, -1, 3)` the indices (1, 2, 3) become coordinates (2, -2, 9).
            Finally, if :attr:`spacing` is a list of one-dimensional tensors then each tensor specifies the coordinates for
            the corresponding dimension. For example, if the indices are (1, 2, 3) and the tensors are (t0, t1, t2), then
            the coordinates are (t0[1], t1[2], t2[3])

        dim (``int``, ``list of int``, optional): the dimension or dimensions to approximate the gradient over.  By default
            the partial  gradient in every dimension is computed. Note that when :attr:`dim` is  specified the elements of
            the :attr:`spacing` argument must correspond with the specified dims."

        edge_order (``int``, optional): 1 or 2, for `first-order
            <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ or
            `second-order <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_
            estimation of the boundary ("edge") values, respectively.

    Examples::

        >>> # Estimates the gradient of f(x)=x^2 at points [-2, -1, 2, 4]
        >>> coordinates = (torch.tensor([-2., -1., 1., 4.]),)
        >>> values = torch.tensor([4., 1., 1., 16.], )
        >>> torch.gradient(values, spacing = coordinates)
        (tensor([-3., -2., 2., 5.]),)

        >>> # Estimates the gradient of the R^2 -> R function whose samples are
        >>> # described by the tensor t. Implicit coordinates are [0, 1] for the outermost
        >>> # dimension and [0, 1, 2, 3] for the innermost dimension, and function estimates
        >>> # partial derivative for both dimensions.
        >>> t = torch.tensor([[1, 2, 4, 8], [10, 20, 40, 80]])
        >>> torch.gradient(t)
        (tensor([[ 9., 18., 36., 72.],
                 [ 9., 18., 36., 72.]]),
         tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]))

        >>> # A scalar value for spacing modifies the relationship between tensor indices
        >>> # and input coordinates by multiplying the indices to find the
        >>> # coordinates. For example, below the indices of the innermost
        >>> # 0, 1, 2, 3 translate to coordinates of [0, 2, 4, 6], and the indices of
        >>> # the outermost dimension 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = 2.0) # dim = None (implicitly [0, 1])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                  [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.5000, 0.7500, 1.5000, 2.0000],
                  [ 5.0000, 7.5000, 15.0000, 20.0000]]))
        >>> # doubling the spacing between samples halves the estimated partial gradients.

        >>>
        >>> # Estimates only the partial derivative for dimension 1
        >>> torch.gradient(t, dim = 1) # spacing = None (implicitly 1.)
        (tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]),)

        >>> # When spacing is a list of scalars, the relationship between the tensor
        >>> # indices and input coordinates changes based on dimension.
        >>> # For example, below, the indices of the innermost dimension 0, 1, 2, 3 translate
        >>> # to coordinates of [0, 3, 6, 9], and the indices of the outermost dimension
        >>> # 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = [3., 2.])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                 [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                 [ 3.3333, 5.0000, 10.0000, 13.3333]]))

        >>> # The following example is a replication of the previous one with explicit
        >>> # coordinates.
        >>> coords = (torch.tensor([0, 2]), torch.tensor([0, 3, 6, 9]))
        >>> torch.gradient(t, spacing = coords)
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                 [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                 [ 3.3333, 5.0000, 10.0000, 13.3333]]))
    """

@overload
def gradient(
    input: Tensor,
    *,
    spacing: Sequence[Number | _complex],
    dim: _size,
    edge_order: _int = 1,
) -> tuple[Tensor, ...]:
    r"""
    gradient(input, *, spacing=1, dim=None, edge_order=1) -> List of Tensors

    Estimates the gradient of a function :math:`g : \mathbb{R}^n \rightarrow \mathbb{R}` in
    one or more dimensions using the `second-order accurate central differences method
    <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ and
    either first or second order estimates at the boundaries.

    The gradient of :math:`g` is estimated using samples. By default, when :attr:`spacing` is not
    specified, the samples are entirely described by :attr:`input`, and the mapping of input coordinates
    to an output is the same as the tensor's mapping of indices to values. For example, for a three-dimensional
    :attr:`input` the function described is :math:`g : \mathbb{R}^3 \rightarrow \mathbb{R}`, and
    :math:`g(1, 2, 3)\ == input[1, 2, 3]`.

    When :attr:`spacing` is specified, it modifies the relationship between :attr:`input` and input coordinates.
    This is detailed in the "Keyword Arguments" section below.

    The gradient is estimated by estimating each partial derivative of :math:`g` independently. This estimation is
    accurate if :math:`g` is in :math:`C^3` (it has at least 3 continuous derivatives), and the estimation can be
    improved by providing closer samples. Mathematically, the value at each interior point of a partial derivative
    is estimated using `Taylor's theorem with remainder <https://en.wikipedia.org/wiki/Taylor%27s_theorem>`_.
    Letting :math:`x` be an interior point with :math:`x-h_l` and :math:`x+h_r` be points neighboring
    it to the left and right respectively, :math:`f(x+h_r)` and :math:`f(x-h_l)` can be estimated using:

    .. math::
        \begin{aligned}
            f(x+h_r) = f(x) + h_r f'(x) + {h_r}^2  \frac{f''(x)}{2} + {h_r}^3 \frac{f'''(\xi_1)}{6}, \xi_1 \in (x, x+h_r) \\
            f(x-h_l) = f(x) - h_l f'(x) + {h_l}^2  \frac{f''(x)}{2} - {h_l}^3 \frac{f'''(\xi_2)}{6}, \xi_2 \in (x, x-h_l) \\
        \end{aligned}

    Using the fact that :math:`f \in C^3` and solving the linear system, we derive:

    .. math::
        f'(x) \approx \frac{ {h_l}^2 f(x+h_r) - {h_r}^2 f(x-h_l)
              + ({h_r}^2-{h_l}^2 ) f(x) }{ {h_r} {h_l}^2 + {h_r}^2 {h_l} }

    .. note::
        We estimate the gradient of functions in complex domain
        :math:`g : \mathbb{C}^n \rightarrow \mathbb{C}` in the same way.

    The value of each partial derivative at the boundary points is computed differently. See edge_order below.

    Args:
        input (``Tensor``): the tensor that represents the values of the function

    Keyword args:
        spacing (``scalar``, ``list of scalar``, ``list of Tensor``, optional): :attr:`spacing` can be used to modify
            how the :attr:`input` tensor's indices relate to sample coordinates. If :attr:`spacing` is a scalar then
            the indices are multiplied by the scalar to produce the coordinates. For example, if :attr:`spacing=2` the
            indices (1, 2, 3) become coordinates (2, 4, 6). If :attr:`spacing` is a list of scalars then the corresponding
            indices are multiplied. For example, if :attr:`spacing=(2, -1, 3)` the indices (1, 2, 3) become coordinates (2, -2, 9).
            Finally, if :attr:`spacing` is a list of one-dimensional tensors then each tensor specifies the coordinates for
            the corresponding dimension. For example, if the indices are (1, 2, 3) and the tensors are (t0, t1, t2), then
            the coordinates are (t0[1], t1[2], t2[3])

        dim (``int``, ``list of int``, optional): the dimension or dimensions to approximate the gradient over.  By default
            the partial  gradient in every dimension is computed. Note that when :attr:`dim` is  specified the elements of
            the :attr:`spacing` argument must correspond with the specified dims."

        edge_order (``int``, optional): 1 or 2, for `first-order
            <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ or
            `second-order <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_
            estimation of the boundary ("edge") values, respectively.

    Examples::

        >>> # Estimates the gradient of f(x)=x^2 at points [-2, -1, 2, 4]
        >>> coordinates = (torch.tensor([-2., -1., 1., 4.]),)
        >>> values = torch.tensor([4., 1., 1., 16.], )
        >>> torch.gradient(values, spacing = coordinates)
        (tensor([-3., -2., 2., 5.]),)

        >>> # Estimates the gradient of the R^2 -> R function whose samples are
        >>> # described by the tensor t. Implicit coordinates are [0, 1] for the outermost
        >>> # dimension and [0, 1, 2, 3] for the innermost dimension, and function estimates
        >>> # partial derivative for both dimensions.
        >>> t = torch.tensor([[1, 2, 4, 8], [10, 20, 40, 80]])
        >>> torch.gradient(t)
        (tensor([[ 9., 18., 36., 72.],
                 [ 9., 18., 36., 72.]]),
         tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]))

        >>> # A scalar value for spacing modifies the relationship between tensor indices
        >>> # and input coordinates by multiplying the indices to find the
        >>> # coordinates. For example, below the indices of the innermost
        >>> # 0, 1, 2, 3 translate to coordinates of [0, 2, 4, 6], and the indices of
        >>> # the outermost dimension 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = 2.0) # dim = None (implicitly [0, 1])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                  [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.5000, 0.7500, 1.5000, 2.0000],
                  [ 5.0000, 7.5000, 15.0000, 20.0000]]))
        >>> # doubling the spacing between samples halves the estimated partial gradients.

        >>>
        >>> # Estimates only the partial derivative for dimension 1
        >>> torch.gradient(t, dim = 1) # spacing = None (implicitly 1.)
        (tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]),)

        >>> # When spacing is a list of scalars, the relationship between the tensor
        >>> # indices and input coordinates changes based on dimension.
        >>> # For example, below, the indices of the innermost dimension 0, 1, 2, 3 translate
        >>> # to coordinates of [0, 3, 6, 9], and the indices of the outermost dimension
        >>> # 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = [3., 2.])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                 [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                 [ 3.3333, 5.0000, 10.0000, 13.3333]]))

        >>> # The following example is a replication of the previous one with explicit
        >>> # coordinates.
        >>> coords = (torch.tensor([0, 2]), torch.tensor([0, 3, 6, 9]))
        >>> torch.gradient(t, spacing = coords)
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                 [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                 [ 3.3333, 5.0000, 10.0000, 13.3333]]))
    """

@overload
def gradient(
    input: Tensor,
    *,
    spacing: tuple[Tensor, ...] | list[Tensor] | None,
    dim: _int | None = None,
    edge_order: _int = 1,
) -> tuple[Tensor, ...]:
    r"""
    gradient(input, *, spacing=1, dim=None, edge_order=1) -> List of Tensors

    Estimates the gradient of a function :math:`g : \mathbb{R}^n \rightarrow \mathbb{R}` in
    one or more dimensions using the `second-order accurate central differences method
    <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ and
    either first or second order estimates at the boundaries.

    The gradient of :math:`g` is estimated using samples. By default, when :attr:`spacing` is not
    specified, the samples are entirely described by :attr:`input`, and the mapping of input coordinates
    to an output is the same as the tensor's mapping of indices to values. For example, for a three-dimensional
    :attr:`input` the function described is :math:`g : \mathbb{R}^3 \rightarrow \mathbb{R}`, and
    :math:`g(1, 2, 3)\ == input[1, 2, 3]`.

    When :attr:`spacing` is specified, it modifies the relationship between :attr:`input` and input coordinates.
    This is detailed in the "Keyword Arguments" section below.

    The gradient is estimated by estimating each partial derivative of :math:`g` independently. This estimation is
    accurate if :math:`g` is in :math:`C^3` (it has at least 3 continuous derivatives), and the estimation can be
    improved by providing closer samples. Mathematically, the value at each interior point of a partial derivative
    is estimated using `Taylor's theorem with remainder <https://en.wikipedia.org/wiki/Taylor%27s_theorem>`_.
    Letting :math:`x` be an interior point with :math:`x-h_l` and :math:`x+h_r` be points neighboring
    it to the left and right respectively, :math:`f(x+h_r)` and :math:`f(x-h_l)` can be estimated using:

    .. math::
        \begin{aligned}
            f(x+h_r) = f(x) + h_r f'(x) + {h_r}^2  \frac{f''(x)}{2} + {h_r}^3 \frac{f'''(\xi_1)}{6}, \xi_1 \in (x, x+h_r) \\
            f(x-h_l) = f(x) - h_l f'(x) + {h_l}^2  \frac{f''(x)}{2} - {h_l}^3 \frac{f'''(\xi_2)}{6}, \xi_2 \in (x, x-h_l) \\
        \end{aligned}

    Using the fact that :math:`f \in C^3` and solving the linear system, we derive:

    .. math::
        f'(x) \approx \frac{ {h_l}^2 f(x+h_r) - {h_r}^2 f(x-h_l)
              + ({h_r}^2-{h_l}^2 ) f(x) }{ {h_r} {h_l}^2 + {h_r}^2 {h_l} }

    .. note::
        We estimate the gradient of functions in complex domain
        :math:`g : \mathbb{C}^n \rightarrow \mathbb{C}` in the same way.

    The value of each partial derivative at the boundary points is computed differently. See edge_order below.

    Args:
        input (``Tensor``): the tensor that represents the values of the function

    Keyword args:
        spacing (``scalar``, ``list of scalar``, ``list of Tensor``, optional): :attr:`spacing` can be used to modify
            how the :attr:`input` tensor's indices relate to sample coordinates. If :attr:`spacing` is a scalar then
            the indices are multiplied by the scalar to produce the coordinates. For example, if :attr:`spacing=2` the
            indices (1, 2, 3) become coordinates (2, 4, 6). If :attr:`spacing` is a list of scalars then the corresponding
            indices are multiplied. For example, if :attr:`spacing=(2, -1, 3)` the indices (1, 2, 3) become coordinates (2, -2, 9).
            Finally, if :attr:`spacing` is a list of one-dimensional tensors then each tensor specifies the coordinates for
            the corresponding dimension. For example, if the indices are (1, 2, 3) and the tensors are (t0, t1, t2), then
            the coordinates are (t0[1], t1[2], t2[3])

        dim (``int``, ``list of int``, optional): the dimension or dimensions to approximate the gradient over.  By default
            the partial  gradient in every dimension is computed. Note that when :attr:`dim` is  specified the elements of
            the :attr:`spacing` argument must correspond with the specified dims."

        edge_order (``int``, optional): 1 or 2, for `first-order
            <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ or
            `second-order <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_
            estimation of the boundary ("edge") values, respectively.

    Examples::

        >>> # Estimates the gradient of f(x)=x^2 at points [-2, -1, 2, 4]
        >>> coordinates = (torch.tensor([-2., -1., 1., 4.]),)
        >>> values = torch.tensor([4., 1., 1., 16.], )
        >>> torch.gradient(values, spacing = coordinates)
        (tensor([-3., -2., 2., 5.]),)

        >>> # Estimates the gradient of the R^2 -> R function whose samples are
        >>> # described by the tensor t. Implicit coordinates are [0, 1] for the outermost
        >>> # dimension and [0, 1, 2, 3] for the innermost dimension, and function estimates
        >>> # partial derivative for both dimensions.
        >>> t = torch.tensor([[1, 2, 4, 8], [10, 20, 40, 80]])
        >>> torch.gradient(t)
        (tensor([[ 9., 18., 36., 72.],
                 [ 9., 18., 36., 72.]]),
         tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]))

        >>> # A scalar value for spacing modifies the relationship between tensor indices
        >>> # and input coordinates by multiplying the indices to find the
        >>> # coordinates. For example, below the indices of the innermost
        >>> # 0, 1, 2, 3 translate to coordinates of [0, 2, 4, 6], and the indices of
        >>> # the outermost dimension 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = 2.0) # dim = None (implicitly [0, 1])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                  [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.5000, 0.7500, 1.5000, 2.0000],
                  [ 5.0000, 7.5000, 15.0000, 20.0000]]))
        >>> # doubling the spacing between samples halves the estimated partial gradients.

        >>>
        >>> # Estimates only the partial derivative for dimension 1
        >>> torch.gradient(t, dim = 1) # spacing = None (implicitly 1.)
        (tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]),)

        >>> # When spacing is a list of scalars, the relationship between the tensor
        >>> # indices and input coordinates changes based on dimension.
        >>> # For example, below, the indices of the innermost dimension 0, 1, 2, 3 translate
        >>> # to coordinates of [0, 3, 6, 9], and the indices of the outermost dimension
        >>> # 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = [3., 2.])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                 [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                 [ 3.3333, 5.0000, 10.0000, 13.3333]]))

        >>> # The following example is a replication of the previous one with explicit
        >>> # coordinates.
        >>> coords = (torch.tensor([0, 2]), torch.tensor([0, 3, 6, 9]))
        >>> torch.gradient(t, spacing = coords)
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                 [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                 [ 3.3333, 5.0000, 10.0000, 13.3333]]))
    """

@overload
def gradient(
    input: Tensor,
    *,
    spacing: Number | _complex,
    dim: _size,
    edge_order: _int = 1,
) -> tuple[Tensor, ...]:
    r"""
    gradient(input, *, spacing=1, dim=None, edge_order=1) -> List of Tensors

    Estimates the gradient of a function :math:`g : \mathbb{R}^n \rightarrow \mathbb{R}` in
    one or more dimensions using the `second-order accurate central differences method
    <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ and
    either first or second order estimates at the boundaries.

    The gradient of :math:`g` is estimated using samples. By default, when :attr:`spacing` is not
    specified, the samples are entirely described by :attr:`input`, and the mapping of input coordinates
    to an output is the same as the tensor's mapping of indices to values. For example, for a three-dimensional
    :attr:`input` the function described is :math:`g : \mathbb{R}^3 \rightarrow \mathbb{R}`, and
    :math:`g(1, 2, 3)\ == input[1, 2, 3]`.

    When :attr:`spacing` is specified, it modifies the relationship between :attr:`input` and input coordinates.
    This is detailed in the "Keyword Arguments" section below.

    The gradient is estimated by estimating each partial derivative of :math:`g` independently. This estimation is
    accurate if :math:`g` is in :math:`C^3` (it has at least 3 continuous derivatives), and the estimation can be
    improved by providing closer samples. Mathematically, the value at each interior point of a partial derivative
    is estimated using `Taylor's theorem with remainder <https://en.wikipedia.org/wiki/Taylor%27s_theorem>`_.
    Letting :math:`x` be an interior point with :math:`x-h_l` and :math:`x+h_r` be points neighboring
    it to the left and right respectively, :math:`f(x+h_r)` and :math:`f(x-h_l)` can be estimated using:

    .. math::
        \begin{aligned}
            f(x+h_r) = f(x) + h_r f'(x) + {h_r}^2  \frac{f''(x)}{2} + {h_r}^3 \frac{f'''(\xi_1)}{6}, \xi_1 \in (x, x+h_r) \\
            f(x-h_l) = f(x) - h_l f'(x) + {h_l}^2  \frac{f''(x)}{2} - {h_l}^3 \frac{f'''(\xi_2)}{6}, \xi_2 \in (x, x-h_l) \\
        \end{aligned}

    Using the fact that :math:`f \in C^3` and solving the linear system, we derive:

    .. math::
        f'(x) \approx \frac{ {h_l}^2 f(x+h_r) - {h_r}^2 f(x-h_l)
              + ({h_r}^2-{h_l}^2 ) f(x) }{ {h_r} {h_l}^2 + {h_r}^2 {h_l} }

    .. note::
        We estimate the gradient of functions in complex domain
        :math:`g : \mathbb{C}^n \rightarrow \mathbb{C}` in the same way.

    The value of each partial derivative at the boundary points is computed differently. See edge_order below.

    Args:
        input (``Tensor``): the tensor that represents the values of the function

    Keyword args:
        spacing (``scalar``, ``list of scalar``, ``list of Tensor``, optional): :attr:`spacing` can be used to modify
            how the :attr:`input` tensor's indices relate to sample coordinates. If :attr:`spacing` is a scalar then
            the indices are multiplied by the scalar to produce the coordinates. For example, if :attr:`spacing=2` the
            indices (1, 2, 3) become coordinates (2, 4, 6). If :attr:`spacing` is a list of scalars then the corresponding
            indices are multiplied. For example, if :attr:`spacing=(2, -1, 3)` the indices (1, 2, 3) become coordinates (2, -2, 9).
            Finally, if :attr:`spacing` is a list of one-dimensional tensors then each tensor specifies the coordinates for
            the corresponding dimension. For example, if the indices are (1, 2, 3) and the tensors are (t0, t1, t2), then
            the coordinates are (t0[1], t1[2], t2[3])

        dim (``int``, ``list of int``, optional): the dimension or dimensions to approximate the gradient over.  By default
            the partial  gradient in every dimension is computed. Note that when :attr:`dim` is  specified the elements of
            the :attr:`spacing` argument must correspond with the specified dims."

        edge_order (``int``, optional): 1 or 2, for `first-order
            <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ or
            `second-order <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_
            estimation of the boundary ("edge") values, respectively.

    Examples::

        >>> # Estimates the gradient of f(x)=x^2 at points [-2, -1, 2, 4]
        >>> coordinates = (torch.tensor([-2., -1., 1., 4.]),)
        >>> values = torch.tensor([4., 1., 1., 16.], )
        >>> torch.gradient(values, spacing = coordinates)
        (tensor([-3., -2., 2., 5.]),)

        >>> # Estimates the gradient of the R^2 -> R function whose samples are
        >>> # described by the tensor t. Implicit coordinates are [0, 1] for the outermost
        >>> # dimension and [0, 1, 2, 3] for the innermost dimension, and function estimates
        >>> # partial derivative for both dimensions.
        >>> t = torch.tensor([[1, 2, 4, 8], [10, 20, 40, 80]])
        >>> torch.gradient(t)
        (tensor([[ 9., 18., 36., 72.],
                 [ 9., 18., 36., 72.]]),
         tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]))

        >>> # A scalar value for spacing modifies the relationship between tensor indices
        >>> # and input coordinates by multiplying the indices to find the
        >>> # coordinates. For example, below the indices of the innermost
        >>> # 0, 1, 2, 3 translate to coordinates of [0, 2, 4, 6], and the indices of
        >>> # the outermost dimension 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = 2.0) # dim = None (implicitly [0, 1])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                  [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.5000, 0.7500, 1.5000, 2.0000],
                  [ 5.0000, 7.5000, 15.0000, 20.0000]]))
        >>> # doubling the spacing between samples halves the estimated partial gradients.

        >>>
        >>> # Estimates only the partial derivative for dimension 1
        >>> torch.gradient(t, dim = 1) # spacing = None (implicitly 1.)
        (tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]),)

        >>> # When spacing is a list of scalars, the relationship between the tensor
        >>> # indices and input coordinates changes based on dimension.
        >>> # For example, below, the indices of the innermost dimension 0, 1, 2, 3 translate
        >>> # to coordinates of [0, 3, 6, 9], and the indices of the outermost dimension
        >>> # 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = [3., 2.])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                 [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                 [ 3.3333, 5.0000, 10.0000, 13.3333]]))

        >>> # The following example is a replication of the previous one with explicit
        >>> # coordinates.
        >>> coords = (torch.tensor([0, 2]), torch.tensor([0, 3, 6, 9]))
        >>> torch.gradient(t, spacing = coords)
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                 [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                 [ 3.3333, 5.0000, 10.0000, 13.3333]]))
    """

@overload
def gradient(
    input: Tensor,
    *,
    spacing: tuple[Tensor, ...] | list[Tensor] | None,
    dim: _size,
    edge_order: _int = 1,
) -> tuple[Tensor, ...]:
    r"""
    gradient(input, *, spacing=1, dim=None, edge_order=1) -> List of Tensors

    Estimates the gradient of a function :math:`g : \mathbb{R}^n \rightarrow \mathbb{R}` in
    one or more dimensions using the `second-order accurate central differences method
    <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ and
    either first or second order estimates at the boundaries.

    The gradient of :math:`g` is estimated using samples. By default, when :attr:`spacing` is not
    specified, the samples are entirely described by :attr:`input`, and the mapping of input coordinates
    to an output is the same as the tensor's mapping of indices to values. For example, for a three-dimensional
    :attr:`input` the function described is :math:`g : \mathbb{R}^3 \rightarrow \mathbb{R}`, and
    :math:`g(1, 2, 3)\ == input[1, 2, 3]`.

    When :attr:`spacing` is specified, it modifies the relationship between :attr:`input` and input coordinates.
    This is detailed in the "Keyword Arguments" section below.

    The gradient is estimated by estimating each partial derivative of :math:`g` independently. This estimation is
    accurate if :math:`g` is in :math:`C^3` (it has at least 3 continuous derivatives), and the estimation can be
    improved by providing closer samples. Mathematically, the value at each interior point of a partial derivative
    is estimated using `Taylor's theorem with remainder <https://en.wikipedia.org/wiki/Taylor%27s_theorem>`_.
    Letting :math:`x` be an interior point with :math:`x-h_l` and :math:`x+h_r` be points neighboring
    it to the left and right respectively, :math:`f(x+h_r)` and :math:`f(x-h_l)` can be estimated using:

    .. math::
        \begin{aligned}
            f(x+h_r) = f(x) + h_r f'(x) + {h_r}^2  \frac{f''(x)}{2} + {h_r}^3 \frac{f'''(\xi_1)}{6}, \xi_1 \in (x, x+h_r) \\
            f(x-h_l) = f(x) - h_l f'(x) + {h_l}^2  \frac{f''(x)}{2} - {h_l}^3 \frac{f'''(\xi_2)}{6}, \xi_2 \in (x, x-h_l) \\
        \end{aligned}

    Using the fact that :math:`f \in C^3` and solving the linear system, we derive:

    .. math::
        f'(x) \approx \frac{ {h_l}^2 f(x+h_r) - {h_r}^2 f(x-h_l)
              + ({h_r}^2-{h_l}^2 ) f(x) }{ {h_r} {h_l}^2 + {h_r}^2 {h_l} }

    .. note::
        We estimate the gradient of functions in complex domain
        :math:`g : \mathbb{C}^n \rightarrow \mathbb{C}` in the same way.

    The value of each partial derivative at the boundary points is computed differently. See edge_order below.

    Args:
        input (``Tensor``): the tensor that represents the values of the function

    Keyword args:
        spacing (``scalar``, ``list of scalar``, ``list of Tensor``, optional): :attr:`spacing` can be used to modify
            how the :attr:`input` tensor's indices relate to sample coordinates. If :attr:`spacing` is a scalar then
            the indices are multiplied by the scalar to produce the coordinates. For example, if :attr:`spacing=2` the
            indices (1, 2, 3) become coordinates (2, 4, 6). If :attr:`spacing` is a list of scalars then the corresponding
            indices are multiplied. For example, if :attr:`spacing=(2, -1, 3)` the indices (1, 2, 3) become coordinates (2, -2, 9).
            Finally, if :attr:`spacing` is a list of one-dimensional tensors then each tensor specifies the coordinates for
            the corresponding dimension. For example, if the indices are (1, 2, 3) and the tensors are (t0, t1, t2), then
            the coordinates are (t0[1], t1[2], t2[3])

        dim (``int``, ``list of int``, optional): the dimension or dimensions to approximate the gradient over.  By default
            the partial  gradient in every dimension is computed. Note that when :attr:`dim` is  specified the elements of
            the :attr:`spacing` argument must correspond with the specified dims."

        edge_order (``int``, optional): 1 or 2, for `first-order
            <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ or
            `second-order <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_
            estimation of the boundary ("edge") values, respectively.

    Examples::

        >>> # Estimates the gradient of f(x)=x^2 at points [-2, -1, 2, 4]
        >>> coordinates = (torch.tensor([-2., -1., 1., 4.]),)
        >>> values = torch.tensor([4., 1., 1., 16.], )
        >>> torch.gradient(values, spacing = coordinates)
        (tensor([-3., -2., 2., 5.]),)

        >>> # Estimates the gradient of the R^2 -> R function whose samples are
        >>> # described by the tensor t. Implicit coordinates are [0, 1] for the outermost
        >>> # dimension and [0, 1, 2, 3] for the innermost dimension, and function estimates
        >>> # partial derivative for both dimensions.
        >>> t = torch.tensor([[1, 2, 4, 8], [10, 20, 40, 80]])
        >>> torch.gradient(t)
        (tensor([[ 9., 18., 36., 72.],
                 [ 9., 18., 36., 72.]]),
         tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]))

        >>> # A scalar value for spacing modifies the relationship between tensor indices
        >>> # and input coordinates by multiplying the indices to find the
        >>> # coordinates. For example, below the indices of the innermost
        >>> # 0, 1, 2, 3 translate to coordinates of [0, 2, 4, 6], and the indices of
        >>> # the outermost dimension 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = 2.0) # dim = None (implicitly [0, 1])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                  [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.5000, 0.7500, 1.5000, 2.0000],
                  [ 5.0000, 7.5000, 15.0000, 20.0000]]))
        >>> # doubling the spacing between samples halves the estimated partial gradients.

        >>>
        >>> # Estimates only the partial derivative for dimension 1
        >>> torch.gradient(t, dim = 1) # spacing = None (implicitly 1.)
        (tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]),)

        >>> # When spacing is a list of scalars, the relationship between the tensor
        >>> # indices and input coordinates changes based on dimension.
        >>> # For example, below, the indices of the innermost dimension 0, 1, 2, 3 translate
        >>> # to coordinates of [0, 3, 6, 9], and the indices of the outermost dimension
        >>> # 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = [3., 2.])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                 [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                 [ 3.3333, 5.0000, 10.0000, 13.3333]]))

        >>> # The following example is a replication of the previous one with explicit
        >>> # coordinates.
        >>> coords = (torch.tensor([0, 2]), torch.tensor([0, 3, 6, 9]))
        >>> torch.gradient(t, spacing = coords)
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                 [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],
                 [ 3.3333, 5.0000, 10.0000, 13.3333]]))
    """

@overload
def gradient(
    input: Tensor,
    *,
    dim: _size,
    edge_order: _int = 1,
) -> tuple[Tensor, ...]:
    r"""
    gradient(input, *, spacing=1, dim=None, edge_order=1) -> List of Tensors

    Estimates the gradient of a function :math:`g : \mathbb{R}^n \rightarrow \mathbb{R}` in
    one or more dimensions using the `second-order accurate central differences method
    <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ and
    either first or second order estimates at the boundaries.

    The gradient of :math:`g` is estimated using samples. By default, when :attr:`spacing` is not
    specified, the samples are entirely described by :attr:`input`, and the mapping of input coordinates
    to an output is the same as the tensor's mapping of indices to values. For example, for a three-dimensional
    :attr:`input` the function described is :math:`g : \mathbb{R}^3 \rightarrow \mathbb{R}`, and
    :math:`g(1, 2, 3)\ == input[1, 2, 3]`.

    When :attr:`spacing` is specified, it modifies the relationship between :attr:`input` and input coordinates.
    This is detailed in the "Keyword Arguments" section below.

    The gradient is estimated by estimating each partial derivative of :math:`g` independently. This estimation is
    accurate if :math:`g` is in :math:`C^3` (it has at least 3 continuous derivatives), and the estimation can be
    improved by providing closer samples. Mathematically, the value at each interior point of a partial derivative
    is estimated using `Taylor's theorem with remainder <https://en.wikipedia.org/wiki/Taylor%27s_theorem>`_.
    Letting :math:`x` be an interior point with :math:`x-h_l` and :math:`x+h_r` be points neighboring
    it to the left and right respectively, :math:`f(x+h_r)` and :math:`f(x-h_l)` can be estimated using:

    .. math::
        \begin{aligned}
            f(x+h_r) = f(x) + h_r f'(x) + {h_r}^2  \frac{f''(x)}{2} + {h_r}^3 \frac{f'''(\xi_1)}{6}, \xi_1 \in (x, x+h_r) \\
            f(x-h_l) = f(x) - h_l f'(x) + {h_l}^2  \frac{f''(x)}{2} - {h_l}^3 \frac{f'''(\xi_2)}{6}, \xi_2 \in (x, x-h_l) \\
        \end{aligned}

    Using the fact that :math:`f \in C^3` and solving the linear system, we derive:

    .. math::
        f'(x) \approx \frac{ {h_l}^2 f(x+h_r) - {h_r}^2 f(x-h_l)
              + ({h_r}^2-{h_l}^2 ) f(x) }{ {h_r} {h_l}^2 + {h_r}^2 {h_l} }

    .. note::
        We estimate the gradient of functions in complex domain
        :math:`g : \mathbb{C}^n \rightarrow \mathbb{C}` in the same way.

    The value of each partial derivative at the boundary points is computed differently. See edge_order below.

    Args:
        input (``Tensor``): the tensor that represents the values of the function

    Keyword args:
        spacing (``scalar``, ``list of scalar``, ``list of Tensor``, optional): :attr:`spacing` can be used to modify
            how the :attr:`input` tensor's indices relate to sample coordinates. If :attr:`spacing` is a scalar then
            the indices are multiplied by the scalar to produce the coordinates. For example, if :attr:`spacing=2` the
            indices (1, 2, 3) become coordinates (2, 4, 6). If :attr:`spacing` is a list of scalars then the corresponding
            indices are multiplied. For example, if :attr:`spacing=(2, -1, 3)` the indices (1, 2, 3) become coordinates (2, -2, 9).
            Finally, if :attr:`spacing` is a list of one-dimensional tensors then each tensor specifies the coordinates for
            the corresponding dimension. For example, if the indices are (1, 2, 3) and the tensors are (t0, t1, t2), then
            the coordinates are (t0[1], t1[2], t2[3])

        dim (``int``, ``list of int``, optional): the dimension or dimensions to approximate the gradient over.  By default
            the partial  gradient in every dimension is computed. Note that when :attr:`dim` is  specified the elements of
            the :attr:`spacing` argument must correspond with the specified dims."

        edge_order (``int``, optional): 1 or 2, for `first-order
            <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ or
            `second-order <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_
            estimation of the boundary ("edge") values, respectively.

    Examples::

        >>> # Estimates the gradient of f(x)=x^2 at points [-2, -1, 2, 4]
        >>> coordinates = (torch.tensor([-2., -1., 1., 4.]),)
        >>> values = torch.tensor([4., 1., 1., 16.], )
        >>> torch.gradient(values, spacing = coordinates)
        (tensor([-3., -2., 2., 5.]),)

        >>> # Estimates the gradient of the R^2 -> R function whose samples are
        >>> # described by the tensor t. Implicit coordinates are [0, 1] for the outermost
        >>> # dimension and [0, 1, 2, 3] for the innermost dimension, and function estimates
        >>> # partial derivative for both dimensions.
        >>> t = torch.tensor([[1, 2, 4, 8], [10, 20, 40, 80]])
        >>> torch.gradient(t)
        (tensor([[ 9., 18., 36., 72.],
                 [ 9., 18., 36., 72.]]),
         tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],
                 [10.0000, 15.0000, 30.0000, 40.0000]]))

        >>> # A scalar value for spacing modifies the relationship between tensor indices
        >>> # and input coordinates by multiplying the indices to find the
        >>> # coordinates. For example, below the indices of the innermost
        >>> # 0, 1, 2, 3 translate to coordinates of [0, 2, 4, 6], and the indices of
        >>> # the outermost dimension 0, 1 translate to coordinates of [0, 2].
        >>> torch.gradient(t, spacing = 2.0) # dim = None (implicitly [0, 1])
        (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],
                  [ 4.5000, 9.0000, 18.0000, 36.0000]]),
         tensor([[ 0.5000, 0.7500, 1.5000, 2.0000],
                  [ 5.0000, 7.50